<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 高效的ARC代码和陷阱 · Morefun With Coding</title><meta name="description" content="高效的ARC代码和陷阱 - Tinghui"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://morefun.mobi/atom.xml" title="Morefun With Coding"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Tinghui" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="mailto:tinghui.zhang3@gmail.com" target="_self" class="nav-list-link">EMAIL</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">高效的ARC代码和陷阱</h1><div class="post-info">2012年12月5日</div><div class="post-content"><p>Objective-C是一个非常酷的编程语言。<a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html" target="_blank" rel="external">TIOBE</a>已经公布了十一月的编程语言排行榜，Objective-C很可能会再次成为年度编程语言。Objective-C的流行不只是因为iOS和Mac OS X平台的原因，还得益于它在移动设备上的高性能。在Objective-C中，手动内存管理代替了垃圾回收机制。当然，现在Objective-C也不需要纯手动管理内存了，苹果引入了自动引用计数(Automatic Reference Counting, 简称ARC)机制，在编译时自动加入内存管理代码。大部分情况下，这非常棒。然而，当ARC和Core Foundation对象混用的时候，总是感觉很混乱。今天，我们聊聊ARC的要点和陷阱，尤其是用toll-free bridging将Objc对象和CF对象相互转换时的一些注意事项。<a id="more"></a></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>本文先简单的介绍一下ARC的两个主要的使用场景：Objective-C的property 和 ARC修饰符。然后再重点关注一下ARC与Core Foundation框架的内存管理问题。</p>
<h3 id="ARC-和-Objective-C的property"><a href="#ARC-和-Objective-C的property" class="headerlink" title="ARC 和 Objective-C的property"></a>ARC 和 Objective-C的property</h3><p>首先感谢一下，没有<a href="https://twitter.com/amattn" target="_blank" rel="external">@amattn</a>写的《ARC最佳实践》，就很难有这篇文章。点击这个链接查看<a href="http://amattn.com/2011/12/07/arc_best_practices.html" target="_blank" rel="external">ARC Best Practices</a>的原文。下面是我总结的文章中的重点：</p>
<ul>
<li><p>需要retain的实例变量对象，用 <code>strong</code>。</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> childObject;</div></pre></td></tr></table></figure>
</li>
<li><p>防止引用循环(reference cycle)，要用 <code>weak</code>。</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> delegate;</div></pre></td></tr></table></figure>
</li>
<li><p>基本数据类型，用 <code>assign</code>。</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> width;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> height;</div></pre></td></tr></table></figure>
</li>
<li><p>不可变的容器类型以及字符串和block，用 <code>copy</code>。要避免使用可变容器类型(比如：NSMutableArray这些…)作为property，如果要用可变的容器类型，就用 <code>strong</code>。</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>* name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>* components;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) (<span class="keyword">void</span> (^)(<span class="keyword">void</span>)) job;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span>* badPatterns;</div></pre></td></tr></table></figure>
</li>
<li><p>dealloc中</p>
<ul>
<li>移除观察者。</li>
<li>注销通知。</li>
<li><del>停掉timer。</del>(<strong>译注</strong>：因为系统会retain传递给timer的target对象，在timer停掉前，target对象是不会被dealloc的。 所以原文里的这点是错误的，<font color="red">别把停掉timer的操作放到dealloc中。</font>在确定不再需要当前这对象的时候，要主动停掉timer。)</li>
</ul>
</li>
<li><p>IBOutlets一般用 <code>weak</code>，除非它是文件的所有者(File’s Owner)在nib文件中的顶层对象。如果将它设置为strong了，就需要在<code>viewDidUnload</code>方法中将它设置为nil。</p>
<p>  (<strong>译注</strong>：<code>viewDidUnload</code>在iOS6.0以后没有了，要移到<code>didReciveMemoryWorning</code>中。详细请阅读苹果的《<a href="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/DefiningYourSubclass.html#//apple_ref/doc/uid/TP40007457-CH7-SW1" target="_blank" rel="external">View Controller Programming Guide for iOS</a>》)</p>
</li>
</ul>
<h3 id="ARC类型修饰符"><a href="#ARC类型修饰符" class="headerlink" title="ARC类型修饰符"></a>ARC类型修饰符</h3><p>类型修饰符的使用规则，可以看看我<a href="http://www.idryman.org/blog/2012/10/29/type-qualifiers/" target="_blank" rel="external">以前的一篇文章</a>。ARC相关的类型修饰符，有4个：</p>
<ul>
<li><code>__strong</code>表示到一个对象的强引用。只要有任意一个强引用指向对象，对象就不会被销毁。这个是ARC中所有对象的默认属性。</li>
<li><code>__weak</code>指定到一个对象的弱引用。弱引用不会使它指向的对象保持一直存在，当没有任何强引用指向这个对象后，对象会被释放，然后弱引用会指向nil。</li>
<li><code>__unsafe_unretained</code>指定到一个对象的弱引用，当它指向的对象被销毁后，它不会指向nil，就变成一个野指针了。</li>
<li><code>__autoreleasing</code>用来表示参数按引用传递，在函数返回后，这个参数就被自动释放了。</li>
</ul>
<p>注意，ARC类型修饰符只能用在指针上。也就是说，必须把修饰符放到星号的右边。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">MyClass * __<span class="keyword">weak</span> w_self = <span class="keyword">self</span>; <span class="comment">// 正确</span></div><div class="line">MyClass __<span class="keyword">weak</span> * w_self = <span class="keyword">self</span>; <span class="comment">// 错误! 可能导致很严重的bug!</span></div><div class="line">__<span class="keyword">weak</span> MyClass * w_self = <span class="keyword">self</span>; <span class="comment">// 错误!</span></div><div class="line"></div><div class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) w_self = <span class="keyword">self</span>;</div><div class="line"><span class="comment">// 正确，将会被展开为 __weak (MyClass *) w_self = self;</span></div><div class="line"><span class="comment">// (参见gcc的typeof说明)</span></div><div class="line"></div><div class="line"><span class="keyword">typeof</span>(<span class="keyword">self</span>) __<span class="keyword">weak</span> w_self = <span class="keyword">self</span>; <span class="comment">// 正确, 这个安全些</span></div></pre></td></tr></table></figure>
<p>等等，难道网上这么多写法都是错误的？哦，原来因为苹果官方文档里面提到：“你应该正确修饰变量。当修饰符用在对象变量上的时候，正确的格式是 <code>ClassName * qualifier variableName;</code> ”</p>
<blockquote>
<p>You should decorate variables correctly. When using qualifiers in an object variable declaration, the correct format is: <code>ClassName * qualifier variableName;</code></p>
</blockquote>
<h3 id="ARC-和-Toll-free绑定"><a href="#ARC-和-Toll-free绑定" class="headerlink" title="ARC 和 Toll-free绑定"></a>ARC 和 Toll-free绑定</h3><p>ARC和Core Foundation混用的时候坑最多。以下是一些重要的原则：</p>
<ul>
<li>传递Objc对象给一个CF引用时，要retain它。</li>
<li>传递一个CF引用给一个Objc对象时，要release它。</li>
<li>传递时如果不明确的指定对象的所有权，会很危险。有时Clang编译器会帮你修正，但不是总是会，这样就会造成很严重的问题。</li>
<li>Core Foundation里面没有autorelease。你必须遵守它的内存管理规则：<ul>
<li>名字中带有<code>Create</code>或<code>Copy</code>的函数返回的对象，你会持有它，因此你要负责释放它。</li>
<li>如果函数名字中是带的<code>get</code>，你不会持有它返回的对象，不需要你释放它。</li>
</ul>
</li>
</ul>
<p>ARC中有两种方法来retain一个CF对象：用类型转换符<code>(__bridge_retained)</code> 或者 C函数<code>CFBridgingRetain</code>。我更喜欢后者，因为代码简洁清晰。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">CFArrayRef</span> arr = <span class="built_in">CFBridgingRetain</span>( @[<span class="string">@"abc"</span>, <span class="string">@"def"</span>, @<span class="number">3.14</span>] );</div><div class="line"><span class="comment">// or CFArrayRef arr = (__bridge_retained CFArrayRef)@[...];</span></div><div class="line"><span class="comment">// do stuffs..</span></div><div class="line"><span class="built_in">CFRelease</span>(arr);</div></pre></td></tr></table></figure>
<p>当用Core Foundation中名字中带有Create或者Copy的方法获得一个对象的时候，用<code>(__bridge_transfor)</code>或者<code>CFBridgingRealease</code>来将对象的所有权转移给ARC，这样就能让ARC负责对象的释放。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)logFirstNameOfPerson:(ABRecordRef)person &#123;</div><div class="line">	<span class="built_in">NSString</span> *name = (<span class="built_in">NSString</span> *)<span class="built_in">CFBridgingRelease</span>(ABRecordCopyValue(person, kABPersonFirstNameProperty));</div><div class="line">	<span class="built_in">NSLog</span>(<span class="string">@"Person's first name: %@"</span>, name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Toll-free绑定的注意事项"><a href="#Toll-free绑定的注意事项" class="headerlink" title="Toll-free绑定的注意事项"></a>Toll-free绑定的注意事项</h3><p>要当心下面这种代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">CGColorRef</span>)foo &#123;</div><div class="line">	<span class="built_in">UIColor</span>* color = [<span class="built_in">UIColor</span> redColor];</div><div class="line">	<span class="keyword">return</span> [color <span class="built_in">CGColor</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它任何时候都可能崩溃。由于我们没有保持对UIColor的引用，它可能创建后就立即被释放掉了！CGColor也跟着释放掉了，就会引起崩溃。</p>
<p>有3种方法来修正这个问题：</p>
<ul>
<li><p>使用<code>__autorelease</code>修饰符。这样UIColor就被延迟到当前runloop结束时才被释放，就不会崩溃了。应该是<a href="https://twitter.com/amattn" target="_blank" rel="external">@amattn</a>第一个发现了这种解决方法。</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">CGColorRef</span>)getFooColor &#123;</div><div class="line">	<span class="built_in">UIColor</span> * __autoreleasing color = [<span class="built_in">UIColor</span> redColor];</div><div class="line">	<span class="keyword">return</span> [color <span class="built_in">CGColor</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用Core Foundation的命名规则来改变返回值的所有权。</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">CGColorRef</span>)fooColorCopy &#123;</div><div class="line">	<span class="built_in">UIColor</span>* color = [<span class="built_in">UIColor</span> redColor];</div><div class="line">	<span class="built_in">CGColorRef</span> c = <span class="built_in">CFRetain</span>([color <span class="built_in">CGColor</span>]);</div><div class="line">	<span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">CGColorRef</span> c = [obj fooColorCopy];</div><div class="line"><span class="comment">// do stuffs</span></div><div class="line"><span class="built_in">CFRelease</span>(c);</div></pre></td></tr></table></figure>
</li>
<li><p>用self来持有CF对象。但如果self被dealloc，仍然会引起崩溃。</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">CGColorRef</span>)getFooColor &#123;</div><div class="line">	<span class="built_in">CGColorRef</span> c = <span class="keyword">self</span>.myColor.CGColor;</div><div class="line">	<span class="keyword">return</span> c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ARC中使用Block的注意事项"><a href="#ARC中使用Block的注意事项" class="headerlink" title="ARC中使用Block的注意事项"></a>ARC中使用Block的注意事项</h3><p>如果用block做实例变量，block会隐式的retain self，这样就会造成引用循环。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">	<span class="keyword">id</span> child;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) (<span class="keyword">void</span>(^)(<span class="keyword">void</span>)) job;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)foo &#123;</div><div class="line">	<span class="keyword">self</span>.job = ^&#123;</div><div class="line">		[child work];</div><div class="line">		<span class="comment">// will expand to [self-&gt;child work]</span></div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解决这个问题的方法是使用self的弱引用，然后在block内部临时将弱引用转换为强引用。在block内部使用强引用的原因，是因为我们想确保在使用self的时候它不会被其它人释放掉。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)foo &#123;</div><div class="line">	MyClass * __<span class="keyword">weak</span> w_self = <span class="keyword">self</span>;</div><div class="line">	<span class="keyword">self</span>.block = ^&#123;</div><div class="line">		MyClass *s_self = w_self; <span class="comment">// self retained, but only in this scope!</span></div><div class="line">		<span class="keyword">if</span> (s_self) &#123;</div><div class="line">			[s_self-&gt;child work];</div><div class="line">			<span class="comment">// do other stuffs</span></div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="NSError的注意事项"><a href="#NSError的注意事项" class="headerlink" title="NSError的注意事项"></a>NSError的注意事项</h3><p>实现带NSError参数方法的时候，要注意正确地使用类型修饰符！</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)doStuffWithError:(<span class="built_in">NSError</span> * __autoreleasing *)error; <span class="comment">// correct</span></div><div class="line">- (<span class="keyword">void</span>)doStuffWithError:(__autoreleasing <span class="built_in">NSError</span> **)error; <span class="comment">// wrong!</span></div></pre></td></tr></table></figure>
<p>创建一个NSError对象的时候，通常最好把它定义成一个自动释放对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSError</span> * __autoreleasing error = <span class="literal">nil</span>; <span class="comment">// 正确</span></div><div class="line">__autoreleasing <span class="built_in">NSError</span> *error = <span class="literal">nil</span>; <span class="comment">// 错误</span></div><div class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>; <span class="comment">// clang编译器下正确。(clang编译器会帮我们做优化)</span></div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ARC很方便，但是刚开始使用时可能不容易搞清楚用法。当面对复杂的对象所有权关系时，可以写一些测试代码，看看对象的retain count是怎样的。下面是我用来测试retain count的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)testCGColorRetainCount1 &#123;</div><div class="line">	<span class="built_in">CGColorRef</span> s_ref;</div><div class="line">	<span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">		<span class="built_in">UIColor</span> * __autoreleasing shadowColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.12</span> green:<span class="number">0.12</span> blue:<span class="number">0.12</span> alpha:<span class="number">1.0</span>];</div><div class="line">		s_ref = shadowColor.CGColor;</div><div class="line">		<span class="built_in">CFRetain</span>(s_ref);</div><div class="line">	&#125;</div><div class="line">	STAssertEquals(<span class="built_in">CFGetRetainCount</span>(s_ref), <span class="number">1</span>L, <span class="string">@"retain count owned by us"</span>);</div><div class="line"></div><div class="line">	<span class="built_in">CGColorRef</span>(^strangeBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">		<span class="keyword">return</span> <span class="built_in">CGColorCreateCopy</span>(s_ref);</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="built_in">CGColorRef</span> myCopy = strangeBlock();</div><div class="line">	STAssertEquals(<span class="built_in">CFGetRetainCount</span>(s_ref), <span class="number">2</span>L, <span class="string">@"retain count owned by block and us"</span>);</div><div class="line">	<span class="built_in">CFRelease</span>(s_ref);</div><div class="line">	STAssertEquals(<span class="built_in">CFGetRetainCount</span>(s_ref), <span class="number">1</span>L, <span class="string">@"retain count owned by block"</span>);</div><div class="line">	STAssertEquals(<span class="built_in">CFGetRetainCount</span>(myCopy), <span class="number">1</span>L, <span class="string">@"retain count owned by us"</span>);</div><div class="line">	<span class="built_in">CFRelease</span>(myCopy);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>希望这篇文章对你有帮助！欢迎讨论和分享！</p>
<p>原文：<a href="http://www.idryman.org/blog/2012/11/22/arc-best-practices-and-pitfalls/" target="_blank" rel="external">Effective Obj-C ARC and Pitfalls in It</a></p>
<p>译注：如果还想了解ARC更详细的知识，可以看看官方文档《<a href="http://developer.apple.com/library/ios/#releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Transitioning to ARC Release Notes</a>》或这篇《<a href="http://www.cocoachina.com/bbs/read.php?tid=92507" target="_blank" rel="external">iOS5 ARC完全指南</a>》。</p>
<p style="text-align:center"><img src="/images/posts/thx_money.png" width="30%" height="30%"></p></div></article></div></main><footer><div class="paginator"><a href="/2013/04/19/2013-04-19-she-zhi-yin-ying-lu-jing-de-zhong-yao-xing/" class="prev">上一篇</a><a href="/2012/07/07/2012-07-07-gai-bian-uinavigationcontroller-de-push-he-pop-dong-hua/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'Tinghui';
var disqus_identifier = '2012/12/05/2012-12-05-effective-obj-c-arc-and-pitfalls-in-it/';
var disqus_title = '高效的ARC代码和陷阱';
var disqus_url = 'http://morefun.mobi/2012/12/05/2012-12-05-effective-obj-c-arc-and-pitfalls-in-it/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//Tinghui.disqus.com/count.js" async></script><div class="copyright"><p>© 2012 - 2017 <a href="http://morefun.mobi">Tinghui</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>