<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Core Animation 3D介绍 第1部分 · Coding With MoreFun</title><meta name="description" content="Core Animation 3D介绍 第1部分 - Tinghui"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.morefun.mobi/atom.xml" title="Coding With MoreFun"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Tinghui" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="mailto:tinghui.zhang3@gmail.com" target="_self" class="nav-list-link">EMAIL</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Core Animation 3D介绍 第1部分</h1><div class="post-info">2013年6月11日</div><div class="post-content"><p>本教程将向你介绍Core Animation中用于绘制3D图形的一些技术。</p>
<p>好消息是：我们不必直接使用OpenGL，仅用Core Animation就可以很容易实现一些3D效果。但是，“用Core Animation来制作一个复杂的3D游戏”也并不是一个好主意。</p>
<p>这个教程将分为两部分。第一部分，我们先简单介绍一点3D原理知识，并运用这些概念来创建一些简单的3D场景。在第二部分中，我们将使用Core Animation来制作一个类似于旋转木马的3D场景特效。</p>
<p>最终app的预览效果如下：(译注: 原文中这里的视频被墙，因此这里只简单的提供一个图片预览，你可以直接下载例子代码运行即可以看到最终app的效果)</p>
<p><img src="/images/posts/2013_06_11_core_animation_3d_app_preview.png" alt=""></p>
<p>准备好了吗？开始编码吧！<br><a id="more"></a></p>
<p>首先，下载文章后面的代码。如果你要自己创建项目，要记得添加QuartzCore框架。</p>
<h3 id="少量3D和矩阵相关的数学知识"><a href="#少量3D和矩阵相关的数学知识" class="headerlink" title="少量3D和矩阵相关的数学知识"></a>少量3D和矩阵相关的数学知识</h3><p>要在一个3D空间中绘图，除了标准2D坐标(X和Y)概念外，我们还需要引入一个深度(depth)的概念，也就是要加入第三个坐标轴–Z轴。</p>
<p>这样，在空间中，我们只需要简单的改变物体的X、Y和Z坐标，就可以在垂直方向、水平方向或深度方向上移动物体。</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/handed.png" alt=""></p>
<p>在2D或3D空间中，对一个物体执行平移、缩放或旋转这些操作时需要使用矩阵运算。</p>
<p>你可以将矩阵想象成一个多维数组。比如，在3D空间中我们使用一个像下面这种格式的4X4矩阵：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">[X][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]</div><div class="line">[<span class="number">0</span>][Y][<span class="number">0</span>][<span class="number">0</span>]</div><div class="line">[<span class="number">0</span>][<span class="number">0</span>][Z][<span class="number">0</span>]</div><div class="line">[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]</div></pre></td></tr></table></figure>
<p>把这个矩阵和物体的每一个坐标点(又称顶点)相乘，我们可以得到物体的一个变换(transformation)效果。</p>
<p>严格点讲，前面这个矩阵是用来执行缩放操作的。其中的X、Y、Z值代表每个轴上的缩放值。</p>
<p>如果你要进行其他的变换操作，比如旋转或者平移，你需要将矩阵换成其他矩阵格式(scheme)。</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/Screen-Shot-2013-03-20-at-11.02.03-AM.png" alt=""></p>
<p>不要紧张！你不需要知道其他更多原理知识，而且也不必直接进行这些操作。Core Animation会为你完成这些操作，虽然你不知道它是如何做到的，但是它确实会为你完成这些操作，所以不必害怕。</p>
<p>当然，就我个人来说，如果我知道它背后是如何工作的(至少知道一些它的基本原理)，我会对我的代码更有自信。因此，如果你想了解更多矩阵相关的知识，建议你读一读这篇<a href="http://www.matrix44.net/cms/notes/opengl-3d-graphics/basic-3d-math-matrices" target="_blank" rel="external">文章</a>。</p>
<h3 id="3D变换-Transformations"><a href="#3D变换-Transformations" class="headerlink" title="3D变换(Transformations)"></a>3D变换(Transformations)</h3><p>现在基本上，你已经知道矩阵的作用了，也知道了3D空间是如何构成的。来，我们用Core Animation做一些3D的东西吧。</p>
<p>打开TB_3DIntro-&gt;viewController.m文件。</p>
<p>我在里面列出了6个分别以A、B、C、D、E、F开头的函数。每一个函数对应了一种不同的3D场景效果。</p>
<p>我们先来看看由<code>A_singlePlan</code>函数创造的场景吧。</p>
<p>用这个函数，我们画了一个平面，平面绕Y轴旋转了45度。</p>
<p>首先，我们创建了一个CALayer，用它来作容器层(当然，并不是一定要这样做，只是我更喜欢不直接在self.view的layer上进行工作)。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)A_singlePlane&#123;</div><div class="line">    <span class="comment">//Create the container</span></div><div class="line">    <span class="built_in">CALayer</span> *container = [<span class="built_in">CALayer</span> layer];</div><div class="line">    container.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">640</span>, <span class="number">300</span>);</div><div class="line">    [<span class="keyword">self</span>.view.layer addSublayer:container];</div></pre></td></tr></table></figure>
<p>然后我们创建了另一个CALayer，用它代表一个平面。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//Create a Plane</span></div><div class="line">   <span class="built_in">CALayer</span> *purplePlane = [<span class="keyword">self</span> addPlaneToLayer:container</div><div class="line">                                           size:<span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="number">100</span>)</div><div class="line">                                       position:<span class="built_in">CGPointMake</span>(<span class="number">250</span>, <span class="number">150</span>)</div><div class="line">                                          color:[<span class="built_in">UIColor</span> purpleColor]];</div></pre></td></tr></table></figure>
<p>我写了一个简单的辅助函数，用它将平面直接添加到容器层上，然后返回这个新建的平面层。代码非常简单：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">CALayer</span>*)addPlaneToLayer:(<span class="built_in">CALayer</span>*)container size:(<span class="built_in">CGSize</span>)size position:(<span class="built_in">CGPoint</span>)point color:(<span class="built_in">UIColor</span>*)color&#123;</div><div class="line">    <span class="comment">//Initialize the layer</span></div><div class="line">    <span class="built_in">CALayer</span> *plane = [<span class="built_in">CALayer</span> layer];</div><div class="line">    <span class="comment">//Define position,size and colors</span></div><div class="line">    plane.backgroundColor = [color <span class="built_in">CGColor</span>];</div><div class="line">    plane.opacity = <span class="number">0.6</span>;</div><div class="line">    plane.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height);</div><div class="line">    plane.position = point;</div><div class="line">    plane.anchorPoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>, <span class="number">0.5</span>);</div><div class="line">    plane.borderColor = [[<span class="built_in">UIColor</span> colorWithWhite:<span class="number">1.0</span> alpha:<span class="number">0.5</span>]<span class="built_in">CGColor</span>];</div><div class="line">    plane.borderWidth = <span class="number">3</span>;</div><div class="line">    plane.cornerRadius = <span class="number">10</span>;</div><div class="line">    <span class="comment">//Add the layer to the container layer</span></div><div class="line">    [container addSublayer:plane];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> plane;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，我们用CATransform3D来添加变换。</p>
<p>啊？？？你一定又想问CATransform3D是什么东西？按住Cmd键点击这个类型名称，你可以发现它是一个结构体，使用了一种很“火星”的语法来表示一个矩阵。<img src="http://www.thinkandbuild.it/wp-includes/images/smilies/icon_razz.gif" alt=""></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> <span class="built_in">CATransform3D</span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">CGFloat</span> m11, m12, m13, m14;</div><div class="line">  <span class="built_in">CGFloat</span> m21, m22, m23, m24;</div><div class="line">  <span class="built_in">CGFloat</span> m31, m32, m33, m34;</div><div class="line">  <span class="built_in">CGFloat</span> m41, m42, m43, m44;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CATransform3D</span> <span class="built_in">CATransform3D</span>;</div></pre></td></tr></table></figure>
<p>旋转变换部分的代码也相当简单：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">    <span class="comment">//Apply transform to the PLANE</span></div><div class="line">    <span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, <span class="number">45.00</span>f * M_PI / <span class="number">180.0</span>f, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    purplePlane.transform = t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先用单位矩阵<code>CATransform3DIdentity</code>来初始化一个变换(transformation)，然后用<code>CATransform3DRotate</code>函数给变换乘上一个旋转矩阵。</p>
<p>CATransform3DRotate这个函数的参数分别表示矩阵，旋转的角度(以弧度为单位)和3个坐标轴上的变换系数。这个例子中，X和Z轴都没受到影响，只对Y轴有影响，物体会在Y轴上旋转45度。</p>
<p>下图是运行结果。</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/pa1.png" alt=""></p>
<p>呃……你可以看到，它还不是3D的！我们只是在X轴方向上将一个正方形压扁了。</p>
<p>这是由于我们还没有设置视点的值(perspective value)。通常，在绘制3D场景的时候会将场景进行正射投影(Orthographic projection)处理，由此会产生一个扁平的场景。换句话说，在正射投影后你无法看到Z轴上的深度感。</p>
<p>要给我们的场景加上空间深度感，我们必须修改变换矩阵的<code>m34</code>参数。这个参数决定了视点的值。</p>
<p>现在，来看看<code>B_singlePlanePerspective</code>这个函数，这函数展示了视点的作用。</p>
<p>这个函数和前一个函数只有变换部分的代码有所不同：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">    <span class="comment">//Apply transform to the PLANE</span></div><div class="line">    <span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    <span class="comment">//Add perspective!!!</span></div><div class="line">    t.m34 = <span class="number">1.0</span>/ <span class="number">-500</span>;</div><div class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(<span class="number">45.0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    purplePlane.transform = t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以看到，我们直接给矩阵的m34属性赋了一个值。在这里，我不会深入的从数学上解释这个值是如何起作用的。但是我可以告诉你的是，这个值越接近0，视点就越深。</p>
<p>下面是两种不同视点值的效果：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/pa_2.png" alt=""></p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/pa_21.png" alt=""></p>
<h3 id="3D变换的顺序问题-Transformations-chain"><a href="#3D变换的顺序问题-Transformations-chain" class="headerlink" title="3D变换的顺序问题(Transformations chain)"></a>3D变换的顺序问题(Transformations chain)</h3><p>我们可以将多个矩阵相乘从而将多种变换应用到一个物体上。比如，如果我们想将平移和旋转变换应用到一个物体上，我们可以直接将两个变换矩阵相乘：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">TransformMatrix = TranslateMtx * RotateMtx</div></pre></td></tr></table></figure>
<p>数学上，一般情况下乘法都可以使用交换律：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">TranslateMtx * RotateMxt = RotateMtx * TranslateMtx</div></pre></td></tr></table></figure>
<p>但是<strong>矩阵乘法不适用于交换律</strong>。AxB的结果可能和BxA的结果不一样。要记住这一点！</p>
<p>接下来<code>C_transformationsChain</code>这个例子中，我们会将2个变换效果按不同的先后顺序应用到2个不同的物体上。</p>
<p>以下是主要代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//Apply transformation to the PLANES</span></div><div class="line"><span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line"> </div><div class="line"><span class="comment">//Purple plane: Perform a rotation and then a translation</span></div><div class="line">t = <span class="built_in">CATransform3DRotate</span>(t, <span class="number">45.0</span>f * M_PI / <span class="number">180.0</span>f, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">purplePlane.transform = t;</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">//reset the transform matrix</span></div><div class="line">t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line"> </div><div class="line"><span class="comment">//Red plane: Perform translation first and then the rotation</span></div><div class="line">t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">t = <span class="built_in">CATransform3DRotate</span>(t, <span class="number">45.0</span>f * M_PI / <span class="number">180.0</span>f, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">redPlane.transform = t;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/Screen-Shot-2013-03-20-at-11.47.15-AM.png" alt=""></p>
<p>看到了吗，不同的变换顺序完全导致了不同的效果。</p>
<p>我们重点下看一下紫色的那块。旋转变换改变了它的坐标轴方向，然后我们又将它沿X轴进行了平移，此时它的X轴方向已经和红色平面的X轴方向不一致了。</p>
<p>变换步骤示意图如下：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/p_r.png" alt=""></p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/p_r2.png" alt=""></p>
<h3 id="图层层次-layer-hierarchies"><a href="#图层层次-layer-hierarchies" class="headerlink" title="图层层次(layer hierarchies)"></a>图层层次(layer hierarchies)</h3><p>到目前为止，我们都是将变换直接应用在这些平面上。在3D场景中，经常需要创建一些相互之间有层次结构的物体。这个时候，只需要将变换应用到根层次上，就可以使整个层次结构中的物体整体具有这个变换效果。这种做法非常有用。</p>
<p>接下来，我们来看看<code>D_multiplePlanes</code>这个例子。</p>
<p>我们在容器层上添加了4个平面。</p>
<p>当没有任何变换效果时看起来是这样的：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/p5.png" alt=""></p>
<p>如果我们给每一个平面都加上一个Y轴上的旋转变换，我们会得到4个独立的旋转效果：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/p5_2.png" alt=""></p>
<p>但是，如果我们只是在容器层上应用旋转变换，我们会得到一个完全不同的场景效果：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/p5_1.png" alt=""></p>
<p>这种效果，是相机(camera)位置发生改变带来的结果。我们没有移动每个平面，只是改变了视点的位置。</p>
<p>此函数主要的变换部分代码如下，包含了分别应用于各个平面和应用于容器层的两种变换效果的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//Transformation </span></div><div class="line"><span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line"> </div><div class="line"><span class="built_in">BOOL</span> applyToContainer = <span class="literal">NO</span>;</div><div class="line"> </div><div class="line"><span class="comment">//Apply the transformation to each PLANE</span></div><div class="line"><span class="keyword">if</span>(!applyToContainer)&#123;</div><div class="line">    t.m34 = <span class="number">1.0</span> / <span class="number">-500.0</span>;</div><div class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(<span class="number">60.0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    purplePlane.transform = t;</div><div class="line">     </div><div class="line">    t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    t.m34 = <span class="number">1.0</span> / <span class="number">-500.0</span>;</div><div class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(<span class="number">60.0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    redPlane.transform = t;</div><div class="line">     </div><div class="line">    t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    t.m34 = <span class="number">1.0</span> / <span class="number">-500.0</span>;</div><div class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(<span class="number">60.0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    orangePlane.transform = t;</div><div class="line">     </div><div class="line">    t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    t.m34 = <span class="number">1.0</span> / <span class="number">-500.0</span>;</div><div class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(<span class="number">60.0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    yellowPlane.transform = t;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//Apply the transformation to the CONTAINER</span></div><div class="line"><span class="keyword">else</span>&#123;    </div><div class="line">    <span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    t.m34 = <span class="number">1.0</span>/<span class="number">-500</span>;</div><div class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(<span class="number">60.0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    container.transform = t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CATransformLayer"><a href="#CATransformLayer" class="headerlink" title="CATransformLayer"></a>CATransformLayer</h3><p>到目前为止我们所见到的代码都能正常工作，但说实话，作为3D层次结构的根，CALayer不是正确的选择。</p>
<p>函数<code>E_multiplePlanesZAxis</code>展示了为什么。</p>
<p>这个例子中，我们创建4个XY坐标相同只有Z坐标不同的平面。紫色平面最近，黄色平面最远。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//Apply transforms to the PLANES</span></div><div class="line">t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-10</span>);</div><div class="line">purplePlane.transform = t;</div><div class="line"> </div><div class="line">t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-50</span>);</div><div class="line">redPlane.transform = t;</div><div class="line"> </div><div class="line">t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-90</span>);</div><div class="line">orangePlane.transform = t;</div><div class="line"> </div><div class="line">t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-130</span>);</div><div class="line">yellowPlane.transform = t;</div></pre></td></tr></table></figure>
<p>在旋转这些平面前，我们先让容器层执行了一个旋转变换。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//Apply transform to the CONTAINER</span></div><div class="line"><span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">t.m34 = <span class="number">1.0</span>/<span class="number">-500</span>;</div><div class="line">t = <span class="built_in">CATransform3DRotate</span>(t, <span class="number">80.0</span>f * M_PI / <span class="number">180.0</span>f, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">container.transform = t;</div></pre></td></tr></table></figure>
<p>你也许希望看到下面这种结果：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/p6_1.png" alt=""></p>
<p>但是，实际上会得到这种结果：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/p6.png" alt=""></p>
<p>这是因为CALayer不能处理3D层次结构的深度，它只能将场景处理成相同的Z层次。</p>
<p>为了修正这个问题，我们需要用一个<code>CATransformLayers</code>来做根层对象。</p>
<p>函数<code>F_multiplePlanesZAxis</code>修正了这个问题：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//Create the container as a CATransformLayer</span></div><div class="line"><span class="built_in">CATransformLayer</span> *container = [<span class="built_in">CATransformLayer</span> layer];</div><div class="line">container.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">640</span>, <span class="number">300</span>);</div><div class="line">[<span class="keyword">self</span>.view.layer addSublayer:container];</div></pre></td></tr></table></figure>
<p>CATransformLayer是一个特殊的layer。与CALayer的不同之处在于，CATransformLayer本身不会被渲染到屏幕上，只有它的子图层才会被渲染到屏幕上。所以它的一些属性，比如backgroundColor、contents、border等等都没有什么用。要记住这点。</p>
<p>到这里，这个教程的第一部分就完了。建议你实际运行一下这些函数，也可以试试我没有讲到的<code>CATransform3DScale</code>，试试用它做一个缩放变换看。</p>
<p>如果你有任何问题，可以在twitter上找到我(<a href="http://www.twitter.com/bitwaker" target="_blank" rel="external">@bitwaker</a>)。</p>
<p><a href="https://github.com/ariok/TB_3DCoreAnimation" target="_blank" rel="external">本教程代码下载</a></p>
<p>译自：<a href="http://www.thinkandbuild.it/introduction-to-3d-drawing-in-core-animation-part-1/" target="_blank" rel="external">Think &amp; Build</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2013/06/24/2013-06-24-core-animation-3djie-shao-di-2bu-fen/" class="prev">上一篇</a><a href="/2013/05/20/2013-05-20-ios-mvcshe-ji-mo-shi-zui-jia-shi-jian-yao-dian/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'rockonmycode';
var disqus_identifier = '2013/06/11/2013-06-11-core-animation-3djie-shao-di-1bu-fen/';
var disqus_title = 'Core Animation 3D介绍 第1部分';
var disqus_url = 'http://blog.morefun.mobi/2013/06/11/2013-06-11-core-animation-3djie-shao-di-1bu-fen/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//rockonmycode.disqus.com/count.js" async></script><div class="copyright"><p>© 2012 - 2017 <a href="http://blog.morefun.mobi">Tinghui</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>