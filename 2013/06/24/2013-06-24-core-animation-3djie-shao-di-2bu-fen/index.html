<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Core Animation 3D介绍 第2部分 · Coding With MoreFun</title><meta name="description" content="Core Animation 3D介绍 第2部分 - Tinghui"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.morefun.mobi/atom.xml" title="Coding With MoreFun"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Tinghui" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="mailto:tinghui.zhang3@gmail.com" target="_self" class="nav-list-link">EMAIL</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Core Animation 3D介绍 第2部分</h1><div class="post-info">2013年6月24日</div><div class="post-content"><p><a href="/2013/06/11/2013-06-11-core-animation-3djie-shao-di-1bu-fen/">上一篇</a>教程中，我们已经学习了Core Animation中3D绘图的基本方法。这篇教程，我们准备深入一些，讲讲如何创建一个可交互的3D场景。我们将会创建一个类似于旋转木马的3D场景界面，用户可以通过拖拽手势来旋转界面。</p>
<p>可能你已经在上一篇教程中见过最终APP的样子了，但是，让我们再来看一次吧：</p>
<p><img src="/images/posts/2013_06_11_core_animation_3d_app_preview.png" alt=""></p>
<p>你可以直接下载教程的<a href="https://github.com/ariok/TB_3DCoreAnimation" target="_blank" rel="external">源代码</a>。本篇教程的源代码和上一篇教程中的源代码在同一个代码仓库里面，但是我做了一些修改，为这篇教程建立了一个新的target。</p>
<a id="more"></a>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>这个程序，我们把工作分成了以下几个部分。</p>
<h4 id="3D"><a href="#3D" class="headerlink" title="3D"></a>3D</h4><p>因为我们需要3D效果，所以我们需要使用一个透视视图来进行绘制工作。为了构造旋转木马效果，我们将会建立一个3D层次体系。正如前一篇教程中介绍过的，用CATransformLayer来做层次体系中的根是不错的选择。</p>
<h4 id="平面"><a href="#平面" class="headerlink" title="平面"></a>平面</h4><p>旋转木马效果由一系列平面构成。我们将使用CAGradientLayer来表示这些平面。CAGradientLayer是CALayer的一个子类，用它可以制作渐变背景色，会比纯色背景要好看一些。</p>
<p>我们会对这些平面进行一些平移和旋转操作，使它们沿着旋转木马的圆周排列。</p>
<h4 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h4><p>获取用户的手势非常简单。我们只需要使用一个手势识别器(Gesture Recognizer)就可以了。然后，我们追踪用户的动作，将手势数据转换成角度值，用这个角度值来旋转界面。</p>
<p>好了，现在你应该已经知道这个项目有哪些东西要完成了吧？启动XCode吧！</p>
<h3 id="写代码吧"><a href="#写代码吧" class="headerlink" title="写代码吧"></a>写代码吧</h3><p>展开项目中的<strong>TB_3DPlanes</strong>文件夹，然后打开ViewController.m文件。</p>
<p>我们从viewDidLoad这个函数开始：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="comment">//Initialize the TransformLayer</span></div><div class="line">    transformLayer = [<span class="built_in">CATransformLayer</span> layer];</div><div class="line">    transformLayer.frame = <span class="keyword">self</span>.view.bounds;</div><div class="line">    [<span class="keyword">self</span>.view.layer addSublayer:transformLayer];</div><div class="line">    </div><div class="line">    angle = <span class="number">0</span>;</div><div class="line">    XPanOffset = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//Create 5 planes</span></div><div class="line">    [<span class="keyword">self</span> addPlane];</div><div class="line">    [<span class="keyword">self</span> addPlane];</div><div class="line">    [<span class="keyword">self</span> addPlane];</div><div class="line">    [<span class="keyword">self</span> addPlane];</div><div class="line">    [<span class="keyword">self</span> addPlane];</div><div class="line">    </div><div class="line">    <span class="comment">//Force the first animation to set the planes in place</span></div><div class="line">    [<span class="keyword">self</span> animate];</div><div class="line">    </div><div class="line">    <span class="comment">//Initialize the Pan gesture recognizer</span></div><div class="line">    <span class="built_in">UIPanGestureRecognizer</span> *panGesture = [[<span class="built_in">UIPanGestureRecognizer</span> alloc]initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pan:)];</div><div class="line">    [<span class="keyword">self</span>.view addGestureRecognizer:panGesture];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或许这个函数中有许多东西你还不完全明白是什么意思。但是，确实从这里开始就是核心部分的代码了。你可以暂时不用在这里纠结，继续阅读，后面会解释这些代码的意思的。<img src="http://www.thinkandbuild.it/wp-includes/images/smilies/icon_smile.gif" alt=""></p>
<p>很显然，我们先用<strong>CATransformLayer</strong>创建了一个根图层对象(<strong>transformLayer</strong>)，然后我们用<strong>addPlane</strong>函数向场景中添加了5个平面，并且我们将用<strong>pan:</strong>函数来处理拖拽手势。</p>
<h3 id="绘制平面"><a href="#绘制平面" class="headerlink" title="绘制平面"></a>绘制平面</h3><p>addPlane函数的代码也是相当直观的。它只是用<strong>CAGradientLayer</strong>和一些参数创建了一个图层罢了。然后将图层添加到了<strong>transformLayer</strong>上.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/** A simple function to create a CAGradientLayer **/</span></div><div class="line">- (<span class="keyword">void</span>)addPlane&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">CGSize</span> planeSize = <span class="built_in">CGSizeMake</span>(<span class="number">250</span>, <span class="number">150</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//Initialize the layer</span></div><div class="line">    <span class="built_in">CAGradientLayer</span> *layer = [<span class="built_in">CAGradientLayer</span> layer];</div><div class="line">    </div><div class="line">    <span class="comment">//Set the frame and the anchorPoint</span></div><div class="line">    layer.frame = <span class="built_in">CGRectMake</span>(<span class="number">480</span>/<span class="number">2</span> - planeSize.width/<span class="number">2</span>, <span class="number">320</span>/<span class="number">2</span> - planeSize.height/<span class="number">2</span> <span class="number">-20</span>, planeSize.width, planeSize.height);</div><div class="line">    layer.anchorPoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>, <span class="number">0.5</span>);</div><div class="line"></div><div class="line">    <span class="comment">//Set borders and cornerRadius</span></div><div class="line">    layer.borderColor = [[<span class="built_in">UIColor</span> colorWithWhite:<span class="number">1.0</span> alpha:<span class="number">0.3</span>]<span class="built_in">CGColor</span>];</div><div class="line">    layer.cornerRadius = <span class="number">10</span>;</div><div class="line">    layer.borderWidth = <span class="number">4</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//Set the gradient color for the plane background</span></div><div class="line">    layer.colors = [<span class="built_in">NSArray</span> arrayWithObjects:</div><div class="line">                    (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> purpleColor].CGColor,</div><div class="line">                    (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> redColor].CGColor,</div><div class="line">                    <span class="literal">nil</span>];</div><div class="line">    layer.locations = [<span class="built_in">NSArray</span> arrayWithObjects:</div><div class="line">                       [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">0.0</span>f],</div><div class="line">                       [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">1.0</span>f],</div><div class="line">                       <span class="literal">nil</span>];</div><div class="line">        </div><div class="line">    <span class="comment">//Set the shadow</span></div><div class="line">    layer.shadowColor = [[<span class="built_in">UIColor</span> blackColor]<span class="built_in">CGColor</span>];</div><div class="line">    layer.shadowOpacity = <span class="number">1</span>;</div><div class="line">    layer.shadowRadius = <span class="number">20</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//The double side has to be setted if we want to see the plane when its face is turned back</span></div><div class="line">    layer.doubleSided = <span class="literal">YES</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//Add the plane to the transformLayer</span></div><div class="line">    [transformLayer addSublayer:layer];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里唯一需要解释一下的是<strong>doubleSide</strong>属性。将它设置成YES，表示我们希望图层的背面也被绘制出来。当一个平面在Y轴上旋转接近180度的时候，我们仍然可以在场景中看到它，只是它旋转到了相反的方向。</p>
<p>为了更形象地说明这个问题，可以看看下图doubleSide为NO和YES时的对比。</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/04/double_side.png" alt=""></p>
<p>看了图，一下就明白了吧？设置成NO的时候，被旋转到背对着我们的那些平面都不会被绘制出来。</p>
<p>也许你已经注意到了，在viewDidLoad函数中我们添加了5个平面，但是这些平面并不是按位置排列在场景中的。在addPlane函数中，它们被添加到了同一个位置(参见frame属性)。</p>
<h3 id="更新平面位置"><a href="#更新平面位置" class="headerlink" title="更新平面位置"></a>更新平面位置</h3><p>在viewDidLoad函数里，平面被创建后，我们调用了<strong>animate</strong>方法。这个函数的主要作用是更新各个平面的位置。这里是我们第一次调用这个函数，这个时候并没有发生任何触摸事件，这里调用它只是为了让各个平面沿着旋转木马的圆周排列好。</p>
<p>我们来看看这个函数的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/** This function performs the transformation on each plane **/</span></div><div class="line">- (<span class="keyword">void</span>)animate&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//Define the degrees needed for each plane to create a circle</span></div><div class="line">    <span class="keyword">float</span> degForPlane = <span class="number">360</span> / [[transformLayer sublayers] count];</div><div class="line">    </div><div class="line">    <span class="comment">//The current angle offset (initially it is 0... it will change through the pan function)</span></div><div class="line">    <span class="keyword">float</span> degX = angle;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">CALayer</span> *layer <span class="keyword">in</span> [transformLayer sublayers]) &#123;</div><div class="line">        <span class="comment">//Create the Matrix identity</span></div><div class="line">        <span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">        <span class="comment">//Setup the perspective modifying the matrix elementat [3][4]</span></div><div class="line">        t.m34 = <span class="number">1.0</span>f / - <span class="number">1000.0</span>f;</div><div class="line">        </div><div class="line">        <span class="comment">//Perform rotate on the matrix identity</span></div><div class="line">        t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(degX), <span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f);</div><div class="line">        </div><div class="line">        <span class="comment">//Perform translate on the current transform matrix (identity + rotate)</span></div><div class="line">        t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">0.0</span>f, <span class="number">0.0</span>f,  <span class="number">250.0</span>f);</div><div class="line">        </div><div class="line">        <span class="comment">//Avoid animations</span></div><div class="line">        [<span class="built_in">CATransaction</span> setAnimationDuration:<span class="number">0.0</span>];</div><div class="line">        </div><div class="line">        <span class="comment">//apply the transoform on the current layer</span></div><div class="line">        layer.transform = t;</div><div class="line">        </div><div class="line">        <span class="comment">//Add the degree needed for the next plane</span></div><div class="line">        degX += degForPlane;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<strong>defForPlane</strong>变量是指沿着360度圆周上每个平面需要旋转的角度。看下图会容易理解一些：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/04/planes_circle_1.png" alt=""></p>
<p>圆周上的5个平面需要旋转一定的角度。这个角度从0开始，每个平面增加”360/平面总数”度。</p>
<p><strong>angle</strong>变量的值目前还是零，我们稍后会详细解释它的作用。</p>
<p>animate函数循环遍历transformLayer的所有子图层(5个平面)，为每一个平面加上一些变换效果：</p>
<p>第一个变换效果是改变视点，和我们在上一篇教程中的做法一样，直接给m34属性赋一个值，从而可以绘制出平面的3D空间深度。</p>
<p>另外2个变换效果需要一点点数值计算。我们前面已经谈到了，每个平面需要一个旋转角度。但是我们跳过了一个关键点，还没讲。</p>
<p>如果我们只是给每个平面加上一个旋转角度，我们只会得到下面这种效果：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/04/planes_center.png" alt=""></p>
<p>你可以看到，这种效果不行，我们还需要给每个平面加上平移变换，使让它们沿着圆周排列。</p>
<p>最后一步是将这些变换应用到各个平面上。只需要将变换赋值给当前平面的<strong>transform</strong>属性就可以了，赋值后，下一个平面的degX值会增加“degForPlane”度。</p>
<h3 id="拖拽手势"><a href="#拖拽手势" class="headerlink" title="拖拽手势"></a>拖拽手势</h3><p><strong>pan:</strong>函数是拖拽手势的处理函数。下面是该函数的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)pan:(<span class="built_in">UIPanGestureRecognizer</span>*)gesture&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//Get the current translation on the X</span></div><div class="line">    <span class="keyword">float</span> xOffset = [gesture translationInView:<span class="keyword">self</span>.view].x;</div><div class="line">    </div><div class="line">    <span class="comment">//When gesture begin, reset the offset</span></div><div class="line">    <span class="keyword">if</span>(gesture.state == <span class="built_in">UIGestureRecognizerStateBegan</span>)&#123;</div><div class="line">        XPanOffset = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//the distance covered since the last gesture event (I slow down a bit the final rotation multiplying by 0.5)</span></div><div class="line">    <span class="keyword">float</span> movedBy = xOffset * <span class="number">0.5</span> - XPanOffset;</div><div class="line">    </div><div class="line">    <span class="comment">//Calculate the offset from the previous gesture event</span></div><div class="line">    XPanOffset += movedBy;</div><div class="line">    </div><div class="line">    <span class="comment">//Add the offset to the current angle</span></div><div class="line">    angle += movedBy;</div><div class="line">    </div><div class="line">    <span class="comment">//Update the plane</span></div><div class="line">    [<span class="keyword">self</span> animate];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>拖拽手势是一个连续性的手势。从手势开始，直到所有手指离开屏幕之前，只要手指一移动，pan函数就会被调用。</p>
<p>为了将这些手势数据转换成对旋转木马动画有用的数据，我们需要获得每次移动前的X坐标值。</p>
<p>这里我们使用了<strong>XPanOffset</strong>这个变量来存储位置信息。当手势发生移动后，我们会计算出本次移动的距离(<strong>movedBy</strong>变量)。这个移动距离会被加到XPanOffset中，也会被加到当前的<strong>angle</strong>变量上。</p>
<p>然后调用animate函数就可以将所有平面旋转到新角度。</p>
<p>就这样，完成了！<img src="http://www.thinkandbuild.it/wp-includes/images/smilies/icon_smile.gif" alt=""></p>
<p>这个简单的例子展示了只需用Core Animation就可以做出来的一些3D效果。</p>
<p>祝你玩的愉快！有任何疑问或建议，请随时在<a href="http://twitter.com/bitwaker" target="_blank" rel="external">twitter</a>上联系我。</p>
<p><a href="https://github.com/ariok/TB_3DCoreAnimation" target="_blank" rel="external">教程源代码下载</a></p>
<p>译自：<a href="http://www.thinkandbuild.it/introduction-to-3d-drawing-in-core-animation-part-2/" target="_blank" rel="external">Think &amp; Build</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2014/01/08/2014-01-08-uiapplicationdelegate-launchoptions/" class="prev">上一篇</a><a href="/2013/06/11/2013-06-11-core-animation-3djie-shao-di-1bu-fen/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'rockonmycode';
var disqus_identifier = '2013/06/24/2013-06-24-core-animation-3djie-shao-di-2bu-fen/';
var disqus_title = 'Core Animation 3D介绍 第2部分';
var disqus_url = 'http://blog.morefun.mobi/2013/06/24/2013-06-24-core-animation-3djie-shao-di-2bu-fen/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//rockonmycode.disqus.com/count.js" async></script><div class="copyright"><p>© 2012 - 2017 <a href="http://blog.morefun.mobi">Tinghui</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>