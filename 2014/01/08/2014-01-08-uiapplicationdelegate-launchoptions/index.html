<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> UIApplication​Delegate的launch​Options · Coding With MoreFun</title><meta name="description" content="UIApplication​Delegate的launch​Options - Tinghui"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.morefun.mobi/atom.xml" title="Coding With MoreFun"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Tinghui" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="mailto:tinghui.zhang3@gmail.com" target="_self" class="nav-list-link">EMAIL</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">UIApplication​Delegate的launch​Options</h1><div class="post-info">2014年1月8日</div><div class="post-content"><p>AppDelegate就是iOS的垃圾场。</p>
<p>App的生命周期管理、URL处理、通知、CoreData、第三方SDK的初始化，还有那些看起来放到哪里都不合适的函数，统统都被塞到AppDelegate.m里面！</p>
<p>其中，<code>application:didFinishLaunchingWithOptions:</code>是最拥挤的一个。</p>
<p>对于许多开发者来说，launchOptions参数如同Java main函数的String[]参数一样，被忽视了。然而，摆在眼前的事实是，launchOptions包含了许多关键性知识，涉及了app在iOS上的众多启动方式。</p>
<p>这个周，我们就谈谈这个UIKit里面最重要的方法，揭秘一下这个知之甚少的launchOptions参数。</p>
<a id="more"></a>
<p>## </p>
<p>每个app都从UIApplicationDelegate的<code>application:didFinishLaunchingWithOptions:</code>方法开始启动(更精确点说，是<code>application:willFinishLaunchingWithOptions:</code>方法，如果你把它实现了的话)。应用程序通过调用这个方法来通知它的delegate：启动程序已经完成，差不多已经准备好运行了。</p>
<p>除了点击桌面上的应用图标可以启动程序外，还有其他几种场景可以使程序启动。例如，app如果注册了自定义的URL schemme，比如twitter://，就可以被open URL的方式调用开启程序。也可以通过推送通知或定位服务的方式调用开启程序。</p>
<p>launchOptions参数的所用就是用来判断一个app是如何被启动的。类似于userInfo字典，在<code>application:didFinishLaunchingWithOptions:</code>方法中，可以通过launchOptions参数来获取指定key的相关信息。</p>
<blockquote>
<p>其中的许多key同样使用于UIApplicationDidFinishLaunchingNotification通知。详细信息可以查阅相关文档。</p>
</blockquote>
<p>launchOptions包含了大量的key。根据app的启动方式，这些key大体可以被分为以下这几类：</p>
<h2 id="Open-URL"><a href="#Open-URL" class="headerlink" title="Open URL"></a><strong>Open URL</strong></h2><p>通过URL，程序可以调用启动其他程序：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"app://..."</span>]];</div></pre></td></tr></table></figure>
<p>例如，“http://” 的URL可以打开Safari，“mailto://” 的URL可以打开邮件程序，“tel://” 的URL可以拨打电话。</p>
<p>这些情形下，launchOptions里面会包含一个叫<code>UIApplicationLaunchOptionsURLKey</code>的Key。</p>
<blockquote>
<p>UIApplicationLaunchOptionsURLKey: 标示了该应用程序是为了打开一个URL启动。这个Key对应的值是一个NSURL对象，表示要打开的URL。</p>
</blockquote>
<p>app被URL启动的时候，还可以附带一些系统信息。当app是被UIDocumentInteractionController或AirDrop启动的时候，launchOptions里面还会附带下面这些key：</p>
<blockquote>
<p>UIApplicationLaunchOptionsSourceApplicationKey: 标示了要求启动你的程序的那个app。对应的值是一个NSString，表示那个app的bundle ID。</p>
<p>UIApplicationLaunchOptionsAnnotationKey: 标示了要求打开URL的那个app提供的自定义数据。对应的值是一个property-list类型的对象， 包含自定义的数据。 </p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *fileURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"Document"</span> withExtension:<span class="string">@"pdf"</span>];</div><div class="line"><span class="keyword">if</span> (fileURL) &#123;</div><div class="line">    <span class="built_in">UIDocumentInteractionController</span> *documentInteractionController = [<span class="built_in">UIDocumentInteractionController</span> interactionControllerWithURL:fileURL];</div><div class="line">    documentInteractionController.annotation = @&#123;<span class="string">@"foo"</span>: <span class="string">@"bar"</span>&#125;;</div><div class="line">    [documentInteractionController setDelegate:<span class="keyword">self</span>];</div><div class="line">    [documentInteractionController presentPreviewAnimated:<span class="literal">YES</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a><strong>通知</strong></h2><p>这里的通知不是指<a href="http://nshipster.com/nsnotification-and-nsnotificationcenter/" target="_blank" rel="external">NSNotification</a>，而是指推送通知和本地通知。</p>
<h4 id="推送通知"><a href="#推送通知" class="headerlink" title="推送通知"></a><strong>推送通知</strong></h4><p>自从iOS3引入推送通知以后，推送通知就成了移动平台最典型的功能之一。</p>
<p>要注册推送通知，在<code>application:didFinishLaunchingWithOptions:</code>里面调用<code>registerForRemoteNotificationTypes:</code>方法即可：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">[application registerForRemoteNotificationTypes:</div><div class="line">    <span class="built_in">UIRemoteNotificationTypeBadge</span> |</div><div class="line">    <span class="built_in">UIRemoteNotificationTypeSound</span> |</div><div class="line">    <span class="built_in">UIRemoteNotificationTypeAlert</span>];</div></pre></td></tr></table></figure>
<p>注册成功后，会收到<code>application:didRegisterForRemoteNotificationsWithDeviceToken:</code>这个回调。然后，就可以接收推送通知了。</p>
<p>接收到推送通知后，如果app当前处于前台运行状态，appDelgate的<code>application:didReceiveRemoteNotification:</code>方法会被调用。然而，当app是因为用户滑动通知中心的推送消息而启动时，<code>application:didFinishLaunchingWithOptions:</code>方法会被调用。这个时候，launchOption里面会包含名为<code>UIApplicationLaunchOptionsRemoteNotificationKey</code>的key：</p>
<blockquote>
<p>UIApplicationLaunchOptionsRemoteNotificationKey: 表明app有一个推送通知等待处理。这个key对应的值是一个包含了推送通知负载信息的NSDictionary，包括以下这些信息：</p>
<p><strong>alert</strong>：alert可以是一个字符串，表示提示信息；也可以是一个包含两个key(<strong>body</strong>和<strong>show-view</strong>)的字典。</p>
<p> <strong>badge</strong>：badge是一个数字，用于标示可从提供者下载的数据数量。这数字会被显示在app的图标上。如果推送通知中不包含badge这个字段，则app图标上标记的数字会被移除掉。</p>
<p> <strong>sound</strong>：指定app bundle里面用作提示音的声音文件的名字。如果为”default”，则会播放系统默认的提示音。</p>
</blockquote>
<p>这样看来，就有两个地方要写处理推送通知的代码。因此，一个通常的做法是在<code>application:didFinishLaunchingWithOptions:</code>里面手动调用<code>application:didReceiveRemoteNotification:</code>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application</div><div class="line">didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</div><div class="line">&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">if</span> (launchOptions[<span class="built_in">UIApplicationLaunchOptionsRemoteNotificationKey</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span> application:application didReceiveRemoteNotification:launchOptions[<span class="built_in">UIApplicationLaunchOptionsRemoteNotificationKey</span>]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="本地通知"><a href="#本地通知" class="headerlink" title="本地通知"></a><strong>本地通知</strong></h4><p><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/IPhoneOSClientImp.html#//apple_ref/doc/uid/TP40008194-CH103-SW1" target="_blank" rel="external">本地通知</a>从iOS4引入。令人惊奇的是，时至今日，仍然有很多人没有把它搞明白。</p>
<p>app可以定时触发一些<code>UILocalNotification</code>通知。通知触发时候，如果app正处于前台运行状态，appDelegate的<code>application:didReceiveLocalNotification:</code>方法会被调用。如果app处于非活动状态，通知就会被发布到通知中心。</p>
<p>与推送通知不同，UIApplication的delegate方法提供了一个统一的处理本地通知的地方。如果一个app是被本地通知启动的，会先调用<code>application:didReceiveLocalNotification:</code>方法，然后才会调用<code>application:didFinishLaunchingWithOptions:</code>(因此，就不需要在<code>application:didFinishLaunchingWithOptions:</code>里面手动调用<code>application:didReceiveLocalNotification</code>了)。</p>
<p>本地通知在launchOptions里面的key为<code>UIApplicationLaunchOptionsLocalNotificationKey</code>，对应的值为<code>UILocalNotification</code>对象(原文此处有误，本地通知和推送通知的结构不是相同的)。</p>
<blockquote>
<p>UIApplicationLaunchOptionsLocalNotificationKey: 如果这个key出现在launchOptions里面，则说明app有一个本地通知等待处理。对应的值是一个UILocalNotification对象，表示触发的本地通知。</p>
</blockquote>
<p>为了直观的展示，当app处于前台活动状态时应该如何显示一个本地通知的提示框。请看下面这个例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@import</span> <span class="built_in">AVFoundation</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SystemSoundID localNotificationSound;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application</div><div class="line">didReceiveLocalNotification:(<span class="built_in">UILocalNotification</span> *)notification</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (application.applicationState == <span class="built_in">UIApplicationStateActive</span>) &#123;</div><div class="line">        <span class="built_in">UIAlertView</span> *alertView =</div><div class="line">            [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:notification.alertAction</div><div class="line">                                       message:notification.alertBody</div><div class="line">                                      delegate:<span class="literal">nil</span></div><div class="line">                             cancelButtonTitle:<span class="built_in">NSLocalizedString</span>(<span class="string">@"OK"</span>, <span class="literal">nil</span>)</div><div class="line">                             otherButtonTitles:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.localNotificationSound) &#123;</div><div class="line">            <span class="built_in">NSURL</span> *soundURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"Sosumi"</span></div><div class="line">                                                      withExtension:<span class="string">@"wav"</span>];</div><div class="line">            AudioServicesCreateSystemSoundID((__bridge <span class="built_in">CFURLRef</span>)soundURL, &amp;_localNotificationSound);</div><div class="line">        &#125;</div><div class="line">        AudioServicesPlaySystemSound(<span class="keyword">self</span>.localNotificationSound);</div><div class="line"></div><div class="line">        [alertView show];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">UIApplication</span> *)application &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.localNotificationSound) &#123;</div><div class="line">        AudioServicesDisposeSystemSoundID(<span class="keyword">self</span>.localNotificationSound);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="定位事件"><a href="#定位事件" class="headerlink" title="定位事件"></a><strong>定位事件</strong></h2><p>想创造一个基于地理位置信息的本地社交图片签到软件？好吧，你已经晚了4年了。</p>
<p>但是不用怕！使用iOS的位置监测，你的app可以被定位事件启动：</p>
<blockquote>
<p>UIApplicationLaunchOptionsLocationKey: 表明app是为了响应定位事件才启动的。这个key对应的值是一个包含一个BOOL值的NSNumber对象。监测到这个key后，你应当创建CLLocationManager对象并再次启动定位服务。定位数据只会被投递给location manager的delegate，不会用这个key投递。</p>
</blockquote>
<p>下面这个例子，展示了当app收到一个显著的位置变化(significant location)事件而启动时的处理过程：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@import</span> CoreLocation;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> () &lt;<span class="title">CLLocationManagerDelegate</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CLLocationManager</span> *locationManager;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application</div><div class="line">didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</div><div class="line">&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (![<span class="built_in">CLLocationManager</span> locationServicesEnabled]) &#123;</div><div class="line">        [[[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="built_in">NSLocalizedString</span>(<span class="string">@"Location Services Disabled"</span>, <span class="literal">nil</span>)</div><div class="line">                                    message:<span class="built_in">NSLocalizedString</span>(<span class="string">@"You currently have all location services for this device disabled. If you proceed, you will be asked to confirm whether location services should be reenabled."</span>, <span class="literal">nil</span>)</div><div class="line">                                   delegate:<span class="literal">nil</span></div><div class="line">                          cancelButtonTitle:<span class="built_in">NSLocalizedString</span>(<span class="string">@"OK"</span>, <span class="literal">nil</span>)</div><div class="line">                          otherButtonTitles:<span class="literal">nil</span>] show];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">self</span>.locationManager = [[<span class="built_in">CLLocationManager</span> alloc] init];</div><div class="line">        <span class="keyword">self</span>.locationManager.delegate = <span class="keyword">self</span>;</div><div class="line">        [<span class="keyword">self</span>.locationManager startMonitoringSignificantLocationChanges];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (launchOptions[<span class="built_in">UIApplicationLaunchOptionsLocationKey</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span>.locationManager startUpdatingLocation];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Newsstand"><a href="#Newsstand" class="headerlink" title="Newsstand"></a><strong>Newsstand</strong></h2><p>所有Newsstand开发者，欢呼吧。</p>
<p>好吧好吧。</p>
<p>Newsstand可以在有新的下载资源时被启动。</p>
<p>你可以像这样注册：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">[application registerForRemoteNotificationTypes:</div><div class="line">    <span class="built_in">UIRemoteNotificationTypeNewsstandContentAvailability</span>];</div></pre></td></tr></table></figure>
<p>接下来就是launchOptions里面的关键部分：</p>
<blockquote>
<p>UIApplicationLaunchOptionsNewsstandDownloadsKey: 表明有新的Newsstand资源可供你的app下载。这个key对应的值是一组字符串标示符，它们标示了可供下载的资源对应的NKAssetDownload对象。虽然，这些标示符可以用作重复核对的用途，但是，你应当通过NKLibrary对象(表示Newsstand app的资源库)的downloadingAssets属性来明确的获取NKAssetDownload对象数组(它们表示了正在下载或者有错误的资源)。</p>
</blockquote>
<p>除此之外，就没有什么需要多说的了。</p>
<h2 id="Bluetooth"><a href="#Bluetooth" class="headerlink" title="Bluetooth"></a><strong>Bluetooth</strong></h2><p>iOS7引入了一个新功能，允许app被蓝牙外围设备重新启动。</p>
<p>如果app用特定的标示符实例化了一个<a href="https://developer.apple.com/library/ios/documentation/CoreBluetooth/Reference/CBCentralManager_Class/translated_content/CBCentralManager.html" target="_blank" rel="external">CBCentralManager</a>或一个<a href="https://developer.apple.com/library/ios/documentation/CoreBluetooth/Reference/CBPeripheralManager_Class/Reference/CBPeripheralManager.html#//apple_ref/doc/uid/TP40013015" target="_blank" rel="external">CBPeripheralManager</a>对象，并且连接了其他蓝牙外围设备，app就可以被来自蓝牙系统的中央操作(certain actions)重新启动。取决于接到通知的是中央设备管理器还是外围设备管理器，launchOptions里面会包含下面这两个key中的其中一个：</p>
<blockquote>
<p>UIApplicationLaunchOptionsBluetoothCentralsKey: 表明app先前有一个或多个CBCentralManager对象，现在app被蓝牙系统重新启动以继续处理这些对象的相关操作。这个key对应的值是一个包含了一个或多个NSString对象的数组。 每个字符串代表了一个中央设备管理器对象的复位标示符。</p>
<p>UIApplicationLaunchOptionsBluetoothPeripheralsKey: 表明app先前有一个或多个CBPeripheralManager对象，现在app被蓝牙系统重新启动以继续处理这些对象的相关操作。这个key对应的值是一个包含了一个或多个NSString对象的数组。每个字符串代表了一个外围设备管理器对象的复位标示符。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@import</span> CoreBluetooth;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> () &lt;<span class="title">CBCentralManagerDelegate</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) CBCentralManager *centralManager;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">self</span>.centralManager = [[CBCentralManager alloc] initWithDelegate:<span class="keyword">self</span> queue:<span class="literal">nil</span> options:@&#123;CBCentralManagerOptionRestoreIdentifierKey:(launchOptions[<span class="built_in">UIApplicationLaunchOptionsBluetoothCentralsKey</span>] ?: [[<span class="built_in">NSUUID</span> UUID] UUIDString])&#125;];</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.centralManager.state == CBCentralManagerStatePoweredOn) &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">UID</span> = <span class="string">@"7C13BAA0-A5D4-4624-9397-15BF67161B1C"</span>; <span class="comment">// generated with `$ uuidgen`</span></div><div class="line">    <span class="built_in">NSArray</span> *services = @[[CBUUID UUIDWithString:<span class="built_in">UID</span>]];</div><div class="line">    <span class="built_in">NSDictionary</span> *scanOptions = @&#123;CBCentralManagerScanOptionAllowDuplicatesKey:@YES&#125;;</div><div class="line">    [<span class="keyword">self</span>.centralManager scanForPeripheralsWithServices:services options:scanOptions];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要记住这么多app启动的方法和手段可能会让人筋疲力尽。幸运的是，任何一个app可能只需要处理其中的一两种情况。</p>
<p>知道什么是可能的，通常是能让一个app从概念演变成实现的必要条件。因此记住所有这些选项吧，以备你脑海中浮现出来的下一个伟大想法。</p>
<p>译自: <a href="http://nshipster.com/launch-options/" target="_blank" rel="external">NSHipster: UIApplication​Delegate launch​Options</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2014/02/11/2014-02-11-ni-xu-yao-zhi-dao-de-suo-you-guan-yu-ioshe-os-xyi-qi-yong-de-apide-shi-er/" class="prev">上一篇</a><a href="/2013/06/24/2013-06-24-core-animation-3djie-shao-di-2bu-fen/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'rockonmycode';
var disqus_identifier = '2014/01/08/2014-01-08-uiapplicationdelegate-launchoptions/';
var disqus_title = 'UIApplication​Delegate的launch​Options';
var disqus_url = 'http://blog.morefun.mobi/2014/01/08/2014-01-08-uiapplicationdelegate-launchoptions/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//rockonmycode.disqus.com/count.js" async></script><div class="copyright"><p>© 2012 - 2017 <a href="http://blog.morefun.mobi">Tinghui</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>