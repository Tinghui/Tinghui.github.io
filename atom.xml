<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Morefun With Coding</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.morefun.mobi/"/>
  <updated>2017-08-13T08:38:48.000Z</updated>
  <id>http://blog.morefun.mobi/</id>
  
  <author>
    <name>Tinghui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什么时候使用updateConstraints</title>
    <link href="http://blog.morefun.mobi/2015/09/01/2015-09-01-he-shi-shi-yong-updateconstraints/"/>
    <id>http://blog.morefun.mobi/2015/09/01/2015-09-01-he-shi-shi-yong-updateconstraints/</id>
    <published>2015-09-01T15:22:00.000Z</published>
    <updated>2017-08-13T08:38:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>UIView中的<code>updateConstraints</code>方法一直是一个令人纠结的地方。按照<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/#//apple_ref/occ/instm/UIView/updateConstraints" target="_blank" rel="external">苹果官方文档</a>中给出的建议：</p>
<blockquote>
<p>Custom views that set up constraints themselves should do so by overriding this method. When your custom view notes that a change has been made to the view that invalidates one of its constraints, it should immediately remove that constraint, and then call setNeedsUpdateConstraints to note that constraints need to be updated. Before layout is performed, your implementation of updateConstraints will be invoked, allowing you to verify that all necessary constraints for your content are in place at a time when your custom view’s properties are not changing.</p>
</blockquote>
<p>当视图的改变使得某个约束无效时，应当把该约束移除，并调用<code>setNeedsUpdateConstraints</code>以标记视图需要更新约束，然后在<code>updateConstraints</code>中更新约束。</p>
<p>然而，实际上却并不那么好用：</p>
<a id="more"></a>
<ol>
<li>每次执行<code>updateConstraints()</code>方法时，视图的状态并不是完全相同的。视图可能已经有一些约束了，而且大部分情况下你可能只想更改一部分约束。这就导致<code>updateConstraints()</code>中散落着各种if语句用来判断指定的约束是否已经存在。</li>
<li>视图也不一定完全拥有它的所有约束。视图层级中的其他视图可能会把约束加到你的视图上，所以你的代码也不能假设constraints数组中的哪个约束是干什么的。这意味着你必须用单独的属性来跟踪所有可能需要修改的约束。</li>
<li>改变约束通常是在响应事件的时候。如果你遵循了官方文档的建议，在处理事件，改变内部状态后，就需要调用<code>setNeedsUpdateConstraints()</code>。结果就是：修改布局的代码（在updateConstraints()里面）和触发修改的代码分离在不同的地方，逻辑难以理解。</li>
</ol>
<p>那么我们应该按照文档建议的那样使用<code>updateConstraints()</code>吗？在今年的WWDC技术讲座 <a href="https://developer.apple.com/videos/wwdc/2015/?id=219" target="_blank" rel="external">Mysteries of Auto Layout (Part 2) </a>上，苹果给出了新的建议：</p>
<blockquote>
<p>Really, all this is is a way for views to have a chance to make changes to constraints just in time for the next layout pass, but it’s often not actually needed.</p>
<p>All of your initial constraint setup should ideally happen inside Interface Builder. Or if you really find that you need to allocate your constraints programmatically, some place like viewDidLoad is much better. updateConstraints is really just for work that needs to be repeated periodically.</p>
<p>Also, it’s pretty straightforward to just change constraints when you find the need to do that; whereas, if you take that logic apart from the other code that’s related to it and you move it into a separate method that gets executed at a later time, your code becomes a lot harder to follow, so it will be harder for you to maintain, it will be a lot harder for other people to understand.</p>
<p>So when would you need to use updateConstraints? Well, it boils down to performance. If you find that just changing your constraints in place is too slow, then update constraints might be able to help you out. It turns out that changing a constraint inside updateConstraints is actually faster than changing a constraint at other times. The reason for that is because the engine is able to treat all the constraint changes that happen in this pass as a batch.</p>
</blockquote>
<p>总结下来就是：不要将<code>updateConstraints()</code>用于视图的初始化设置。当你需要在单个布局流程（single layout pass）中添加、修改或删除大量约束的时候，用它来获得最佳性能。如果没有性能问题，直接更新约束更简单。</p>
<p>参考：</p>
<ol>
<li><a href="http://oleb.net/blog/2015/08/how-to-use-updateconstraints/" target="_blank" rel="external">How to Use updateConstraints</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/#//apple_ref/occ/instm/UIView/updateConstraints" target="_blank" rel="external">UIView Class Reference</a></li>
<li><a href="https://developer.apple.com/videos/wwdc/2015/?id=219" target="_blank" rel="external">WWDC session: Mysteries of Auto Layout (Part 2)</a></li>
</ol>
<p style="text-align:center"><img src="/images/posts/thx_money.png" width="50%" height="50%"></p>

]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UIView中的&lt;code&gt;updateConstraints&lt;/code&gt;方法一直是一个令人纠结的地方。按照&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/#//apple_ref/occ/instm/UIView/updateConstraints&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;苹果官方文档&lt;/a&gt;中给出的建议：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Custom views that set up constraints themselves should do so by overriding this method. When your custom view notes that a change has been made to the view that invalidates one of its constraints, it should immediately remove that constraint, and then call setNeedsUpdateConstraints to note that constraints need to be updated. Before layout is performed, your implementation of updateConstraints will be invoked, allowing you to verify that all necessary constraints for your content are in place at a time when your custom view’s properties are not changing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当视图的改变使得某个约束无效时，应当把该约束移除，并调用&lt;code&gt;setNeedsUpdateConstraints&lt;/code&gt;以标记视图需要更新约束，然后在&lt;code&gt;updateConstraints&lt;/code&gt;中更新约束。&lt;/p&gt;
&lt;p&gt;然而，实际上却并不那么好用：&lt;/p&gt;
    
    </summary>
    
      <category term="AutoLayout" scheme="http://blog.morefun.mobi/categories/AutoLayout/"/>
    
    
  </entry>
  
  <entry>
    <title>Content Compression Resistance和Content Hugging</title>
    <link href="http://blog.morefun.mobi/2015/01/28/2015-01-28-autolayoutzhong-de-content-compression-resistancehe-content-huggingdao-di-shi-shi-yao-yi-si/"/>
    <id>http://blog.morefun.mobi/2015/01/28/2015-01-28-autolayoutzhong-de-content-compression-resistancehe-content-huggingdao-di-shi-shi-yao-yi-si/</id>
    <published>2015-01-28T05:54:00.000Z</published>
    <updated>2017-08-13T08:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>AutoLayout中，<code>Content Compression Resistance</code>和<code>Content Hugging</code>这两个概念，从字面上很难理解它们意思和用途，苹果官方文档中相关描述也比较少。中文翻译中大多数都把它们按字面翻译成<code>内容压缩阻力</code>和<code>内容吸附性</code>，也不是很好理解。最近搜索和查看了一些文章和资料，搞清楚了它们的作用，在此整理一下。</p>
<a id="more"></a>
<h2 id="固有内容尺寸（Intrinsic-Content-Size）"><a href="#固有内容尺寸（Intrinsic-Content-Size）" class="headerlink" title="固有内容尺寸（Intrinsic Content Size）"></a>固有内容尺寸（Intrinsic Content Size）</h2><p>要理解内容压缩阻力和内容吸附性这两个概念，首先要理解固有内容尺寸（Intrinsic Content Size）这一概念。</p>
<p>每个视图都有内容压缩阻力优先级（Content Compression Resistance Priority）和内容吸附性优先级（Content Hugging Priority）。<strong>但只有当视图定义了固有内容尺寸后，这两种优先级才会起作用；</strong>否则如果都没有定义内容尺寸大小，又如何知道应该抗压缩或者吸附至什么大小呢。</p>
<p>那么，固有内容尺寸是什么，有什么作用呢？</p>
<p>引用自苹果官方AutoLayout指南里面对固有内容尺寸的描述：</p>
<blockquote>
<p><strong>Intrinsic Content Size</strong></p>
<p>Leaf-level views such as buttons typically know more about what size they should be than does the code that is positioning them. This is communicated through the intrinsic content size, which tells the layout system that a view contains some content that it doesn’t natively understand, and indicates how large that content is, intrinsically.</p>
<p>For elements such as text labels, you should typically set the element to be its intrinsic size (select Editor &gt; Size To Fit Content). This means that the element will grow and shrink appropriately with different content for different languages.</p>
</blockquote>
<p>什么意思呢？</p>
<p>简单来说就是，像按钮、文本标签这类视图控件，在布局的时候，它们自己内部比外部布局代码更清楚自己需要多大的尺寸来显示自己的内容。这个尺寸就是由固有内容尺寸（intrinsic content size）来传达的。这就相当于，固有内容尺寸告诉布局系统：“这个视图里面包含了一些你不能理解的内容，但是我给你指出了那些内容有多大的尺寸。”</p>
<p>由此可见，固有内容尺寸是为了实现视图自适应大小而准备的。</p>
<h2 id="Content-Compression-Resistance-与-Content-Hugging"><a href="#Content-Compression-Resistance-与-Content-Hugging" class="headerlink" title="Content Compression Resistance 与 Content Hugging"></a>Content Compression Resistance 与 Content Hugging</h2><p>关于这两个概念，最容易理解的文档说明在UIView Class Reference文档里面：</p>
<blockquote>
<p><strong><code>- contentCompressionResistancePriorityForAxis:</code></strong></p>
<p>Returns the priority with which a view resists being made smaller than its intrinsic size.</p>
<p><strong><code>- contentHuggingPriorityForAxis:</code></strong></p>
<p>Returns the priority with which a view resists being made larger than its intrinsic size.</p>
</blockquote>
<p>通过以上两个接口的说明，其意义已经相当清楚了：内容压缩阻力优先级就是视图反压缩的优先级，优先级越大，视图就越不容易被压小；内容吸附性优先级就是视图反拉伸的优先级，优先级越大，视图就越不容易被拉大。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面，引用一个来自<a href="http://stackoverflow.com/questions/15850417/cocoa-autolayout-content-hugging-vs-content-compression-resistance-priority" target="_blank" rel="external">stackoverflow</a>的例子，这个例子很形象的解释了内容压缩阻力和内容吸附性优先级的作用。</p>
<p>假设，你有一个下面这样的按钮：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[		Click Me		]</div></pre></td></tr></table></figure>
<p>按钮与其父视图之间的边距约束优先级是500。</p>
<p>那么，如果按钮的吸附性优先级（Hugging priority）大于500，按钮看起来会是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[Click Me]</div></pre></td></tr></table></figure>
<p>如果，吸附性优先级小于500，按钮会是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[		Click Me		]</div></pre></td></tr></table></figure>
<p>如果现在父视图收缩了，按钮的压缩阻力优先级（Compression Resistance priority）大于500，它看起来会是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[Click Me]</div></pre></td></tr></table></figure>
<p>否则，如果压缩阻力优先级小于500，它会是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[Cli..]</div></pre></td></tr></table></figure>
<p>如果不是这样，很可能是其他的一些约束扰乱了你的整个布局。<br>例如，你可能将边距约束优先级设置成了1000。或者可能是加一个优先级较高的宽度约束。遇到这种情况，可以试试“Editor &gt; Size to Fit Content”命令。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因此，我们可以简单总结为：</p>
<ol>
<li><strong>Content Hugging: 反拉伸</strong></li>
<li><strong>Content Compression Resistance: 反压缩</strong></li>
<li><strong>仅当视图定义了自己的Intrinsic Content Size，那么它的Content Compression Resistance优先级和Content Hugging优先级属性才有作用。</strong></li>
</ol>
<p>参考</p>
<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutConcepts/AutoLayoutConcepts.html#//apple_ref/doc/uid/TP40010853-CH14-SW2" target="_blank" rel="external">Auto Layout Guide</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/contentHuggingPriorityForAxis:" target="_blank" rel="external">UIView Class Reference</a></li>
<li><a href="http://www.objc.io/issue-3/advanced-auto-layout-toolbox.html" target="_blank" rel="external">Advanced Auto Layout Toolbox</a></li>
<li><a href="http://stackoverflow.com/questions/15850417/cocoa-autolayout-content-hugging-vs-content-compression-resistance-priority" target="_blank" rel="external">Cocoa Autolayout: content hugging vs content compression resistance priority</a></li>
</ol>
<p style="text-align:center"><img src="/images/posts/thx_money.png" width="50%" height="50%"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AutoLayout中，&lt;code&gt;Content Compression Resistance&lt;/code&gt;和&lt;code&gt;Content Hugging&lt;/code&gt;这两个概念，从字面上很难理解它们意思和用途，苹果官方文档中相关描述也比较少。中文翻译中大多数都把它们按字面翻译成&lt;code&gt;内容压缩阻力&lt;/code&gt;和&lt;code&gt;内容吸附性&lt;/code&gt;，也不是很好理解。最近搜索和查看了一些文章和资料，搞清楚了它们的作用，在此整理一下。&lt;/p&gt;
    
    </summary>
    
      <category term="AutoLayout" scheme="http://blog.morefun.mobi/categories/AutoLayout/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Autolayout实现UITableView的Cell动态布局和动态行高</title>
    <link href="http://blog.morefun.mobi/2014/10/15/2014-10-15-shi-yong-autolayoutshi-xian-uitableviewde-celldong-tai-bu-ju-he-ke-bian-xing-gao/"/>
    <id>http://blog.morefun.mobi/2014/10/15/2014-10-15-shi-yong-autolayoutshi-xian-uitableviewde-celldong-tai-bu-ju-he-ke-bian-xing-gao/</id>
    <published>2014-10-15T10:22:00.000Z</published>
    <updated>2017-08-13T08:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自：<a href="http://stackoverflow.com/questions/18746929/using-auto-layout-in-uitableview-for-dynamic-cell-layouts-variable-row-heights" target="_blank" rel="external">stackoverflow</a></p>
<p>有人在<a href="http://stackoverflow.com/questions/18746929/using-auto-layout-in-uitableview-for-dynamic-cell-layouts-variable-row-heights" target="_blank" rel="external">stackoverflow</a>上问了一个问题：</p>
<blockquote>
<p>如何在UITableViewCell中使用Autolayout来实现Cell的内容和子视图自动计算行高，并且保持平滑的滚动？</p>
</blockquote>
<p>这个问题获得了接近1000的支持和1100+的收藏，答案更是超过了1800+的支持，很详细的说明了如何在iOS7和iOS8上实现UITableView的动态行高计算。答案对实现UICollectionView的动态行高也具有参考意义，所以在这里将这个答案翻译了一下，希望对大家有所帮助。以下是答案的全文翻译：</p>
<p>全文略长，不喜欢阅读可以直接看示例代码：</p>
<ul>
<li><a href="https://github.com/smileyborg/TableViewCellWithAutoLayoutiOS8" target="_blank" rel="external">iOS8的示例代码</a> - iOS8以上才支持</li>
<li><a href="https://github.com/smileyborg/TableViewCellWithAutoLayout" target="_blank" rel="external">iOS7的示例代码</a> - iOS7+</li>
</ul>
<a id="more"></a>
<h3 id="概念描述"><a href="#概念描述" class="headerlink" title="概念描述"></a>概念描述</h3><p>不管在哪个iOS版本上进行开发，前两步是必须的：</p>
<h4 id="1、设置好布局约束"><a href="#1、设置好布局约束" class="headerlink" title="1、设置好布局约束"></a>1、设置好布局约束</h4><p>在<code>UITableViewCell</code>子类中，添加约束，使子视图的边缘与<strong>contentView</strong>的边缘固定(pin)（最重要的是要有顶部和底部的边距约束）。<strong>注意：不能将子视图的边缘设置成与cell的边缘固定，只能设置为与contentView的边缘固定！</strong> 确保每个子视图在垂直方向上的内容压缩阻力(compression resistance)和内容吸附性约束(content hugging constraints)没有被你添加的更高优先级的约束覆盖，以使得这些子视图的固有内容尺寸(intrinsic content size)来推动contentView的高度。（嗯？点击<a href="http://stackoverflow.com/questions/22599069/what-is-the-content-compression-resistance-and-content-hugging-of-a-uiview" target="_blank" rel="external">英文</a>或<a href="http://codingobjc.com/blog/2015/01/28/autolayoutzhong-de-content-compression-resistancehe-content-huggingdao-di-shi-shi-yao-yi-si/" target="_blank" rel="external">中文</a>。）</p>
<p>记住，重点是cell的子视图与contentView要有垂直方向上的连结，让它们能够对contentView“施加压力”，使contentView扩张以适合它们的尺寸。</p>
<p>下面用一个带有一些子视图的cell作为示例，展示了<strong>一些</strong>必要的约束（没有展示全部的约束）：</p>
<p><img src="http://i.stack.imgur.com/CTUPi.png" alt=""></p>
<p>可以想象，当更多的文本被添加到“Multi-line body”那个label上面后，它就需要垂直地增高以适应文本，这实际上将强迫cell增加高度。（当然，前提是你需要把约束设置正确！）</p>
<p>设置正确的约束是使用Autolayout实现动态行高时<strong>最难也最重要</strong>的部分。如果你犯了一个错误，它可能使后面一切都无法工作——所以，不要着急，慢慢来！我建议你用代码来设置约束，这样你就完全知道每个约束被加到了什么地方，出问题的时候也更容易调试。特别是如果你利用好一些优秀的开源库，使用代码设置约束可以变得和使用Interface Builder设置约束一样简单，而且更加强大。这里有一个我设计、维护和使用的开源库：<a href="https://github.com/smileyborg/PureLayout" target="_blank" rel="external">https://github.com/smileyborg/PureLayout</a></p>
<ul>
<li><p><del>如果你用代码来设置约束，应该在UITableViewCell子类的<code>updateConstraints</code>方法里面一次性完成。注意，<code>updateConstraints</code>可能不止被调用一次，因此要避免重复添加相同的约束。在<code>updateConstraints</code>中，可以将添加约束的代码包在一个if语句中(比如使用一个叫<code>didSetupConstraints</code>的布尔属性，运行一次添加约束的代码后就将其置为YES)，以确保不重复添加相同的约束。另外，更新已有约束的代码（比如调整约束的<code>constant</code>属性），也应该将它们放置在<code>updateConstraints</code>中，但是要在<code>didSetupConstraints</code>条件语句的外面，这样才能保证每次调用的时候都被执行。</del></p>
</li>
<li><p>译注：上面这段<code>updateConstraints</code>中添加约束的描述，由于文章久远，已经不合时宜。苹果官方在 <a href="https://developer.apple.com/videos/wwdc/2015/?id=219" target="_blank" rel="external">WWDC2015 session219</a> 中已经给出了<code>updateConstraints</code>使用的<a href="/2015/09/01/2015-09-01-he-shi-shi-yong-updateconstraints/">新建议</a>。</p>
</li>
</ul>
<h4 id="2-确立唯一的Cell重用标示符"><a href="#2-确立唯一的Cell重用标示符" class="headerlink" title="2. 确立唯一的Cell重用标示符"></a>2. 确立唯一的Cell重用标示符</h4><p>为cell中每一组独特的约束，使用一个唯一的cell重用标示符。也就是说，如果cell有不止一种布局，每一种布局都应当有其对应的重用标示符。（当cell有多种布局包含不同数量的子视图的时候或者子视图以不同的方式布局的时候，你就需要使用一个新的重用标示符。）</p>
<p>例如，要在一个cell中显示一条email消息，可能会有4种不同的布局：第一种，只有主题；第二种，主题和正文；第三种，主题和图片附件；第四种，主题、正文和图片附件。每一种布局都需要完全不同的约束才能实现。因此，一旦cell被初始化并且约束被加到其中任意一种类型的cell上之后，cell应当得到一个唯一的重用标示符来指定该cell类型。这样，当你dequeue重用cell的时候，该cell类型的约束已经添加好了，拿来即用。</p>
<p>注意，由于固有内容尺寸的不同，具有相同布局约束的cell仍然可能具有不同的高度！不要混淆了不同的布局（不同的约束）和由于不同的内容尺寸而计算出（通过相同的约束来计算）的不同的视图frame这两个概念，它们本质上是两个完全不同的东西。(译注：本段翻译的不好，如果有疑惑，可以看看<a href="http://stackoverflow.com/questions/18746929/using-auto-layout-in-uitableview-for-dynamic-cell-layouts-variable-row-heights" target="_blank" rel="external">原文</a>。)</p>
<ul>
<li>不要将拥有不同布局约束的cell丢到同一个重用池中（也就是使用相同的重用标示符），然后又在每次dequeue过后企图将旧的约束移除后从头开始重新添加约束。内部自动布局引擎并没有被设计来可以处理大规模的约束更改，你会看到大量的性能问题。</li>
</ul>
<h4 id="iOS8适用-Self-Sizing-Cells"><a href="#iOS8适用-Self-Sizing-Cells" class="headerlink" title="iOS8适用 - Self-Sizing Cells"></a>iOS8适用 - Self-Sizing Cells</h4><h5 id="3-启用行高估算"><a href="#3-启用行高估算" class="headerlink" title="3. 启用行高估算"></a>3. 启用行高估算</h5><p>在iOS8上，苹果将许多在之前你比较难实现的东西都内置实现了。为了让cell实现自适应（self-sizing），必须先将tableView的<code>rowHeight</code>属性设置为常量<code>UITableViewAutomaticDimension</code>。然后，只需将tableView的<code>estimatedRowHeight</code>属性设置为一个非零值即可开启行高估算功能，例如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">self</span>.tableView.rowHeight = <span class="built_in">UITableViewAutomaticDimension</span>;</div><div class="line"><span class="keyword">self</span>.tableView.estimatedRowHeight = <span class="number">44.0</span>; <span class="comment">// 设置为一个接近于行高“平均值”的数值</span></div></pre></td></tr></table></figure>
<p>这样就为tableView提供了一个还没有被显示在屏幕上的cell的临时估算的行高。当cell即将滚入屏幕范围内的时候，会计算出真实的高度。为了确定每一行的实际高度，tableView会自动让每个cell基于其contentView的已知固定宽度（tableView的宽度减去其他额外的，像section index或accessoryView这些宽度）和被添加到contentView及其子视图上的布局约束来计算<code>contentView</code>的高度。真实的行高被计算出来之后，旧的估算的行高会被更新为这个真实的行高（并且其他任何需要对tableView的contentSize或contentOffset的更改都自动替你完成）。</p>
<p>一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的<code>estimatedRowHeight</code>属性设置成（在<code>viewDidLoad</code>或类似的方法中）一个接近于行高“平均值”的常量值即可。<em>仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现<code>tableView:estimatedHeightForRowAtIndexPath:</code>方法，为每一行返回一个更精确的估算值。</em></p>
<h4 id="iOS7支持（自己实现cell尺寸自适应功能）"><a href="#iOS7支持（自己实现cell尺寸自适应功能）" class="headerlink" title="iOS7支持（自己实现cell尺寸自适应功能）"></a>iOS7支持（自己实现cell尺寸自适应功能）</h4><h5 id="3-完成一个完整的布局过程-amp-获得行高"><a href="#3-完成一个完整的布局过程-amp-获得行高" class="headerlink" title="3. 完成一个完整的布局过程 &amp; 获得行高"></a>3. 完成一个完整的布局过程 &amp; 获得行高</h5><p>首先，实例化一个离屏(offscreen)的cell实例，为每个重用标示符实例化一个与之对应的cell实例，这些cell实例严格的仅用于高度计算。（离屏表示cell的引用被存储在view controller的一个属性或实例变量之中，并且这个cell绝对不会被用作<code>tableView:cellForRowAtIndexPath:</code>方法的返回值显示在屏幕上。）接下来，这个cell的内容（例如，文本、图片等等）还必须被配置为与显示在table view中的内容完全一样。</p>
<p>然后，强制cell立即更新子视图的布局，再在cell的<code>contentView</code>上调用<code>systemLayoutSizeFittingSize:</code>方法以计算出cell所需的高度。使用<code>UILayoutFittingCompressedSize</code>参数得到适合cell中所有内容所需的最小尺寸。然后将其高度作为<code>tableView:heightForRowAtIndexPath:</code>方法的返回值返回给table view。</p>
<h5 id="4-使用估算的行高"><a href="#4-使用估算的行高" class="headerlink" title="4. 使用估算的行高"></a>4. 使用估算的行高</h5><p>如果你的table view超过几十行，你会发现在第一次加载table view的时候会卡住主线程。因为，在第一次加载的过程中，会对每一行调用<code>tableView:heightForRowAtIndexPath:</code>方法（为了计算滚动条的尺寸）。</p>
<p>iOS7中，你可以（也绝对应当）使用table view的<code>estimatedRowHeight</code>属性。这样会为还不在屏幕范围内的cell提供一个临时估算的行高值。然后，当这些cell即将要滚入屏幕范围内的时候，真实的行高值会被计算出来（通过<code>tableView:heightForRowAtIndexPath:</code>方法），估算的行高会被替换掉。</p>
<p>一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的<code>estimatedRowHeight</code>属性设置成（在<code>viewDidLoad</code>或类似的方法中）一个接近于行高“平均值”的常量值即可。<em>仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现<code>tableView:estimatedHeightForRowAtIndexPath:</code>方法，为每一行返回一个更精确的估算值。</em></p>
<h5 id="5-缓存行高（如果需要）"><a href="#5-缓存行高（如果需要）" class="headerlink" title="5. 缓存行高（如果需要）"></a>5. 缓存行高（如果需要）</h5><p>如果上面提到的你都做了，但是<code>tableView:heightForRowAtIndexPath:</code>的性能仍然慢的不可接受。非常不幸，这个时候你需要给行高做一些缓存（这是苹果的工程师们给出的改进建议）。大体的思路是，第一次计算时让自动布局引擎解析布局约束计算行高，然后将计算出来的行高缓存起来，之后所有对该cell的高度请求都返回缓存值。当然，还要保证任何导致cell高度变化的情况发生时都要清除缓存的行高——这通常发生在cell的内容变化时或其他重大事件发生的时候（比如用户调节了动态类型文本大小(Dynamic Type text size)的滑动条）。</p>
<h5 id="iOS7示例代码（包含详细的注释）"><a href="#iOS7示例代码（包含详细的注释）" class="headerlink" title="iOS7示例代码（包含详细的注释）"></a>iOS7示例代码（包含详细的注释）</h5><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 判断indexPath对应cell的重用标示符，</span></div><div class="line">    <span class="comment">// 取决于特定的布局需求（可能只有一个，也或者有多个）</span></div><div class="line">    <span class="built_in">NSString</span> *reuseIdentifier = ...;</div><div class="line"></div><div class="line">    <span class="comment">// 取出重用标示符对应的cell。</span></div><div class="line">    <span class="comment">// 注意，如果重用池(reuse pool)里面没有可用的cell，这个方法会初始化并返回一个全新的cell，</span></div><div class="line">    <span class="comment">// 因此无论怎样，此行代码过后，你会得到一个布局约束已经完全准备好，可以直接使用的cell。</span></div><div class="line">    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:reuseIdentifier];</div><div class="line"></div><div class="line">    <span class="comment">// 用indexPath对应的数据内容来配置cell，例如：</span></div><div class="line">    <span class="comment">// cell.textLabel.text = someTextForThisCell;</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="comment">// 确保cell的布局约束已经被设置好，因为它可能刚刚才被创建。</span></div><div class="line">    <span class="comment">// 假设你已经在cell的updateConstraints方法中设置好了约束，使用下面两行代码：</span></div><div class="line">    [cell setNeedsUpdateConstraints];</div><div class="line">    [cell updateConstraintsIfNeeded];</div><div class="line"></div><div class="line">    <span class="comment">// 如果你使用了多行的UILabel，不要忘了给label设置正确的preferredMaxLayoutWidth值。</span></div><div class="line">    <span class="comment">// 如果你没有在cell的layoutSubviews方法中设置，就需要在这里设置。例如：</span></div><div class="line">    <span class="comment">// cell.multiLineLabel.preferredMaxLayoutWidth = CGRectGetWidth(tableView.bounds);</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 判断indexPath对应cell的重用标示符，</span></div><div class="line">    <span class="built_in">NSString</span> *reuseIdentifier = ...;</div><div class="line"></div><div class="line">    <span class="comment">// 从缓存字典中取出重用标示符对应的cell。如果没有，就创建一个新的然后存储在字典里面。</span></div><div class="line">    <span class="comment">// 警告：不要调用table view的dequeueReusableCellWithIdentifier:方法，因为这会导致cell被创建了但是又未曾被tableView:cellForRowAtIndexPath:方法返回，会造成内存泄露！</span></div><div class="line">    <span class="comment">// 译注：原文这里说的dequeueReusableCellWithIdentifier:会造成内存泄漏的说法是错误的，并不会造成内存泄漏。</span></div><div class="line">    <span class="built_in">UITableViewCell</span> *cell = [<span class="keyword">self</span>.offscreenCells objectForKey:reuseIdentifier];</div><div class="line">    <span class="keyword">if</span> (!cell) &#123;</div><div class="line">        cell = [[YourTableViewCellClass alloc] init];</div><div class="line">        [<span class="keyword">self</span>.offscreenCells setObject:cell forKey:reuseIdentifier];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 用indexPath对应的数据内容来配置cell，例如：</span></div><div class="line">    <span class="comment">// cell.textLabel.text = someTextForThisCell;</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="comment">// 确保cell的布局约束已经被设置好，因为它可能刚刚才被创建。</span></div><div class="line">    <span class="comment">// 假设你已经在cell的updateConstraints方法中设置好了约束，使用下面两行代码：</span></div><div class="line">    [cell setNeedsUpdateConstraints];</div><div class="line">    [cell updateConstraintsIfNeeded];</div><div class="line"></div><div class="line">    <span class="comment">// 将cell的宽度设置为与tableView的宽度一样。</span></div><div class="line">    <span class="comment">// 这点很重要。</span></div><div class="line">    <span class="comment">// 如果cell的高度取决于table view的宽度（例如，多行的UILabel通过单词换行等方式换行），</span></div><div class="line">    <span class="comment">// 那么这使得对于不同宽度的table view，我们都可以基于其宽度而得到cell的高度。</span></div><div class="line">    <span class="comment">// 但是，我们不需要在-[tableView:cellForRowAtIndexPath]方法中做相同的处理（设置宽度），</span></div><div class="line">    <span class="comment">// 因为，cell被用到table view中的时候，这一步是自动完成的。</span></div><div class="line">    <span class="comment">// 也要注意，某些情况下，cell的最终宽度可能不等于table view的宽度。</span></div><div class="line">    <span class="comment">// 例如当table view的右边显示了section index的时候，必须要减去这个宽度。</span></div><div class="line">    cell.bounds = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="built_in">CGRectGetWidth</span>(tableView.bounds), <span class="built_in">CGRectGetHeight</span>(cell.bounds));</div><div class="line"></div><div class="line">    <span class="comment">// 触发cell的布局过程，会基于布局约束计算所有视图的frame。</span></div><div class="line">    <span class="comment">// （注意，你必须在cell的layoutSubviews方法中给多行的UILabel设置好preferredMaxLayoutWidth值；</span></div><div class="line">    <span class="comment">// 或者在下面2行代码前手动设置！）</span></div><div class="line">    [cell setNeedsLayout];</div><div class="line">    [cell layoutIfNeeded];</div><div class="line"></div><div class="line">    <span class="comment">// 得到cell的contentView需要的真实高度</span></div><div class="line">    <span class="built_in">CGFloat</span> height = [cell.contentView systemLayoutSizeFittingSize:<span class="built_in">UILayoutFittingCompressedSize</span>].height;</div><div class="line"></div><div class="line">    <span class="comment">// 为cell的分割线加上额外的1pt高度。因为分隔线是被加在cell底边与contentView底边之间的。</span></div><div class="line">    height += <span class="number">1.0</span>f;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> height;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 注意：除非行高极端变化并且你已经明显的觉察到了滚动时滚动条的“跳跃”现象，你才需要实现此方法；否则，直接用tableView的estimatedRowHeight属性即可。</span></div><div class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView estimatedHeightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 以最小计算量，返回实际高度数量级之内的一个行高估算值。</span></div><div class="line">    <span class="comment">// 例如：</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isTallCellAtIndexPath:indexPath]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">350.0</span>f;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">40.0</span>f;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h3><ul>
<li><a href="https://github.com/smileyborg/TableViewCellWithAutoLayoutiOS8" target="_blank" rel="external">iOS8的示例代码</a> - iOS8以上才支持</li>
<li><a href="https://github.com/smileyborg/TableViewCellWithAutoLayout" target="_blank" rel="external">iOS7的示例代码</a> - iOS7+</li>
</ul>
<p>最后，推荐两个相关的开源库：</p>
<ul>
<li><a href="https://github.com/smileyborg/PureLayout" target="_blank" rel="external">PureLayout</a>：原文作者使用和开源的布局库，用代码写布局约束的时候很方便。</li>
<li><a href="https://github.com/Tinghui/UITableView-CellHeightCalculation" target="_blank" rel="external">UITableView-CellHeightCalculation</a>：根据本文思路封装的UITableView动态行高计算和行高缓存库，由本人开源和维护。</li>
</ul>
<p>有任何问题，欢迎大家留言讨论！</p>
<p style="text-align:center"><img src="/images/posts/thx_money.png" width="50%" height="50%"></p>


]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自：&lt;a href=&quot;http://stackoverflow.com/questions/18746929/using-auto-layout-in-uitableview-for-dynamic-cell-layouts-variable-row-heights&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有人在&lt;a href=&quot;http://stackoverflow.com/questions/18746929/using-auto-layout-in-uitableview-for-dynamic-cell-layouts-variable-row-heights&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow&lt;/a&gt;上问了一个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何在UITableViewCell中使用Autolayout来实现Cell的内容和子视图自动计算行高，并且保持平滑的滚动？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个问题获得了接近1000的支持和1100+的收藏，答案更是超过了1800+的支持，很详细的说明了如何在iOS7和iOS8上实现UITableView的动态行高计算。答案对实现UICollectionView的动态行高也具有参考意义，所以在这里将这个答案翻译了一下，希望对大家有所帮助。以下是答案的全文翻译：&lt;/p&gt;
&lt;p&gt;全文略长，不喜欢阅读可以直接看示例代码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/smileyborg/TableViewCellWithAutoLayoutiOS8&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS8的示例代码&lt;/a&gt; - iOS8以上才支持&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/smileyborg/TableViewCellWithAutoLayout&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS7的示例代码&lt;/a&gt; - iOS7+&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="AutoLayout" scheme="http://blog.morefun.mobi/categories/AutoLayout/"/>
    
    
  </entry>
  
  <entry>
    <title>Objective-C到Swift：一些想法和建议</title>
    <link href="http://blog.morefun.mobi/2014/07/15/2014-07-15-you-objective-cdao-swiftde-xie-gan-xiang-he-ti-shi/"/>
    <id>http://blog.morefun.mobi/2014/07/15/2014-07-15-you-objective-cdao-swiftde-xie-gan-xiang-he-ti-shi/</id>
    <published>2014-07-15T01:25:00.000Z</published>
    <updated>2017-08-13T08:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文分享一些在由Objective-C转换至Swift的过程中产生的思考，并尝试总结了一些技巧建议和一些误区陷阱。本文尽量通过对比来展示这两种语言在同一个问题上的不同处理方法。开始吧！</p>
<h2 id="单文件-vs-接口-实现文件"><a href="#单文件-vs-接口-实现文件" class="headerlink" title="单文件 vs. 接口-实现文件"></a>单文件 vs. 接口-实现文件</h2><p>第一个重大的变化是：<code>interface.h/implementation.m</code>的文件结构被舍弃了。</p>
<p>我是这种文件结构的坚定支持者。只通过接口文件来获取或共享类相关的信息，不仅安全而且很方便。</p>
<p>在Swift中，接口和实现并没有分离。我们只能实现自己的类（并且在写代码的时候甚至不能添加可见性修饰符）。<br><a id="more"></a></p>
<p>如果真的无法忍受这个变化，可以使用以下这些方法，但有些要慎用：</p>
<p>第一个是显而易见的：<strong>要使用普遍的用法</strong></p>
<p>良好的文档可以轻易地增加类的可读性。例如，我们可以将我们想要“公开（public）”的元素都移到文件的顶部，可以使用类扩展（extension）来隔离公有的和私有的区域。</p>
<p>另一个真正常见的做法是：所有私有的方法和变量的命名都以下划线“_”开头。</p>
<p>这里有个混合了这两种方法的简短例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Public</span></div><div class="line">extension DataReader &#123;</div><div class="line">    var data &#123; &#125;</div><div class="line">    func readData()&#123;</div><div class="line">        var data = _webserviceInteraction()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// Private implementation</span></div><div class="line"><span class="keyword">class</span> DataReader: <span class="built_in">NSObject</span> &#123;</div><div class="line">    </div><div class="line">    let _wsURL = <span class="built_in">NSURL</span>(string: <span class="string">"http://theurl.com"</span>)</div><div class="line">     </div><div class="line">    func _webserviceInteraction()-&gt;String&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然我们不能修改类元素的可见性，但是我们可以尝试让它们变得“更难”被直接访问到。</p>
<p>有种奇特的解决方法是：使用内嵌的类来部分隐藏私有区域(至少可以对代码自动补全功能达到隐藏)。下面是一个例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">import <span class="built_in">UIKit</span></div><div class="line"> </div><div class="line"><span class="keyword">class</span> DataReader: <span class="built_in">NSObject</span> &#123;</div><div class="line">     </div><div class="line">    <span class="comment">// Public ***********************</span></div><div class="line">    var data:String?&#123;</div><div class="line">        get&#123;<span class="keyword">return</span> private.internalData&#125;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    init()&#123;</div><div class="line">        private = DataReaderPrivate()</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    func publicFunction()&#123;</div><div class="line">        private.privateFunc()</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">     </div><div class="line">    <span class="comment">// Private **********************</span></div><div class="line">    var private:DataReaderPrivate</div><div class="line">     </div><div class="line">    <span class="keyword">class</span> DataReaderPrivate &#123;</div><div class="line">        var internalData:String?</div><div class="line">         </div><div class="line">        init()&#123;</div><div class="line">            internalData = <span class="string">"Private data!"</span></div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        func privateFunc ()&#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将私有实现放入了一个名叫<strong>private</strong>的常量实例，然后用“正规的”类实现来作为公共的接口。这些私有的元素并没有被真正的隐藏，但要访问它们，就不得不通过”private”常量。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">let reader = DataReader()</div><div class="line">reader.private.privateFunc()</div></pre></td></tr></table></figure>
<p><strong>问题是：</strong>要达到部分隐藏私有元素的目的而使用这种怪异的模式是否值得？</p>
<p>我的建议是再等等，再等等可见性修饰符相关的更新(<font color="orange">译注：在翻译这篇文章的时候，苹果已经在Swift中引入<a href="https://developer.apple.com/swift/blog/?id=5" target="_blank" rel="external">访问权限</a>了</font>)。在此期间，不管是否使用类扩展的方式，都要写好文档。</p>
<h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><p>在Objective-C中，我真的很少使用<strong>const</strong>关键词，甚至即便我知道某些数据永远不会被改变的时候我也没有用const（好吧…我羞愧）。在Swift中，苹果建议开发者多考虑选择使用常量(<strong>let</strong>)而不是使用变量(<strong>var</strong>)。因此，多留意一下，试着找到变量的最佳角色。最终，你会比你预想多得多的使用常量。</p>
<h2 id="只写必须要写的"><a href="#只写必须要写的" class="headerlink" title="只写必须要写的"></a>只写必须要写的</h2><p>看看下面这两行代码，找出有什么不同：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">let wsURL:<span class="built_in">NSURL</span> = <span class="built_in">NSURL</span>(string:<span class="string">"http://wsurl.com"</span>);</div><div class="line">vs</div><div class="line">let wsURL = <span class="built_in">NSURL</span>(string:<span class="string">"http://wsurl.com"</span>)</div></pre></td></tr></table></figure>
<p>在开始转向Swift的前两周，我强迫自己不要在每行代码后面写<strong>分号</strong>。现在好多了（但是我现在经常忘了在Objective-C中写分号 <img src="http://www.thinkandbuild.it/wp-includes/images/smilies/icon_neutral.gif" alt=""> ）。</p>
<p><strong>类型推断</strong>是一种直接从变量的定义推断出它的类型的能力。这又是一个带来方便的地方。但是如果是从一种冗长(verbose)的语言(像Objective-C)而来时，会觉得有点难以接受。</p>
<p>我们应当试着使用一些命名约定来对方法名进行命名，否则如果选择了一种非常不幸的命名方式，那么另外的开发者(也包括你自己)会很难猜出类型推断出的是什么类型：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">let a = something()</div></pre></td></tr></table></figure>
<p>一个更合理的名字可以帮助我们理解：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">let a = anInt()</div></pre></td></tr></table></figure>
<p>另一个重要的变化是圆括号的使用：它们不再是必需的了。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (a &gt; b)&#123;&#125;</div><div class="line">     vs   </div><div class="line"><span class="keyword">if</span> a &gt; b &#123;&#125;</div></pre></td></tr></table></figure>
<p>但是请记住，我们写在圆括号当中的东西是被当作一个表达式的，并不总是可以不写括号。例如，在变量绑定（variable binding）中，我们不能使用圆括号：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (let x = data)&#123;&#125; <span class="comment">// Error! </span></div><div class="line"><span class="keyword">if</span> let x = data &#123;&#125; <span class="comment">// OK!</span></div></pre></td></tr></table></figure>
<p>我们没有被强制要求必须要采用类型推断或者移除掉分号和圆括号，但是我们可以认为这些是Swift推荐的代码写法。最终提高了可读性，并且减少了一些键盘打字量。</p>
<h2 id="可选类型-OPTIONALS"><a href="#可选类型-OPTIONALS" class="headerlink" title="可选类型(OPTIONALS)"></a>可选类型(OPTIONALS)</h2><p>有多少次，你都在和要么返回“一个值”要么返回“空”的函数打交道，你有没有想过什么是定义“空”的最好方式？我用过NSNotFound、-1、0和其他一些自定义的返回值……</p>
<p>感谢可选类型(Optionals)，现在我们拥有了“空或有值(nothing-value)”的完整定义，只需要在数据类型后面加一个问号即可。</p>
<p>我们可以这样写：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Person&#123;</div><div class="line">    let name:String</div><div class="line">    let car:Car? <span class="comment">// Optional value</span></div><div class="line">     </div><div class="line">    init(name:String)&#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// ACCESSING THE OPTIONAL VALUE ***********</span></div><div class="line"> </div><div class="line">var Mark = Person(name:<span class="string">"mark"</span>)</div><div class="line"> </div><div class="line"><span class="comment">// use optional binding </span></div><div class="line"><span class="keyword">if</span> let car = Mark.car &#123;</div><div class="line">    car.accelerate()</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// unwrap the value</span></div><div class="line">Mark.car?.accelerate()</div></pre></td></tr></table></figure>
<p>这个例子中，”人有一辆车”这个关系被定义成了一个可选类型。这表示car这个属性可以是nil，一个人可以没有车。</p>
<p>然后我们使用了可选类型绑定(optional binding)(if let car =)或可选类型解析(unwrap)(car?)来访问这个值。</p>
<p>如果我们没有将一个属性定义为一个可选类型，那么我们需要为它设置一个值，否则编译器很快就会抱怨。</p>
<p>定义一个非可选类型属性值的最后机会是在初始化方法里面。因此，我们需要确定类的属性会如何和类的其他部分进行交互以及在类实例中它们会有何种行为。</p>
<p>这些改进彻底改变了我们构思类的方法。</p>
<h2 id="可选类型解析-OPTIONALS-UNWRAPPING"><a href="#可选类型解析-OPTIONALS-UNWRAPPING" class="headerlink" title="可选类型解析(OPTIONALS UNWRAPPING)"></a>可选类型解析(OPTIONALS UNWRAPPING)</h2><p>如果你发现可选类型用起来有些困难，那是因为你还没理解为什么编译器要求你在使用一个值之前要先将它给解包(unwrap)…</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">Mark.car?</div></pre></td></tr></table></figure>
<p>…我建议你将可选类型想象成一个结构体（它是一个结构体，所以不会太难 <img src="http://www.thinkandbuild.it/wp-includes/images/smilies/icon_razz.gif" alt="">），它没有直接包含你的值，而是给它包(wrap)了一层。如果内部这个值定义了，你把外面包的一层给解开(unwarp)后，就得到值了；否则就得到nil。BOOM，想通了吧！</p>
<p>使用“!”这个符号是强行解包的意思。解包的时候不会关心内部是什么值。你就在“冒着风险”使用里面的值。如果值为nil，应用程序就会挂掉。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>在用Objective-C和Cocoa写了多年程序之后，我们都对代理模式上瘾了。</p>
<p>不要怕！我们仍然采用和过去一样的方式来使用这种模式。下面有个超级简单的使用代理模式的例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">@objc protocol DataReaderDelegate&#123;</div><div class="line">    <span class="keyword">@optional</span> func DataWillRead()</div><div class="line">    func DataDidRead()</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">class</span> DataReader: <span class="built_in">NSObject</span> &#123;</div><div class="line">    </div><div class="line">    var delegate:DataReaderDelegate?</div><div class="line">    var data:<span class="built_in">NSData</span>?</div><div class="line"> </div><div class="line">    func buildData()&#123;</div><div class="line">         </div><div class="line">        delegate?.DataWillRead?() <span class="comment">// Optional method check</span></div><div class="line">        data = _createData()</div><div class="line">        delegate?.DataDidRead()       <span class="comment">// Required method check</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用了一个优雅的<strong>可选链(optional chaining)</strong>来代替<strong>respondToSelector</strong>进行代理是否存在的检查。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">delegate?.DataWillRead?()</div></pre></td></tr></table></figure>
<p>注意，由于我们使用了<strong>@optional</strong>，所以需要在协议前面加<strong>@obj</strong>。如果我们忘了，编译器也会给我们一个明确的警告信息。</p>
<p>为了实现这个代理，我们用另外一个类实现了这个协议，然后用它进行赋值，就和在Objective-C中的做法一样：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> ViewController: <span class="built_in">UIViewController</span>, DataReaderDelegate &#123;</div><div class="line">                             </div><div class="line">    override func viewDidLoad() &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">         </div><div class="line">        let reader = DataReader()</div><div class="line">        reader.delegate = <span class="keyword">self</span></div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    func DataWillRead() &#123;...&#125;</div><div class="line">     </div><div class="line">    func DataDidRead() &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="目标—动作模式-TARGET-ACTION-PATTERN"><a href="#目标—动作模式-TARGET-ACTION-PATTERN" class="headerlink" title="目标—动作模式(TARGET ACTION PATTERN)"></a>目标—动作模式(TARGET ACTION PATTERN)</h2><p>另一个我们在Swift中仍然在用的模式就是<strong>目标-动作模式(target-action)</strong>，并且这次甚至是以在Objective-C中一模一样的方式来使用它。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> ViewController: <span class="built_in">UIViewController</span> &#123;</div><div class="line">     </div><div class="line">    @IBOutlet var button:<span class="built_in">UIButton</span></div><div class="line">     </div><div class="line">    override func viewDidLoad() &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">         </div><div class="line">        button.addTarget(<span class="keyword">self</span>, action: <span class="string">"buttonPressed:"</span>, forControlEvents: <span class="built_in">UIControlEvents</span>.TouchUpInside)</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    func buttonPressed(sender:<span class="built_in">UIButton</span>)&#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有一个真正不同的地方，就是定义<strong>selector</strong>的方式。我们只需将方法原型写成一个字符串，它就可以自动被转换成类似下面这样的东西：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">Selector(<span class="string">"buttonPressed:"</span>)</div></pre></td></tr></table></figure>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>爱或不爱，单例模式仍然是被使用的最多的模式。</p>
<p>我们可以用GCD的dispatch_once来实现它，或者可以直接依靠天生线程安全的<strong>let</strong>关键词来实现。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> DataReader: <span class="built_in">NSObject</span> &#123;</div><div class="line">     </div><div class="line">    <span class="keyword">class</span> var sharedReader:DataReader &#123;</div><div class="line">         </div><div class="line">        <span class="keyword">struct</span> Static&#123;</div><div class="line">            <span class="keyword">static</span> let _instance = DataReader()</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        <span class="keyword">return</span> Static._instance</div><div class="line">    &#125;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>让我们快速浏览一下这段代码。</p>
<ol>
<li>sharedReader是一个静态的复合（compound）属性（我们也可以用一个函数来代替这个实现）。</li>
<li><p>静态（非复合）属性现在还不允许出现在类实现中。因此要感谢<strong>内嵌类型</strong>，我们在类里面添加了一个内嵌的结构体。</p>
<p>结构体支持静态属性，所以我们只需把静态属性加在那儿就可以了。</p>
</li>
<li><p>_instance属性是一个常量。它不能被修改为其他值，并且是线程安全的。</p>
</li>
</ol>
<p>我们可以像下面这样引用DataReader的单例实例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">DataReader.sharedReader</div></pre></td></tr></table></figure>
<h2 id="结构体和枚举"><a href="#结构体和枚举" class="headerlink" title="结构体和枚举"></a>结构体和枚举</h2><p>Swift中，结构体和枚举有许多你很难在其他语言中能够找到的特性。</p>
<p>它们支持方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> User&#123;</div><div class="line">    <span class="comment">// Struct properties</span></div><div class="line">    let name:String</div><div class="line">    let ID:Int</div><div class="line">     </div><div class="line">    <span class="comment">// Method!!!</span></div><div class="line">    func sayHello()&#123;</div><div class="line">        println(<span class="string">"I'm "</span> + <span class="keyword">self</span>.name + <span class="string">" my ID is: \(self.ID)"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">let pamela = User(name: <span class="string">"Pamela"</span>, ID: <span class="number">123456</span>)</div><div class="line">pamela.sayHello()</div></pre></td></tr></table></figure>
<p>你可以看到，这个结构体使用了一个由Swift自动创建的初始化方法（我们也可以添加其他自定义的实现）。</p>
<p>枚举的语法和我们以前使用的语法有点不同。</p>
<p>它使用关键词<strong>case</strong>来定义枚举值：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">enum</span> Fruit &#123; </div><div class="line">  <span class="keyword">case</span> orange</div><div class="line">  <span class="keyword">case</span> apple</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>枚举也不仅限于整型值：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">enum</span> Fruit:String &#123; </div><div class="line">  <span class="keyword">case</span> .orange = <span class="string">"Orange"</span></div><div class="line">  <span class="keyword">case</span> .apple = <span class="string">"Apple"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以构造行为更复杂的枚举类型：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">enum</span> Fruit&#123;</div><div class="line">     </div><div class="line">    <span class="comment">// Available Fruits</span></div><div class="line">    <span class="keyword">case</span> orange</div><div class="line">    <span class="keyword">case</span> apple</div><div class="line">     </div><div class="line">    <span class="comment">// Nested type</span></div><div class="line">    <span class="keyword">struct</span> Vitamin&#123;</div><div class="line">        var name:String</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="comment">// Compound property</span></div><div class="line">    var mainVitamin:Vitamin &#123;</div><div class="line">     </div><div class="line">    <span class="keyword">switch</span> <span class="keyword">self</span>&#123;</div><div class="line">    <span class="keyword">case</span> .orange:</div><div class="line">        <span class="keyword">return</span> Vitamin(name: <span class="string">"C"</span>)</div><div class="line">         </div><div class="line">    <span class="keyword">case</span> .apple:</div><div class="line">        <span class="keyword">return</span> Vitamin(name: <span class="string">"B"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"> </div><div class="line">let Apple = Fruit.apple</div><div class="line">var Vitamin = Apple.mainVitamin</div></pre></td></tr></table></figure>
<p>在前面的代码中，我们添加了一个内嵌类型（Vitamin）和一个复合类型（mainVitamin）。这两个类型都依靠枚举值来初始化元素值。令人兴奋，对吧？</p>
<h2 id="可变和不可变"><a href="#可变和不可变" class="headerlink" title="可变和不可变"></a>可变和不可变</h2><p>在Objective-C中，我们习惯了像NSArray和NSDictionary这类的有可变和不可变版本的类。</p>
<p>在Swift中，我们不再需要不同的数据类型，只需利用常量或变量定义即可。</p>
<p>变量数组是可以被修改的。但常量数组，我们就无法修改其存储的值。因此，只要记住“let = 不可变， var = 可变”这个规则就好（但注意：在Swift的Beta 3之前，你是可以修改一个let数组的）。</p>
<h2 id="Block和Closure"><a href="#Block和Closure" class="headerlink" title="Block和Closure"></a>Block和Closure</h2><font color="orange">译注：由于个人偏好问题，没有将“Block”翻译成“块代码”，“Closure”翻译成“闭包”，这两个词都保留了原文，需要的请自行脑补它们的翻译。 </font>

<p>我爱死Block的语法了，它们真是太清晰、太好记了！</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;/好了，反话模式结束&gt;</div></pre></td></tr></table></figure>
<p>但，顺便还是要说一句：用Cocoa做开发这么多年后，我们已经非常习惯于使用这个语法。有的时候，我甚至更喜欢用它来代替代理模式来完成一些简单的任务。它们灵巧、使用方便，完全是有用的。</p>
<p>Swift中，类似于Block的东西是Closure。Closure极其强大，并且苹果也做了大量的工作来简化我们编写它们的方式。</p>
<p>Swift官方文档上的例子让我惊呆了。</p>
<p>文档上，是以这样的一个定义开始的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">reversed = sort(names, &#123; (s1: String, s2: String) -&gt; Bool <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> s1 &gt; s2</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>然后它被重构成了这样：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">reversed = sort(names, &gt;)</div></pre></td></tr></table></figure>
<p>因此，感谢类型推断，我们有不同的方式来实现一个Closure，可以使用速记参数列表(shorthand arguments)（$0, %1）和直接用运算符函数(operator functions)（&gt;）。</p>
<p>这篇文章中，我不打算过多的讨论Closure的语法，但是我想花些时间谈谈Closure是如何捕获(capture)值的。</p>
<p>在Objective-C中，如果我们想在block中修改一个变量的值，我们需要将它定义成<strong>__block</strong>。但是使用Closure，就用不着这样了。</p>
<p>我们可以随意访问和修改周围作用域中的任意一个值。Closure已经足够聪明，能够自己捕获要使用的外部元素。一个元素可以被以一个“<strong>副本</strong>”或一个“<strong>引用</strong>”的方式捕获。如果Closure要修改元素的值，它就会创建一个引用；如果不修改，它就创建一个副本。</p>
<p>我们来看看下面这个例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Person&#123;</div><div class="line">     </div><div class="line">    var age:Int = <span class="number">0</span></div><div class="line">     </div><div class="line">    @lazy var agePotion: (Int) -&gt; Void = &#123;</div><div class="line">        (agex:Int)-&gt;Void <span class="keyword">in</span></div><div class="line">            <span class="keyword">self</span>.age += agex</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    func modifyAge(agex:Int, modifier:(Int)-&gt;Void)&#123;</div><div class="line">        modifier(agex)</div><div class="line">    &#125;   </div><div class="line">&#125;</div><div class="line"> </div><div class="line">var Mark:Person? = Person()</div><div class="line">Mark!.modifyAge(<span class="number">50</span>, Mark!.agePotion)</div><div class="line">Mark = <span class="literal">nil</span> <span class="comment">// Memory Leak</span></div></pre></td></tr></table></figure>
<p>agePotion这个closure使用了self，持有了一个指向当前实例的强引用。与此同时，那个实例又持有了一个指向这个closure的引用…BOOM…产生强引用循环了！</p>
<p>为了避免这种问题，我们要使用捕获列表（<strong>Capture List</strong>）。这个列表关联了一个指向我们要在closure中使用的实例的弱引用或无主（unowned）引用。其对应的语法也相当简单，只需在closure的定义前面加上<strong>[unowned/strong self]</strong>，然后就可以得到一个无主引用或弱引用。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">@lazy var agePotion: (Int) -&gt; Void = &#123;</div><div class="line">     [unowned <span class="keyword">self</span>](agex:Int)-&gt;Void <span class="keyword">in</span></div><div class="line">         <span class="keyword">self</span>.age += agex</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="无主引用和弱引用"><a href="#无主引用和弱引用" class="headerlink" title="无主引用和弱引用"></a>无主引用和弱引用</h2><p>我们已经知道弱引用是如何在Objective-C中工作的。它在Swift中的工作方式也一样，没有什么不同的。</p>
<p>那么，无主引用呢？我真的很感激引入了这个关键词，因为它可以对类与类之间的关系起到一个很好的暗示作用。</p>
<p>我们来表述一下一个人与他的银行账户之间的简单关系：</p>
<ol>
<li>一个人可以有一个银行账户（可选的）</li>
<li>一个银行账户应该属于某一个人（必需的）</li>
</ol>
<p>我们可以用如下的代码来描述这种关系：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">We can describe <span class="keyword">this</span> relation with code: </div><div class="line"><span class="keyword">class</span> Person&#123;</div><div class="line">    let name:String</div><div class="line">    let account:BankAccount!</div><div class="line">     </div><div class="line">    init(name:String)&#123;</div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">        <span class="keyword">self</span>.account = BankAccount(owner: <span class="keyword">self</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">class</span> BankAccount&#123;</div><div class="line">    let owner:Person</div><div class="line">     </div><div class="line">    init(owner:Person)&#123;</div><div class="line">        <span class="keyword">self</span>.owner = owner</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些关系将会产生一个引用循环。第一种解决方法是，在“BankAccount.owner”属性上加一个弱引用。然而，如果使用<strong>无主</strong>引用，我们可以定义另一种有用的约束条件：属性必须有一个值，它不能为nil（这种方式下，前面列出的2个条件我们都满足了）。</p>
<p>关于无主引用实在没有什么可以多说的。它和弱引用一样，不会增加它指向的对象的引用计数，但是保证了它引用的不是一个空值（nil）。</p>
<h2 id="最后的思考"><a href="#最后的思考" class="headerlink" title="最后的思考"></a>最后的思考</h2><p>我不得不承认：我有时还是会遇到编译错误，并最终沉默地看着它们，心想：“WAT?”</p>
<p>越用得多，它就变得越清晰。它值得上我花的每一个小时来实验和学习它。它带来了许多不同于Objective-C的有趣的变化和一些以前不存在的东西。这些都让我想多实践一下，去适应它。</p>
<p>它是iOS和OSX开发中的一股值得欢迎的新鲜空气，我肯定你们也会喜欢它的！</p>
<p>Ciao</p>
<p><a href="https://twitter.com/bitwaker" target="_blank" rel="external">Follow @bitwaker</a></p>
<p>译自：<a href="http://www.thinkandbuild.it/from-objective-c-to-swift/" target="_blank" rel="external">FROM OBJECTIVE-C TO SWIFT: THOUGHTS AND HINTS</a></p>
<p style="text-align:center"><img src="/images/posts/thx_money.png" width="50%" height="50%"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文分享一些在由Objective-C转换至Swift的过程中产生的思考，并尝试总结了一些技巧建议和一些误区陷阱。本文尽量通过对比来展示这两种语言在同一个问题上的不同处理方法。开始吧！&lt;/p&gt;
&lt;h2 id=&quot;单文件-vs-接口-实现文件&quot;&gt;&lt;a href=&quot;#单文件-vs-接口-实现文件&quot; class=&quot;headerlink&quot; title=&quot;单文件 vs. 接口-实现文件&quot;&gt;&lt;/a&gt;单文件 vs. 接口-实现文件&lt;/h2&gt;&lt;p&gt;第一个重大的变化是：&lt;code&gt;interface.h/implementation.m&lt;/code&gt;的文件结构被舍弃了。&lt;/p&gt;
&lt;p&gt;我是这种文件结构的坚定支持者。只通过接口文件来获取或共享类相关的信息，不仅安全而且很方便。&lt;/p&gt;
&lt;p&gt;在Swift中，接口和实现并没有分离。我们只能实现自己的类（并且在写代码的时候甚至不能添加可见性修饰符）。&lt;br&gt;
    
    </summary>
    
      <category term="Objc" scheme="http://blog.morefun.mobi/categories/Objc/"/>
    
      <category term="Swift" scheme="http://blog.morefun.mobi/categories/Objc/Swift/"/>
    
      <category term="编程思想" scheme="http://blog.morefun.mobi/categories/Objc/Swift/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS的Model-View-ViewModel模式</title>
    <link href="http://blog.morefun.mobi/2014/05/17/2014-05-17-yi-model-view-viewmodel-for-ios/"/>
    <id>http://blog.morefun.mobi/2014/05/17/2014-05-17-yi-model-view-viewmodel-for-ios/</id>
    <published>2014-05-17T05:21:00.000Z</published>
    <updated>2017-08-13T08:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你已经做过一段时间的iOS开发，那么你一定听说过模型—视图—控制器或MVC模式。这是构建iOS应用的标准方式。不过最近，我越来越厌倦MVC的缺点。本文，我们先重温一下MVC是什么，它有什么缺点。然后再介绍一种构建应用的新方式：Model-View-ViewModel。</p>
<h2 id="Model-View-Controller"><a href="#Model-View-Controller" class="headerlink" title="Model-View-Controller"></a>Model-View-Controller</h2><p>模型-视图-控制器模式(Model-View-Controller)是构造代码的权威范式。苹果甚至<a href="https://developer.apple.com/library/ios/documentation/general/conceptual/devpedia-cocoacore/MVC.html" target="_blank" rel="external">这么说</a>。MVC模式，所有对象都被界定为，要么是一个模型，要么是一个视图，或者要么是一个控制器。模型持有数据，视图向用户呈现一个可交互的界面，视图控制器做模型和视图之间的中介者。</p>
<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/mvc1.png" alt=""></p>
<p>这个图表中，视图将用户交互通知给控制器。然后视图控制器根据这个状态的变化来更新模型。然后该模型通知(通常是通过KVO的方式)相关的控制器更新它们的视图。iOS应用大部分代码都采用这种机制。<br><a id="more"></a></p>
<p>模型对象通常是非常简单的对象。很多时候，都是Core Data的<a href="https://developer.apple.com/library/ios/documentation/DataManagement/Devpedia-CoreData/managedObject.html#//apple_ref/doc/uid/TP40010398-CH23-SW1" target="_blank" rel="external">managed object对象</a>。当然，如果你不喜欢用Core Data，也可以用其他流行的<a href="https://github.com/MantleFramework/Mantle" target="_blank" rel="external">模型层</a>对象。根据苹果的说法，模型对象包含了数据和对数据的操作。但实际应用中，模型对象通常非常轻量，对数据的操作都被混合进了控制器中。</p>
<p>视图（<a href="http://blog.gaborcselle.com/2012/11/letterpress-deconstructed.html" target="_blank" rel="external">典型的</a>）是UIKit组件或者程序员定义的UIKit组件的组合。就是那些在你的xib和Storyboard里面的控件：应用程序中可视和可交互的组件，像按钮、文字标签那些。视图不应该直接引用模型，并且只应该通过IBAction事件引用控制器。不属于视图的业务逻辑不应该存在于视图中。</p>
<p>剩下就是控制器了。控制器中放满了应用中的“胶水代码(glue code)”：那些调解模型和视图之间的交互的所有代码。控制器负责管理它们所拥有的视图的视图层级。它们要负责视图的加载、显示和隐藏等逻辑。我们还倾向于将那些不适合放在模型里面的或不适合放在视图里面的业务逻辑都装进控制器里面。这样就会面对使用MVC时的第一个问题。</p>
<h2 id="臃肿的视图控制器"><a href="#臃肿的视图控制器" class="headerlink" title="臃肿的视图控制器"></a>臃肿的视图控制器</h2><p>由于视图控制器里面放了太多的代码，它们常常变得特别的臃肿。视图控制器有上千行代码也不是闻所未闻的事情。这就使得你的应用无法保持轻量：臃肿的视图控制器难以维护（因为其庞大的规模），包含太多属性也让它们的状态难以控制，太多的协议代码和控制器的逻辑也搅合在一起。</p>
<p>臃肿的视图控制器还造成不管是通过手动测试还是单元测试都难以测试，因为它们拥有太多可能的状态。将代码拆解成更小的区块是非常好的主意。这又让我联想到最近的一个<a href="http://mikehadlow.blogspot.co.uk/2013/12/are-your-programmers-working-hard-or.html" target="_blank" rel="external">故事</a>。</p>
<h2 id="迷失的网络逻辑"><a href="#迷失的网络逻辑" class="headerlink" title="迷失的网络逻辑"></a>迷失的网络逻辑</h2><p>MVC（苹果推荐的那个MVC）的定义被描述为：所有的对象都可以被划分为模型、视图或控制器。那么，负责网络通信的代码放在哪里呢？使用这些接口的代码又放在什么地方呢？</p>
<p>你可以试着聪明地将它放进模型对象里面，不过那样会变得非常令人费解。因为网络请求应该是异步的，所以一个网络请求如果比拥有它的模型对象存活的更久，那么，真的太复杂了。你肯定也不应该将网络通信的代码放到视图里面，所以就只剩下控制器了。但这同样也不是个好主意，因为它只会将视图控制器变得更臃肿。</p>
<p>那么，到底放什么地方呢? MVC完全没有任何一个地方可以放那些不适合放在这三个地方的代码。</p>
<h2 id="糟糕的可测试性"><a href="#糟糕的可测试性" class="headerlink" title="糟糕的可测试性"></a>糟糕的可测试性</h2><p>MVC的另一个大问题是，它使得开发人员很难编写单元测试的代码。由于视图控制器中混合了视图管理逻辑的代码和业务逻辑的代码，要将这些部分拆分出来做单元测试变成了一项艰巨的任务。最后只能演变为不测试……</p>
<h2 id="模糊的“管理”定义"><a href="#模糊的“管理”定义" class="headerlink" title="模糊的“管理”定义"></a>模糊的“管理”定义</h2><p>前面提到过，视图控制器管理了视图的层次体系；他有一个”view”属性，并且通过IBOutlet的方式可以访问这个视图的任何一个子视图。当有了很多outlet后就不好扩展，并且某些时候，你可能会用子视图控制器（child view controller）来帮助管理子视图。</p>
<p>这究竟会引向何方呢？什么时候将这些拆分开来会变得更有利？验证用户输入的业务逻辑是属于控制器呢，还是属于模型？</p>
<p>这里有许多模糊的界定，没有人能对其达成一致的意见。好像无论你怎么画这些线条，视图和对应的控制器都会如此紧密地耦合在一起，那你还不如把它们当作一个组成部分。</p>
<p>嘿嘿！说到这儿，就有了一个想法……</p>
<h2 id="Model-View-ViewModel"><a href="#Model-View-ViewModel" class="headerlink" title="Model-View-ViewModel"></a>Model-View-ViewModel</h2><p>在理想的世界中，MVC可能工作的很不错。然而，我们生活在现实世界中，而事实也并非如此。我们已经详细介绍了MVC典型用法中的不足之处，让我们来看看另一种模式：模型-视图-视图模型(Model-View-ViewModel)。</p>
<p>MVVM<a href="http://msdn.microsoft.com/en-us/library/hh848246.aspx" target="_blank" rel="external">来自微软</a>， 但是不要因此就反对它。MVVM和MVC非常相似。它正式承认了视图和控制器的紧耦合性质，然后引入了一个新组件。</p>
<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/mvvm1.png" alt=""></p>
<p>MVVM模式下，视图和视图控制器正式的连接在一起，我们把它们当作同一个组件。视图仍然不拥有对模型的引用，所以控制器同样也不引用模型。相反，它们都引用视图模型。</p>
<p>视图模型是验证用户输入、处理视图展示逻辑、发起网络请求以及放置其他杂项代码的一个好地方。视图模型不引用任何视图。它里面的逻辑如果适用于OS X，那么同样也应该适用于iOS（换句话说，不在视图模型里面#import UIKit.h就不会错）。</p>
<p>由于展示逻辑被划归到视图模型中，视图控制器本身就变得非常非常轻量级。最棒的是，当你刚刚开始使用MVVM的时候，你可以只在你的视图模型里面放少量的逻辑，到你对这个模式更加熟悉后再对它们进行迁移。</p>
<p>使用MVVM编写的iOS应用具有高度的可测试性。因为视图模型包含了所有的展示逻辑并且不引用视图，所以完全可以编程测试它。尽管<a href="http://programming.oreilly.com/2013/05/upward-mobility-unit-testing-core-data.html" target="_blank" rel="external">众多</a>的<a href="http://www.cimgf.com/2012/05/15/unit-testing-with-core-data/" target="_blank" rel="external">黑客</a>都<a href="http://stackoverflow.com/questions/1876568/ocmock-with-core-data-dynamic-properties-problem" target="_blank" rel="external">参与到</a>了Core Data模型的测试中，但用MVVM编写的应用程序完全可以用单元测试。</p>
<p>以我的经验，使用MVVM会略微增加一些代码量，但代码的复杂度会有整体性的降低。是非常有价值的折衷结果。</p>
<p>如果你再看看MVVM那个示意图，你会发现我使用了模糊的形容词——“通知(notify)”和”更新(update)”，但是并没有指出要怎么做。你可以用KVO，像在MVC里面一样，但是这很快就会变得难以控制。实践中，使用<a href="http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/" target="_blank" rel="external">ReactiveCocoa</a>将各个分散的区块粘合在一起是一个很好的方式。</p>
<p>关于如何联合使用MVVM和ReactiveCocoa，请阅读Colin Wheeler的这篇<a href="http://cocoasamurai.blogspot.ca/2013/03/basic-mvvm-with-reactivecocoa.html" target="_blank" rel="external">优秀文章</a>，或查看我写的一个<a href="https://github.com/AshFurrow/C-41" target="_blank" rel="external">开源应用</a>。也可以阅读我写的关于ReactiveCocoa和MVVM的<a href="https://leanpub.com/iosfrp" target="_blank" rel="external">书</a>。</p>
<p>译自：<a href="http://www.teehanlax.com/blog/model-view-viewmodel-for-ios/" target="_blank" rel="external">Model-View-ViewModel for iOS</a></p>
<p style="text-align:center"><img src="/images/posts/thx_money.png" width="50%" height="50%"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你已经做过一段时间的iOS开发，那么你一定听说过模型—视图—控制器或MVC模式。这是构建iOS应用的标准方式。不过最近，我越来越厌倦MVC的缺点。本文，我们先重温一下MVC是什么，它有什么缺点。然后再介绍一种构建应用的新方式：Model-View-ViewModel。&lt;/p&gt;
&lt;h2 id=&quot;Model-View-Controller&quot;&gt;&lt;a href=&quot;#Model-View-Controller&quot; class=&quot;headerlink&quot; title=&quot;Model-View-Controller&quot;&gt;&lt;/a&gt;Model-View-Controller&lt;/h2&gt;&lt;p&gt;模型-视图-控制器模式(Model-View-Controller)是构造代码的权威范式。苹果甚至&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/general/conceptual/devpedia-cocoacore/MVC.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这么说&lt;/a&gt;。MVC模式，所有对象都被界定为，要么是一个模型，要么是一个视图，或者要么是一个控制器。模型持有数据，视图向用户呈现一个可交互的界面，视图控制器做模型和视图之间的中介者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/mvc1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个图表中，视图将用户交互通知给控制器。然后视图控制器根据这个状态的变化来更新模型。然后该模型通知(通常是通过KVO的方式)相关的控制器更新它们的视图。iOS应用大部分代码都采用这种机制。&lt;br&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://blog.morefun.mobi/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="设计模式" scheme="http://blog.morefun.mobi/categories/%E7%BF%BB%E8%AF%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="架构" scheme="http://blog.morefun.mobi/categories/%E7%BF%BB%E8%AF%91/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>使用NSSecureCoding协议进行编解码</title>
    <link href="http://blog.morefun.mobi/2014/04/15/2014-04-15-shi-yong-nssecurecodingxie-yi-jin-xing-bian-jie-ma/"/>
    <id>http://blog.morefun.mobi/2014/04/15/2014-04-15-shi-yong-nssecurecodingxie-yi-jin-xing-bian-jie-ma/</id>
    <published>2014-04-15T06:08:00.000Z</published>
    <updated>2017-08-13T08:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS和Mac OS上，<code>NSCoding</code>是一种简单方便的数据存储方法。它可以直接将你的数据模型对象写入一个文件，之后又可以直接将它们读入内存而不需要编写任何文件解析和序列化的逻辑。将一个对象（假设它已经实现了NSCoding协议）保存至一个文件，只需要这样做：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">Foo *someFoo = [[Foo alloc] init];</div><div class="line">[<span class="built_in">NSKeyedArchiver</span> archiveRootObject:someFoo toFile:someFile];</div></pre></td></tr></table></figure>
<p>之后要加载时，只需要这样：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">Foo *someFoo = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:someFile];</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>那些编译到应用里面的资源采用这种方式挺好（比如nib文件，它其实就是用的NSCoding方式），但是使用NSCoding读写用户数据文件的问题在于，由于你是将整个类编码进一个文件，因此在你的应用中就隐式的赋予了该文件实例化类对象的权限。</p>
<p>虽然你不能在一个被NSCoding的文件中存储可执行代码（至少在iOS上不行），但黑客可能会用一个特制的文件欺骗你的应用，来实例化一个你意想不到的类对象，或者在一个你想象不到的环境下实例化类对象。虽然这样做很难带来任何真正的伤害，但这肯定会导致应用崩溃或用户数据丢失。</p>
<p>iOS6中，苹果引入了一个基于NSCoding的新协议，叫做<code>NSSecureCoding</code>。NSSecureCoding和NSCoding几乎完全相同，除了解码的时候你需要指定要解码的对象的key和类，并且如果指定的类和从文件解码到的对象的类不匹配的时候，NSCoder会抛出一个异常来告诉你该数据已经被篡改。</p>
<p>大多数支持NSCoding的系统对象都已经升级到支持NSSecureCoding，所以给你的NSKeyedUnarchiver设置要求使用安全编码(secure coding)功能，就可以确保你加载到的数据文件是安全的。如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Set up NSKeyedUnarchiver to use secure coding</span></div><div class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:someFile];</div><div class="line"><span class="built_in">NSKeyedUnarchiver</span> *unarchiver = [[<span class="built_in">NSKeyedUnarchiver</span> alloc] initForReadingWithData:data];</div><div class="line">[unarchiver setRequiresSecureCoding:<span class="literal">YES</span>];</div><div class="line"> </div><div class="line"><span class="comment">// Decode object</span></div><div class="line">Foo *someFoo = [unarchiver decodeObjectForKey:<span class="built_in">NSKeyedArchiveRootObjectKey</span>];</div></pre></td></tr></table></figure>
<p>注意，如果使用NSKeyedUnarchiver的安全编码功能，那么存储在这个文件中的所有对象都必须遵循NSSecureCoding协议，否则你会得到一个异常。要让你的类支持NSSecureCoding协议，需要在<code>initWithCoder:</code>方法里面实现新的解码逻辑，并且要让<code>supportsSecureCoding</code>方法返回YES。<code>encodeWithCoder:</code>方法不需要修改，因为安全问题在读取过程中才可能出现，不会出现在保存的过程中。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">NSObject</span> </span></div><div class="line"> </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSNumber</span> *property1;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *property2;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *property3;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Foo</span></span></div><div class="line"> </div><div class="line">+ (<span class="built_in">BOOL</span>)supportsSecureCoding</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)coder</div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init]))</div><div class="line">  &#123;</div><div class="line">    <span class="comment">// Decode the property values by key, specifying the expected class</span></div><div class="line">    _property1 = [coder decodeObjectOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>] forKey:<span class="string">@"property1"</span>];</div><div class="line">    _property2 = [coder decodeObjectOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>] forKey:<span class="string">@"property2"</span>];</div><div class="line">    _property3 = [coder decodeObjectOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>] forKey:<span class="string">@"property3"</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)coder</div><div class="line">&#123;</div><div class="line">  <span class="comment">// Encode our ivars using string keys as normal</span></div><div class="line">  [coder encodeObject:_property1 forKey:<span class="string">@"property1"</span>];</div><div class="line">  [coder encodeObject:_property2 forKey:<span class="string">@"property2"</span>];</div><div class="line">  [coder encodeObject:_property3 forKey:<span class="string">@"property3"</span>];</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>几周前，我写了「<a href="http://iosdevelopertips.com/cocoa/nscoding-without-boilerplate.html" target="_blank" rel="external">如何在运行时通过内省(introspection)来检测类的属性，以实现自动NSCoding</a>」。</p>
<p>这是一个非常棒的方法，它能一下子让你的所有的模型对象都支持NSCoding，而无需重复的编写initWithCoder:和encodeWithCoder:方法，从而也减少了出错的几率。但是我们使用的这个方法不支持NSSecureCoding，因为我们无法对正在加载的对象进行类型验证。</p>
<p>那么，如何增强我们的自动NSCoding系统以支持NSSecureCoding呢？</p>
<p>如果你还记得，原有的实现是使用了<code>class_copyPropertyList()</code>和<code>property_getName()</code>这两个运行时函数来生成了一组属性名字，然后我们将它们存入了一个数组：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//引入Objective-C运行时的头文件</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span> </span></div><div class="line"> </div><div class="line">- (<span class="built_in">NSArray</span> *)propertyNames</div><div class="line">&#123;    </div><div class="line">  <span class="comment">//获得属性列表</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> propertyCount;</div><div class="line">  objc_property_t *properties = class_copyPropertyList([<span class="keyword">self</span> <span class="keyword">class</span>], </div><div class="line">    &amp;propertyCount);</div><div class="line">  <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:propertyCount];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyCount; i++)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">//获得属性名字</span></div><div class="line">    objc_property_t property = properties[i];</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(property);</div><div class="line">    <span class="built_in">NSString</span> *key = @(propertyName);</div><div class="line"> </div><div class="line">    <span class="comment">//加入数组中</span></div><div class="line">    [array addObject:key];</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">//记得释放属性列表，因为ARC不会替我们释放它</span></div><div class="line">  free(properties);</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过使用KVC,我们就能够通过名字来设置和获取一个对象的所有属性，并在一个NSCoder对象中将它们编码或解码。</p>
<p>实现自动NSSecureCoding时，我们也遵循相同的原则。但，除了获取属性的名字之外，我们还需要获取到其对应的类型。幸运的是，Objective-C的运行时存储了类属性的类型信息，所以获取名字的同时，获取类型数据也很容易。</p>
<p>类的属性可以是基本数据类型（如整型、布尔型和结构体），也可以是对象（如NSString、NSArray等等）。KVC的<code>valueForKey:</code>方法和<code>setValue:forKey:</code>方法实现了对基本数据类型的自动化“装箱（boxing）”操作。就是说，它们会将整型、布尔型和结构体这些基本数据类型转换成NSNumber或NSValue对象。这样，对我们来说就简单多了，因为我们只需要处理装箱后的对象就可以了。因此我们就能够将我们所有的属性类型按照类来处理，而不必为了不同的属性类型调用不同的解码方法。</p>
<p>虽然，运行时不会把每个属性装箱后对应的类名给我们，但它会给我们对应的类型编码信息——一个包含了类型信息的特殊格式的C字符串（与<code>@encode(var);</code>语法返回的字符串格式相同）。由于没有能够自动获取基本数据类型的等价类的方法，所以我们需要解析这个字符串，然后自己指定相应的类。</p>
<p>苹果官方描述类型编码字符串格式的文档在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="external">这里</a>。</p>
<p>第一个字符就代表了对应的基本数据类型。Objective-C为每个支持的基本类型都定义了一个唯一的字符，比如‘i’表示一个整数，‘f’表示浮点数，‘d’表示double，等等。对象被表示为‘@’(后接类名)，还有另外一些生僻的类型，如‘:’表示selector，或‘#’表示类。</p>
<p>花括弧{…}包含起来的表达式代表struct和union类型。仅有一部分struct和union类型被KVC支持。KVC支持的这部分类型会被装箱成NSValue对象，因此我们可以将任何以‘{’开头的值都做同样的处理。</p>
<p>使用switch，基于字符串的第一个字符，我们就能够处理所有的已知类型：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">Class propertyClass = <span class="literal">nil</span>;</div><div class="line"><span class="keyword">char</span> *typeEncoding = property_copyAttributeValue(property, <span class="string">"T"</span>);</div><div class="line"><span class="keyword">switch</span> (typeEncoding[<span class="number">0</span>])</div><div class="line">&#123;</div><div class="line">  <span class="keyword">case</span> <span class="string">'c'</span>: <span class="comment">// Numeric types</span></div><div class="line">  <span class="keyword">case</span> <span class="string">'i'</span>:</div><div class="line">  <span class="keyword">case</span> <span class="string">'s'</span>:</div><div class="line">  <span class="keyword">case</span> <span class="string">'l'</span>:</div><div class="line">  <span class="keyword">case</span> <span class="string">'q'</span>:</div><div class="line">  <span class="keyword">case</span> <span class="string">'C'</span>:</div><div class="line">  <span class="keyword">case</span> <span class="string">'I'</span>:</div><div class="line">  <span class="keyword">case</span> <span class="string">'S'</span>:</div><div class="line">  <span class="keyword">case</span> <span class="string">'L'</span>:</div><div class="line">  <span class="keyword">case</span> <span class="string">'Q'</span>:</div><div class="line">  <span class="keyword">case</span> <span class="string">'f'</span>:</div><div class="line">  <span class="keyword">case</span> <span class="string">'d'</span>:</div><div class="line">  <span class="keyword">case</span> <span class="string">'B'</span>:</div><div class="line">  &#123;</div><div class="line">    propertyClass = [<span class="built_in">NSNumber</span> <span class="keyword">class</span>];</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">case</span> <span class="string">'*'</span>: <span class="comment">// C-String</span></div><div class="line">  &#123;</div><div class="line">    propertyClass = [<span class="built_in">NSString</span> <span class="keyword">class</span>];</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">case</span> <span class="string">'@'</span>: <span class="comment">// Object</span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">//<span class="doctag">TODO:</span> get class name</span></div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">case</span> <span class="string">'&#123;'</span>: <span class="comment">// Struct</span></div><div class="line">  &#123;</div><div class="line">    propertyClass = [<span class="built_in">NSValue</span> <span class="keyword">class</span>];</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">case</span> <span class="string">'['</span>: <span class="comment">// C-Array</span></div><div class="line">  <span class="keyword">case</span> <span class="string">'('</span>: <span class="comment">// Enum</span></div><div class="line">  <span class="keyword">case</span> <span class="string">'#'</span>: <span class="comment">// Class</span></div><div class="line">  <span class="keyword">case</span> <span class="string">':'</span>: <span class="comment">// Selector</span></div><div class="line">  <span class="keyword">case</span> <span class="string">'^'</span>: <span class="comment">// Pointer</span></div><div class="line">  <span class="keyword">case</span> <span class="string">'b'</span>: <span class="comment">// Bitfield</span></div><div class="line">  <span class="keyword">case</span> <span class="string">'?'</span>: <span class="comment">// Unknown type</span></div><div class="line">  <span class="keyword">default</span>:</div><div class="line">  &#123;</div><div class="line">    propertyClass = <span class="literal">nil</span>; <span class="comment">// Not supported by KVC</span></div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">free(typeEncoding);</div></pre></td></tr></table></figure>
<p>要处理‘@’类型，我们还需要获得类名。类名可能包含了协议名，因此我们要把字符串进行分割，只提取出类名，然后使用NSClassFromString函数来获得对应的类：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">'@'</span>:</div><div class="line">&#123;</div><div class="line">  <span class="comment">//类的objcType只少3个字符长度</span></div><div class="line">  <span class="keyword">if</span> (strlen(typeEncoding) &gt;= <span class="number">3</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">//拷贝得到C字符串形式的类名</span></div><div class="line">    <span class="keyword">char</span> *cName = strndup(typeEncoding + <span class="number">2</span>, strlen(typeEncoding) - <span class="number">3</span>);</div><div class="line"> </div><div class="line">    <span class="comment">//转换为一个NSString，以便后续操作的处理</span></div><div class="line">    <span class="built_in">NSString</span> *name = @(cName);</div><div class="line"> </div><div class="line">    <span class="comment">//剔除类名后面的协议名字</span></div><div class="line">    <span class="built_in">NSRange</span> range = [name rangeOfString:<span class="string">@"&lt;"</span>];</div><div class="line">    <span class="keyword">if</span> (range.location != <span class="built_in">NSNotFound</span>)</div><div class="line">    &#123;</div><div class="line">      name = [name substringToIndex:range.location];</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">//根据类名获取对应的类，如果没有对应的类则默认为NSObject</span></div><div class="line">    propertyClass = <span class="built_in">NSClassFromString</span>(name) ?: [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</div><div class="line">    free(cName);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，我们可以将这种解析逻辑与前面的实现中的propertyNames方法的逻辑组合起来，以属性名字作为key，创建一个返回包含属性对应类的字典的方法。下面是完整的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">NSDictionary</span> *)propertyClassesByName</div><div class="line">&#123;</div><div class="line">  <span class="comment">// Check for a cached value (we use _cmd as the cache key, </span></div><div class="line">  <span class="comment">// which represents @selector(propertyNames))</span></div><div class="line">  <span class="built_in">NSMutableDictionary</span> *dictionary = objc_getAssociatedObject([<span class="keyword">self</span> <span class="keyword">class</span>], _cmd);</div><div class="line">  <span class="keyword">if</span> (dictionary)</div><div class="line">  &#123;</div><div class="line">      <span class="keyword">return</span> dictionary;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// Loop through our superclasses until we hit NSObject</span></div><div class="line">  dictionary = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">  Class subclass = [<span class="keyword">self</span> <span class="keyword">class</span>];</div><div class="line">  <span class="keyword">while</span> (subclass != [<span class="built_in">NSObject</span> <span class="keyword">class</span>])</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> propertyCount;</div><div class="line">    objc_property_t *properties = class_copyPropertyList(subclass, </div><div class="line">      &amp;propertyCount);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyCount; i++)</div><div class="line">    &#123;</div><div class="line">      <span class="comment">// Get property name</span></div><div class="line">      objc_property_t property = properties[i];</div><div class="line">      <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(property);</div><div class="line">      <span class="built_in">NSString</span> *key = @(propertyName);</div><div class="line"> </div><div class="line">      <span class="comment">// Check if there is a backing ivar</span></div><div class="line">      <span class="keyword">char</span> *ivar = property_copyAttributeValue(property, <span class="string">"V"</span>);</div><div class="line">      <span class="keyword">if</span> (ivar)</div><div class="line">      &#123;</div><div class="line">        <span class="comment">// Check if ivar has KVC-compliant name</span></div><div class="line">        <span class="built_in">NSString</span> *ivarName = @(ivar);</div><div class="line">        <span class="keyword">if</span> ([ivarName isEqualToString:key] || </div><div class="line">          [ivarName isEqualToString:[<span class="string">@"_"</span> stringByAppendingString:key]])</div><div class="line">        &#123;</div><div class="line">          <span class="comment">// Get type</span></div><div class="line">          Class propertyClass = <span class="literal">nil</span>;</div><div class="line">          <span class="keyword">char</span> *typeEncoding = property_copyAttributeValue(property, <span class="string">"T"</span>);</div><div class="line">          <span class="keyword">switch</span> (typeEncoding[<span class="number">0</span>])</div><div class="line">          &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">'c'</span>: <span class="comment">// Numeric types</span></div><div class="line">            <span class="keyword">case</span> <span class="string">'i'</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">'s'</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">'l'</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">'q'</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">'C'</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">'S'</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">'L'</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">'Q'</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">'f'</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">'d'</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">'B'</span>:</div><div class="line">            &#123;</div><div class="line">              propertyClass = [<span class="built_in">NSNumber</span> <span class="keyword">class</span>];</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">case</span> <span class="string">'*'</span>: <span class="comment">// C-String</span></div><div class="line">            &#123;</div><div class="line">              propertyClass = [<span class="built_in">NSString</span> <span class="keyword">class</span>];</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">case</span> <span class="string">'@'</span>: <span class="comment">// Object</span></div><div class="line">            &#123;</div><div class="line">              <span class="comment">//<span class="doctag">TODO:</span> get class name</span></div><div class="line">              <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">case</span> <span class="string">'&#123;'</span>: <span class="comment">// Struct</span></div><div class="line">            &#123;</div><div class="line">              propertyClass = [<span class="built_in">NSValue</span> <span class="keyword">class</span>];</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">case</span> <span class="string">'['</span>: <span class="comment">// C-Array</span></div><div class="line">            <span class="keyword">case</span> <span class="string">'('</span>: <span class="comment">// Enum</span></div><div class="line">            <span class="keyword">case</span> <span class="string">'#'</span>: <span class="comment">// Class</span></div><div class="line">            <span class="keyword">case</span> <span class="string">':'</span>: <span class="comment">// Selector</span></div><div class="line">            <span class="keyword">case</span> <span class="string">'^'</span>: <span class="comment">// Pointer</span></div><div class="line">            <span class="keyword">case</span> <span class="string">'b'</span>: <span class="comment">// Bitfield</span></div><div class="line">            <span class="keyword">case</span> <span class="string">'?'</span>: <span class="comment">// Unknown type</span></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">            &#123;</div><div class="line">              propertyClass = <span class="literal">nil</span>; <span class="comment">// Not supported by KVC</span></div><div class="line">              <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">          free(typeEncoding);</div><div class="line"> </div><div class="line">          <span class="comment">// If known type, add to dictionary</span></div><div class="line">          <span class="keyword">if</span> (propertyClass) dictionary[propertyName] = propertyClass;</div><div class="line">        &#125;</div><div class="line">        free(ivar);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    free(properties);</div><div class="line">    subclass = [subclass superclass];</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// Cache and return dictionary</span></div><div class="line">  objc_setAssociatedObject([<span class="keyword">self</span> <span class="keyword">class</span>], _cmd, dictionary, </div><div class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">  <span class="keyword">return</span> dictionary;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最困难的部分已经完成。现在，要实现NSSecureCoding，我们只需要修改前面实现自动化逻辑的代码中的initWithCoder:方法，接收属性对应类以进行解析操作。同样，我们还需要让supportsSecureCoding方法返回YES：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)supportsSecureCoding</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)coder</div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init]))</div><div class="line">  &#123;</div><div class="line">    <span class="comment">// Decode the property values by key, specifying the expected class</span></div><div class="line">    [[<span class="keyword">self</span> propertyClassesByName] enumerateKeysAndObjectsUsingBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSString</span> *key, Class propertyClass, <span class="built_in">BOOL</span> *stop)) &#123;</div><div class="line">      <span class="keyword">id</span> object = [aDecoder decodeObjectOfClass:propertyClass forKey:key];</div><div class="line">      <span class="keyword">if</span> (object) [<span class="keyword">self</span> setValue:object forKey:key];</div><div class="line">    &#125;];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder</div><div class="line">&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> [<span class="keyword">self</span> propertyClassesByName])</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">id</span> object = [<span class="keyword">self</span> valueForKey:key];</div><div class="line">    <span class="keyword">if</span> (object) [aCoder encodeObject:object forKey:key];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好了，现在你的模型类已经拥有了一个可以打开即用的支持NSSecureCoding的简单基类。另外，你也可以直接使用我写的一个叫<code>AutoCoding</code>的分类，它正是使用了上述方法来为任何一个没有实现NSCoding和NSSecureCoding协议的对象加入自动NSCoding和NSSecureCoding能力。</p>
<p>译自：<a href="http://iosdevelopertips.com/general/object-encoding-and-decoding-with-nssecurecoding.html" target="_blank" rel="external">Object Encoding and Decoding with NSSecureCoding Protocol</a></p>
<p>原文作者为<a href="https://twitter.com/nicklockwood" target="_blank" rel="external">Nick Lockwood</a>，他是<a href="http://www.informit.com/store/ios-core-animation-advanced-techniques-9780133440751" target="_blank" rel="external">《iOS Core Animation: Advanced Techniques》</a>一书的作者，也是iCarousel、iRate等开源项目的作者。</p>
<p style="text-align:center"><img src="/images/posts/thx_money.png" width="50%" height="50%"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS和Mac OS上，&lt;code&gt;NSCoding&lt;/code&gt;是一种简单方便的数据存储方法。它可以直接将你的数据模型对象写入一个文件，之后又可以直接将它们读入内存而不需要编写任何文件解析和序列化的逻辑。将一个对象（假设它已经实现了NSCoding协议）保存至一个文件，只需要这样做：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Foo *someFoo = [[Foo alloc] init];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;built_in&quot;&gt;NSKeyedArchiver&lt;/span&gt; archiveRootObject:someFoo toFile:someFile];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后要加载时，只需要这样：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Foo *someFoo = [&lt;span class=&quot;built_in&quot;&gt;NSKeyedUnarchiver&lt;/span&gt; unarchiveObjectWithFile:someFile];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://blog.morefun.mobi/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="NSCoding" scheme="http://blog.morefun.mobi/categories/%E7%BF%BB%E8%AF%91/NSCoding/"/>
    
      <category term="runtime" scheme="http://blog.morefun.mobi/categories/%E7%BF%BB%E8%AF%91/NSCoding/runtime/"/>
    
    
  </entry>
  
  <entry>
    <title>7种常见的代码问题</title>
    <link href="http://blog.morefun.mobi/2014/03/21/2014-03-21-yi-7chong-chang-jian-de-dai-ma-wen-ti/"/>
    <id>http://blog.morefun.mobi/2014/03/21/2014-03-21-yi-7chong-chang-jian-de-dai-ma-wen-ti/</id>
    <published>2014-03-21T01:20:00.000Z</published>
    <updated>2017-08-13T08:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>我进行过很多代码审查，其中有7种最常见的代码问题。</p>
<h2 id="被注释掉的代码"><a href="#被注释掉的代码" class="headerlink" title="被注释掉的代码"></a>被注释掉的代码</h2><p>这让我觉得你没有学会如何使用版本控制工具和标记功能。如果这些旧代码已经不再有用了，我干嘛还需要读它！？</p>
<p>如果它很重要，将来你可能会需要返回来查看它。那么你可以在版本控制工具中给它添加一个适当的标记，然后把它从当前代码中移除掉。<br><a id="more"></a></p>
<h2 id="无用的注释"><a href="#无用的注释" class="headerlink" title="无用的注释"></a>无用的注释</h2><p>那些没有任何价值的注释，那些明摆着是显而易见的注释，或者对部分代码做的注释，都应该放进方法里面。</p>
<p><strong>记住：</strong> 注释很快就会过时的，并且人们不会维护它。</p>
<h2 id="空方法"><a href="#空方法" class="headerlink" title="空方法"></a>空方法</h2><p>一个只调用super的方法被认为是一个空方法。把它移除掉。</p>
<h2 id="文件太长"><a href="#文件太长" class="headerlink" title="文件太长"></a>文件太长</h2><p>一个代码超过400行的文件你如何读的下去？眼睛看着都难受啊，请用组合(composition)、分类(categories)或其他方式来组织你的代码。</p>
<p>每当我发现一个文件的代码行数过长，我的第一印象都会假定它破坏了单一职责原则(SRP，Single Responsibility Principle)，除非证明并非如此。</p>
<h2 id="不可变的对象属性用错了修饰符"><a href="#不可变的对象属性用错了修饰符" class="headerlink" title="不可变的对象属性用错了修饰符"></a>不可变的对象属性用错了修饰符</h2><p>如果你有一个不可变的对象属性，并且它有一个可变的副本，请用copy。否则，如果有人给你这个不可变的属性赋值了一个可变的副本，并且修改了这个副本，那么你最终不得不面对这种烦人的bug。</p>
<p><strong>记住：</strong> 如果你对像NSString这样的不可变的对象调用copy，实际上它只会retain它，不会有性能损失。</p>
<h2 id="不关心结果"><a href="#不关心结果" class="headerlink" title="不关心结果"></a>不关心结果</h2><p>如果你调用我的API但是不传递容差处理(errorHandler)相关的方法，我会让你付出沉重的代价(崩溃)。有些情况下我也会对完成结果的回调(completion results)做相同的处理。</p>
<p><strong>记住：</strong> 当你设计API的时候，如果不允许使用者在不关心结果的情况下调用某些消耗很大的方法，那么你的用户会很感激你给他们减少了电量消耗。</p>
<h2 id="没有断言或有效性验证"><a href="#没有断言或有效性验证" class="headerlink" title="没有断言或有效性验证"></a>没有断言或有效性验证</h2><p>为你的假设加上断言，用断言来强制执行API的正确使用方法或者以确保你的假设通过了实际的验证。如果不是，你可以很快的知道。</p>
<p>如果你还发现了其他常见的问题，欢迎给我发个<a href="http://twitter.com/merowing_" target="_blank" rel="external">推特</a>。</p>
<p>译自：<a href="http://www.merowing.info/2014/03/7-most-common-code-issues/#.UyuU_dy_7PA" target="_blank" rel="external">7种常见的代码问题</a></p>
<p style="text-align:center"><img src="/images/posts/thx_money.png" width="50%" height="50%"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我进行过很多代码审查，其中有7种最常见的代码问题。&lt;/p&gt;
&lt;h2 id=&quot;被注释掉的代码&quot;&gt;&lt;a href=&quot;#被注释掉的代码&quot; class=&quot;headerlink&quot; title=&quot;被注释掉的代码&quot;&gt;&lt;/a&gt;被注释掉的代码&lt;/h2&gt;&lt;p&gt;这让我觉得你没有学会如何使用版本控制工具和标记功能。如果这些旧代码已经不再有用了，我干嘛还需要读它！？&lt;/p&gt;
&lt;p&gt;如果它很重要，将来你可能会需要返回来查看它。那么你可以在版本控制工具中给它添加一个适当的标记，然后把它从当前代码中移除掉。&lt;br&gt;
    
    </summary>
    
      <category term="编程风格" scheme="http://blog.morefun.mobi/categories/%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/"/>
    
      <category term="翻译" scheme="http://blog.morefun.mobi/categories/%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Adopting Modern Objective-C</title>
    <link href="http://blog.morefun.mobi/2014/03/16/2014-03-16-yi-adopting-modern-objective-c/"/>
    <id>http://blog.morefun.mobi/2014/03/16/2014-03-16-yi-adopting-modern-objective-c/</id>
    <published>2014-03-16T03:46:00.000Z</published>
    <updated>2017-08-13T08:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>苹果2014年03月10日发布了一个新文档，介绍了Objective-C的几个新技巧，包括：</p>
<ul>
<li><a href="#instancetype">用instancetype代替id</a></li>
<li><a href="#property">用@property代替实例变量</a></li>
<li><a href="#enum">用NS_ENUM或NS_OPTIONS代替enum</a></li>
<li><a href="#arc">采用ARC</a></li>
</ul>
<p>文档名字叫《<a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/RevisionHistory.html#//apple_ref/doc/uid/TP40014150-CH99-SW1" target="_blank" rel="external">Adopting Modern Objective-C</a>》，将它翻译成中文了，以下是正文。<br><a id="more"></a></p>
<h1 id="Adopting-Modern-Objective-C"><a href="#Adopting-Modern-Objective-C" class="headerlink" title="Adopting Modern Objective-C"></a>Adopting Modern Objective-C</h1><p>历经多年，Objective-C语言已经得到了许多增长和演变。虽然核心概念和做法保持一致，但这个语言的部分已经发生显著的变化和改进。这些现代化的改进增强了Objective-C的类型安全、内存管理、性能和一些其他方面，使你可以更轻松地编写正确的代码。在你现有的和将来的代码中采用这些改进可以使你的代码变得更一致，可读性更强，更灵活。</p>
<p>XCode提供了一个工具来帮你完成这些结构上的更改。但是在你开始使用这个工具之前，你应该想了解一下它会给你的代码带来什么样的改变，以及为什么会带来这样的改变。本文档重点介绍了一些你可以在你的代码中应用的最显著的和最有用的新特性。</p>
<h2 id="instancetype"><a href="#instancetype" class="headerlink" title="instancetype"></a><span id="instancetype"><strong>instancetype</strong></span></h2><p>在返回类实例对象的方法中用<code>instancetype</code>关键词作为方法的返回值类型。这包括在<code>alloc</code>、<code>init</code>和类工厂方法等方法中。</p>
<p>在适当的地方用<code>instancetype</code>代替<code>id</code>，可以提高你的Objective-C代码的类型安全。例如，考虑下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)factoryMethodA;</div><div class="line">+ (<span class="keyword">id</span>)factoryMethodB;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)factoryMethodA &#123; <span class="keyword">return</span> [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init]; &#125;</div><div class="line">+ (<span class="keyword">id</span>)factoryMethodB &#123; <span class="keyword">return</span> [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init]; &#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> doSomething() &#123;</div><div class="line">    <span class="built_in">NSUInteger</span> x, y;</div><div class="line">    x = [[MyObject factoryMethodA] count]; <span class="comment">// Return type of +factoryMethodA is taken to be "MyObject *"</span></div><div class="line">    y = [[MyObject factoryMethodB] count]; <span class="comment">// Return type of +factoryMethodB is "id"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为<code>+factoryMethodA</code>的返回值类型为<code>instancetype</code>，该消息表达式的类型为<code>MyObject*</code>。由于MyObject没有<code>count</code>方法，编译器给出了一个关于x行的警告：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">main.m: ’MyObject’ may not respond to ‘count’</div></pre></td></tr></table></figure>
<p>然而，因为<code>+factoryMethodB</code>的返回值类型为<code>id</code>，编译器无法给出关于y行的警告。由于id类型的对象可以是任何类，并且由于一个叫<code>count</code>的方法可能存在于某个类的某个地方，对于编译器来说，它就认为<code>+factoryMethodB</code>方法返回的对象可能实现了该方法。</p>
<p>为了确保instancetype工厂方法有正确的子类化行为，在alloc类内存的时候一定要用<code>[self class]</code>，而不要直接引用类名。遵循这一约定可以确保编译器能够正确的推断出子类类型。例如，考虑MyObject子类的情形：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObjectSubclass</span> : <span class="title">MyObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> doSomethingElse() &#123;</div><div class="line">    <span class="built_in">NSString</span> *aString = [MyObjectSubclass factoryMethodA];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器给出以下警告：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">main.m: Incompatible pointer types initializing ’<span class="built_in">NSString</span> *’ with an expression of type ’MyObjectSubclass *’</div></pre></td></tr></table></figure>
<p>这个示例中，+factoryMethodA消息返回一个MyObjectSubclass类型的对象，这是消息接收者(receiver)类型的对象。编译器会相应地推断出+factoryMethodA的返回值类型应该是子类MyObjectSubclass，而不是定义了该工厂方法的父类。</p>
<h3 id="如何应用"><a href="#如何应用" class="headerlink" title="如何应用"></a>如何应用</h3><p>在你的代码中，在适当的地方用<code>instancetype</code>做返回值，替换掉<code>id</code>。通常是在<code>init</code>方法和类工厂方法的情形中。尽管编译器会自动将返回值类型为id的并且开头为”alloc”、”init”或”new”的方法的返回值类型转换成instancetype类型，但它不会去转换其他的方法。Objective-C的约定是，要为所有有需要的方法明确地写上instancetype。</p>
<p>要注意的是，只有在id作为返回值类型的地方才能用instancetype代替它，其他地方不行。与id不同的是，instancetype关键字只能在方法声明中被用作返回值类型。</p>
<p>例如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span></span></div><div class="line">- (<span class="keyword">id</span>)myFactoryMethod;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>应该变成：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span></span></div><div class="line">- (<span class="keyword">instancetype</span>)myFactoryMethod;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>或者，你也可以用Xcode中的modern Objective-C转换器来自动转换你的代码。欲了解更多信息，请参阅“<a href="#end">使用Xcode重构你的代码</a>”。</p>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a><span id="property"><strong>Properties</strong></span></h2><p>Objective-C的属性(property)是指用<code>@property</code>语法定义的公有的或私有的方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isBlue) <span class="built_in">BOOL</span> blue;</div></pre></td></tr></table></figure>
<p>属性保存了对象的状态。它们反映了对象的固有属性和对象与其他对象之间的关系。属性提供了一种安全的、便捷的方式来与这些属性进行交互，而无需编写一套自定义的访问(accessor)方法(虽然，如果有需要的话，属性确实允许自定义getter和setter方法)。</p>
<p>尽量在尽可能多的地方使用属性来代替实例变量，会有许多好处：</p>
<ul>
<li><p><strong>自动生成getter和setter方法。</strong> 当你定义了一个属性，默认会自动为你创建对应的getter和setter方法。</p>
</li>
<li><p><strong>更好的定义一组方法。</strong> 因为访问方法的命名约定，它会让getter和setter方法的用途更明确。</p>
</li>
<li><p><strong>属性关键词可以表达出对应行为的额外信息。</strong> 属性提供了<code>assign(相对于 copy)</code>、<code>weak</code>、<code>atomic(相对于 nonatomic)</code>等等特性。</p>
</li>
</ul>
<p>属性方法遵循一个简单的命名约定。getter方法的名字和属性名字相同(例如，date)，setter方法的名字是属性名字带一个”set”前缀并采用驼峰命名规则(例如，setDate)。布尔类型的属性还可以定义一个以”is”开头的getter方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isBlue) <span class="built_in">BOOL</span> blue;</div></pre></td></tr></table></figure>
<p>其结果是，以下都是有效的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (color.blue) &#123; &#125;</div><div class="line"><span class="keyword">if</span> (color.isBlue) &#123; &#125;</div><div class="line"><span class="keyword">if</span> ([color isBlue]) &#123; &#125;</div></pre></td></tr></table></figure>
<p>当决定哪些可以作为一个属性的时候，请记住，以下这些不属于属性：</p>
<ul>
<li><code>init</code>方法</li>
<li><code>copy</code>和<code>mutableCopy</code>方法</li>
<li>类工厂方法</li>
<li>开启某项操作并返回一个BOOL结果的方法</li>
<li>明确的改变了一个getter的内部状态的副作用方法。</li>
</ul>
<p>另外，在你的代码中标示属性特性的时候请考虑以下规则：</p>
<ul>
<li>一个可读写(read/write)的属性有两个访问方法。setter方法接受一个参数并且没有返回值，getter方法不接受任何参数并返回一个值。如果将这组方法转换成一个属性，就可以用<code>readwrite</code>关键字来标记它。</li>
<li>一个只读(read-only)的属性只有一个访问方法。即getter方法，它不接受任何参数，并且返回一个值。如果将这个方法转换成一个属性，就可以用<code>readonly</code>关键字标记它。</li>
<li>getter方法应当是幂等的(idempotent，如果一个getter方法被调用两次，那么第二次调用时返回的结果应该和第一调用时返回的结果相同)。然而，如果一个getter方法每次调用时，是被用于计算结果，这是可以接受的。</li>
</ul>
<h3 id="如何应用-1"><a href="#如何应用-1" class="headerlink" title="如何应用"></a>如何应用</h3><p>识别出一组可以被转换成一个属性的方法，如这些方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">NSColor</span> *)backgroundColor;</div><div class="line">- (<span class="keyword">void</span>)setBackgroundColor:(<span class="built_in">NSColor</span> *)color;</div></pre></td></tr></table></figure>
<p>用<code>@property</code>语法和适当的关键字将它们定义成一个属性：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>) <span class="built_in">NSColor</span> *backgroundColor;</div></pre></td></tr></table></figure>
<p>有关属性关键词和其他注意事项，请参阅《<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html" target="_blank" rel="external">Encapsulating Data</a>》。</p>
<p>或者，你也可以用Xcode中的modern Objective-C转换器来自动转换你的代码。欲了解更多信息，请参阅“<a href="#end">使用Xcode重构你的代码</a>”。</p>
<h2 id="枚举宏"><a href="#枚举宏" class="headerlink" title="枚举宏"></a><span id="enum"><strong>枚举宏</strong></span></h2><p><code>NS_ENUM</code>和<code>NS_OPTIONS</code>宏提供了一种在基于C的语言中定义枚举的简洁而又简单的方法。这两个宏增强了XCode中相关的代码补全功能，并且明确地指定了枚举和可选项(options)的类型和大小。此外，该语法定义的枚举既可以使得旧的编译器能够正确地计算枚举值，也可以使新的编译器能够解析出枚举值的类型信息。</p>
<p>使用<code>NS_ENUM</code>宏来定义枚举，即一组互斥的值：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UITableViewCellStyle</span>) &#123;</div><div class="line">    <span class="built_in">UITableViewCellStyleDefault</span>,</div><div class="line">    <span class="built_in">UITableViewCellStyleValue1</span>,</div><div class="line">    <span class="built_in">UITableViewCellStyleValue2</span>,</div><div class="line">    <span class="built_in">UITableViewCellStyleSubtitle</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>NS_ENUM</code>宏同时定义了枚举的名称和类型，这个示例中名称是UITableViewCellStyle，类型是NSInteger。枚举的类型应该尽量是NSInteger的。</p>
<p>使用<code>NS_OPTIONS</code>宏来定义可选项(options)，即一组可以相互结合的按位掩码(bitmasked)的值：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">UIViewAutoresizing</span>) &#123;</div><div class="line">    <span class="built_in">UIViewAutoresizingNone</span>                 = <span class="number">0</span>,</div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>   = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleWidth</span>        = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleRightMargin</span>  = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleTopMargin</span>    = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleHeight</span>       = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleBottomMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>像枚举一样，<code>NS_OPTIONS</code>宏也同时定义了名称和类型。但是，可选项的类型通常应该是NSUInteger的。</p>
<h3 id="如何应用-2"><a href="#如何应用-2" class="headerlink" title="如何应用"></a>如何应用</h3><p>更换你的枚举声明，比如这个：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    <span class="built_in">UITableViewCellStyleDefault</span>,</div><div class="line">	<span class="built_in">UITableViewCellStyleValue1</span>,</div><div class="line">	<span class="built_in">UITableViewCellStyleValue2</span>,</div><div class="line">	<span class="built_in">UITableViewCellStyleSubtitle</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NSInteger</span> <span class="built_in">UITableViewCellStyle</span>;</div></pre></td></tr></table></figure>
<p>更换成NS_ENUM语法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UITableViewCellStyle</span>) &#123;</div><div class="line">    <span class="built_in">UITableViewCellStyleDefault</span>,</div><div class="line">    <span class="built_in">UITableViewCellStyleValue1</span>,</div><div class="line">    <span class="built_in">UITableViewCellStyleValue2</span>,</div><div class="line">    <span class="built_in">UITableViewCellStyleSubtitle</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>但当你用enum来定义一个位掩码的时候，比如这里：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    <span class="built_in">UIViewAutoresizingNone</span>                  = <span class="number">0</span>,</div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>    = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleWidth</span>         = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleRightMargin</span>   = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleTopMargin</span>     = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleHeight</span>        = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleBottomMargin</span>  = <span class="number">1</span> &lt;&lt; <span class="number">5</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NSUInteger</span> <span class="built_in">UIViewAutoresizing</span>;</div></pre></td></tr></table></figure>
<p>要换成使用NS_OPTIONS宏：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">UIViewAutoresizing</span>) &#123;</div><div class="line">    <span class="built_in">UIViewAutoresizingNone</span>                 = <span class="number">0</span>,</div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>   = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleWidth</span>        = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleRightMargin</span>  = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleTopMargin</span>    = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleHeight</span>       = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    <span class="built_in">UIViewAutoresizingFlexibleBottomMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>或者，你也可以用Xcode中的modern Objective-C转换器来自动转换你的代码。欲了解更多信息，请参阅“<a href="#end">使用Xcode重构你的代码</a>”。</p>
<h2 id="自动引用计数-ARC"><a href="#自动引用计数-ARC" class="headerlink" title="自动引用计数(ARC)"></a><span id="arc"><strong>自动引用计数(ARC)</strong></span></h2><p>自动引用计数(Automatic Reference Counting)是一个编译器特性，它提供了Objective-C对象的自动内存管理功能。而你不必再需要记住什么时候使用<code>retain</code>、<code>release</code>和<code>autorelease</code>了，ARC会评估你的对象的生命周期，并在编译期自动帮你插入适当的内存管理调用。编译器也会为你生成相应的<code>dealloc</code>方法。</p>
<h3 id="如何应用-3"><a href="#如何应用-3" class="headerlink" title="如何应用"></a>如何应用</h3><p>XCode提供了一个工具，可以自动帮你完成ARC转换过程中的手动操作部分(比如移除对<code>retain</code>和<code>release</code>的调用)，也可以帮助你解决迁移工具不能自动处理的问题。要使用ARC迁移工具，在XCode菜单中选择“Edit &gt; Refactor &gt; Convert to Objective-C ARC”，迁移工具会将项目中的所有文件转换至使用ARC。</p>
<p>欲了解更多信息，请参阅《<a href="https://developer.apple.com/library/ios/releasenotes/objectivec/rn-transitioningtoarc/introduction/introduction.html" target="_blank" rel="external">Transitioning to ARC Release Notes</a>》。</p>
<h2 id="使用XCode重构你的代码"><a href="#使用XCode重构你的代码" class="headerlink" title="使用XCode重构你的代码"></a><span id="end"><strong>使用XCode重构你的代码</strong></span></h2><p>XCode提供了一个现代的Objective-C转换工具，可以协助你完成转换工作。虽然该转换工具可以在某些潜在的地方帮助你识别和应用这些现代的特性，但它不解释你代码的语义。例如，它不能检测出你的<code>-toggle</code>方法是一个可以影响你的对象的状态的方法，它会错误地提议将这个方法转换成一个更现代化的属性。请务必手动检查和确认转换工具给你的代码提供的任何修改。</p>
<p>综上所述的现代化的特性，这个转换工具可以提供以下这些转换功能：</p>
<ul>
<li>在适当的地方用instancetype替换id</li>
<li>将enum转换至NS_ENUM或NS_OPTIONS</li>
<li>将部分方法更新成@property语法</li>
</ul>
<p>除了这些，这个转换工具还会建议你对代码做一些其他的修改，包括：</p>
<ul>
<li>转换至字面值语法(literals)，因此像<code>[NSNumber numberWithInt:3]</code>这样的语句会变成<code>@3</code>。</li>
<li>使用下标语法，因此像<code>[dictionary setObject:@3 forKey:key]</code>这样的语句会变成<code>dictionary[key] = @3</code>。</li>
</ul>
<p>要使用这个现代的Objective-C转换工具，在Xcode菜单中选择“Edit &gt; Refactor &gt; Convert to Modern Objective-C Syntax”。</p>
<p style="text-align:center"><img src="/images/posts/thx_money.png" width="50%" height="50%"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;苹果2014年03月10日发布了一个新文档，介绍了Objective-C的几个新技巧，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#instancetype&quot;&gt;用instancetype代替id&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#property&quot;&gt;用@property代替实例变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#enum&quot;&gt;用NS_ENUM或NS_OPTIONS代替enum&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#arc&quot;&gt;采用ARC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文档名字叫《&lt;a href=&quot;https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/RevisionHistory.html#//apple_ref/doc/uid/TP40014150-CH99-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Adopting Modern Objective-C&lt;/a&gt;》，将它翻译成中文了，以下是正文。&lt;br&gt;
    
    </summary>
    
      <category term="Objc" scheme="http://blog.morefun.mobi/categories/Objc/"/>
    
      <category term="翻译" scheme="http://blog.morefun.mobi/categories/Objc/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>关于iOS和OS X废弃的API你需要知道的一切</title>
    <link href="http://blog.morefun.mobi/2014/02/11/2014-02-11-ni-xu-yao-zhi-dao-de-suo-you-guan-yu-ioshe-os-xyi-qi-yong-de-apide-shi-er/"/>
    <id>http://blog.morefun.mobi/2014/02/11/2014-02-11-ni-xu-yao-zhi-dao-de-suo-you-guan-yu-ioshe-os-xyi-qi-yong-de-apide-shi-er/</id>
    <published>2014-02-11T06:27:00.000Z</published>
    <updated>2017-08-13T08:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>已废弃(Deprecated)的API指的是那些已经过时并且在将来某个时间最终会被移除掉的方法或类。通常，苹果在引入一个更优秀的API后就会把原来的API给废弃掉。因为，新引入的API通常意味着可以更好的发挥新硬件或操作系统的性能，或者可以使用一些在构建原有API时根本还没有的语言特性(e.g. blocks)。</p>
<p>每当苹果添加新方法的时候，他们都会在方法声明的后面用一个很特殊的宏来标明哪些iOS版本支持它们。例如，在UIViewController中，苹果引入了一个使用block来处理回调的方法用来展示一个模态controller，它的声明是这样的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)presentViewController:(<span class="built_in">UIViewController</span> *)viewControllerToPresent animated: (<span class="built_in">BOOL</span>)flag completion:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completion <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div></pre></td></tr></table></figure>
<p>注意到<code>NS_AVAILABLE_IOS(5_0)</code>了吗？这就告诉我们这个方法可以在iOS5.0及以后的版本中使用。如果我们在比指定版本更老的版本中调用这个方法，就会引起崩溃。</p>
<a id="more"></a>
<p>那被这个方法替换了的那个旧方法又怎么样了呢？同样，它的声明后面也带了一个类似的语法，表示它已经被废弃了：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)presentModalViewController:(<span class="built_in">UIViewController</span> *)modalViewController animated:(<span class="built_in">BOOL</span>)animated <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0, <span class="number">6</span>_0);</div></pre></td></tr></table></figure>
<p><code>NS_DEPRECATED_IOS(2_0, 6_0)</code>这个宏中有两个版本号。前面一个表明了这个方法被引入时的iOS版本，后面一个表明它被废弃时的iOS版本。被废弃并不是指这个方法就不存在了，只是意味着我们应当开始考虑将相关代码迁移到新的API上去了。</p>
<p>还有类似形式的一些宏用在iOS和OS X共用的类上。比如NSArray中的这个方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)obj atIndexedSubscript:(<span class="built_in">NSUInteger</span>)idx <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_8, <span class="number">6</span>_0);</div></pre></td></tr></table></figure>
<p>这里的NS_AVAILABLE宏告诉我们这方法分别随Mac OS 10.8和iOS 6.0被引入。和NS_DEPRECATED_IOS类似，也有个宏叫NS_DEPRECATED，但它的参数要稍微复杂些：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObjectsFromIndices:(<span class="built_in">NSUInteger</span> *)indices numIndices:(<span class="built_in">NSUInteger</span>)cnt <span class="built_in">NS_DEPRECATED</span>(<span class="number">10</span>_0, <span class="number">10</span>_6, <span class="number">2</span>_0, <span class="number">4</span>_0);</div></pre></td></tr></table></figure>
<p>这里表示这个方法随Mac OS 10.0和iOS 2.0被引入，在Mac OS 10.6和iOS 4.0后被废弃。</p>
<h3 id="来的快，去的也快"><a href="#来的快，去的也快" class="headerlink" title="来的快，去的也快"></a>来的快，去的也快</h3><p>上周我们讨论了在iOS7和Mac OS 10.9 SDK中被新引入的Base64 API。有趣的是，有一组有相同功能的Base64方法，在被引入的同时也被废弃掉了。为什么苹果在引入一个API的同时又把它废弃掉了？那不是毫无意义的吗？好吧，其实也不是——它在下面这种情况下就非常有意义：</p>
<p>实际上，这些现在已经废弃的Base64方法从iOS4和Mac 0S 10.6开始就一直存在，只是它们是私有的。直到现在苹果才把它们公开，大概是苹果一直对它们的实现不满意，一直都想把它们改写。</p>
<p>果然，在iOS7中，苹果选定了一个他们感到满意的Base64 API，并且将它添加到了NSData的一个公有类别中。但现在，他们知道老方法已经被取代，不会被改写了，因此他们把它公开出来。当开发者的app仍然需要支持iOS6及以前的版本时，就有了一个系统内置的Base64 api可以用。</p>
<p>这就是为什么，如果你查看这些新API的方法声明，可以看到NS_DEPRECATED宏部分中的起始版本是4_0，虽然实际上直到iOS7之前，它从来都没有被作为公有API被引入过：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)base64Encoding <span class="built_in">NS_DEPRECATED</span>(<span class="number">10</span>_6, <span class="number">10</span>_9, <span class="number">4</span>_0, <span class="number">7</span>_0);</div></pre></td></tr></table></figure>
<p>这告诉你，基于iOS7 SDK开发的app如果调用了这个方法，它同样可以运行在iOS4+或Mac OS 10.6+的系统上而不会崩溃。很有用，对吧？</p>
<h3 id="如何使用已废弃的API"><a href="#如何使用已废弃的API" class="headerlink" title="如何使用已废弃的API"></a>如何使用已废弃的API</h3><p>那么，如果我们有一个app需要同时支持iOS6和iOS7，想用内置的Base64方法，我们该怎么做呢？事实上，这相当简单，你只需要调用这些废弃的API就可以了。</p>
<p>那样编译器不是会产生警告吗？不会——只有你的deployment target版本号设置成大于或等于方法被弃用的版本号的时候才会收到编译器警告。只要你仍然在支持那些还没有废弃这个方法的iOS版本，都不会收到警告。</p>
<p>那么，如果苹果决定在iOS8中移除已弃用的Base64方法，你的应用程序会发生情况？简单来说，它肯定会崩溃，但是不要让这把你吓跑了：苹果不可能只在几个iOS版本后就将已废弃的API给移除(绝大多数已废弃的API在任何的iOS版本中都还没有被移除)，除非你决定不再更新你的app，否则在你放弃支持iOS6之前有很多机会都可以更新到新的API。</p>
<p>但是如果假定我们在最坏的情况下(例如：我们不更新我们的app了，而苹果突然宣布了一个零容忍的不再向下兼容的政策)，怎样让我们的代码保持永不过时并且仍然能够支持旧的系统版本呢？</p>
<p>这其实很简单，我们只需要做一些运行时的方法检测。使用NSObject的<code>respondsToSelector:</code>方法，我们可以检测，如果新的API存在，我们就调用它。否则，我们退回到已废弃的API。很简单：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSData</span> *someData = ...</div><div class="line"><span class="built_in">NSString</span> *base64String = <span class="literal">nil</span>;</div><div class="line"> </div><div class="line"><span class="comment">// Check if new API is available</span></div><div class="line"><span class="keyword">if</span> ([someData respondsToSelector:<span class="keyword">@selector</span>(base64EncodedDataWithOptions:)])</div><div class="line">&#123;</div><div class="line">  <span class="comment">// It exists, so let's call it</span></div><div class="line">  base64String = [someData base64EncodedDataWithOptions:<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">  <span class="comment">// Use the old API</span></div><div class="line">  base64String = [someData base64Encoding];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此代码在iOS4及以上版本中有效，并且如果苹果在未来的iOS版本中移除base64Encoding方法后，同样可以正常工作。</p>
<h3 id="开发SDK的时候"><a href="#开发SDK的时候" class="headerlink" title="开发SDK的时候"></a>开发SDK的时候</h3><p>如果你是在写一个app，这一切都还好。但是如果你是在编写一个给其他人使用的库呢？如果project的target是iOS4或iOS6的时候，上面的代码会工作的很好。但是如果deployment target是iOS7+的时候，你就会收到编译警告，说你使用了已废弃的base64Encoding方法。</p>
<p>该代码实际上可以正常工作，因为那个方法在运行时永远都不会被调用(因为respondsToSelector:那个检查在iOS7上总是会返回YES)。可惜编译器还是不足够聪明，不能发现这点。而且，比如像我，不会想用那些会产生编译警告的第三方库，你肯定也不想自己的库中产生任何警告。 </p>
<p>那么，我们如何改写代码，以便它可以用于任何deployment target，而不会产生警告？幸好，有一个编译器宏指令可以基于不同的deployment target做不同的代码分支。取决于最终app的支持的最小iOS版本，我们可以用<code>__IPHONE_OS_VERSION_MIN_REQUIRED</code>这个宏来生成不同的代码。</p>
<p>下面的代码可以工作在任何的iOS版本上，而且不会产生任何警告：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#if __IPHONE_OS_VERSION_MIN_REQUIRED <span class="meta-string">&lt; __IPHONE_7_0</span></span></div><div class="line"> </div><div class="line">// Check if new API is not available</div><div class="line">if (![someData respondsToSelector:@selector(base64EncodedDataWithOptions:)])</div><div class="line">&#123;</div><div class="line">	// Use the old API</div><div class="line">	base64String = [someData base64Encoding];</div><div class="line">&#125;</div><div class="line">else</div><div class="line"> </div><div class="line">#endif</div><div class="line"> </div><div class="line">&#123;</div><div class="line">	// Use the new API</div><div class="line">	base64String = [someData base64EncodedDataWithOptions:0];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看清楚我们在这里做了什么吗？我们变换了respondsToSelector:的用法：我们用它来测试是否新的API不可用，然后将整段代码放到一个条件代码块中，这样它就只会在deployment target比iOS7低的情况下才会被编译。如果app是为iOS6编译的，它就会先检查新的API是否存在，如果不存在就调用旧的API。如果app是为iOS7编译的，那一整块逻辑代码都会被跳过，直接调用新的API。</p>
<h3 id="补充阅读"><a href="#补充阅读" class="headerlink" title="补充阅读"></a>补充阅读</h3><p>苹果有一个关于<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/cross_development/Using/using.html#//apple_ref/doc/uid/20002000-SW5" target="_blank" rel="external">废弃API用法的实例和相关的编译器警告</a>的简单文档，如果感兴趣可以看看。</p>
<p>原文: <a href="http://iosdevelopertips.com/best-practices/eveything-you-need-to-know-about-ios-and-os-x-deprecated-apis.html" target="_blank" rel="external">Everything You Need to Know about iOS and OS X Deprecated APIs</a></p>
<p style="text-align:center"><img src="/images/posts/thx_money.png" width="50%" height="50%"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已废弃(Deprecated)的API指的是那些已经过时并且在将来某个时间最终会被移除掉的方法或类。通常，苹果在引入一个更优秀的API后就会把原来的API给废弃掉。因为，新引入的API通常意味着可以更好的发挥新硬件或操作系统的性能，或者可以使用一些在构建原有API时根本还没有的语言特性(e.g. blocks)。&lt;/p&gt;
&lt;p&gt;每当苹果添加新方法的时候，他们都会在方法声明的后面用一个很特殊的宏来标明哪些iOS版本支持它们。例如，在UIViewController中，苹果引入了一个使用block来处理回调的方法用来展示一个模态controller，它的声明是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)presentViewController:(&lt;span class=&quot;built_in&quot;&gt;UIViewController&lt;/span&gt; *)viewControllerToPresent animated: (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)flag completion:(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (^)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;))completion &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;_0);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意到&lt;code&gt;NS_AVAILABLE_IOS(5_0)&lt;/code&gt;了吗？这就告诉我们这个方法可以在iOS5.0及以后的版本中使用。如果我们在比指定版本更老的版本中调用这个方法，就会引起崩溃。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.morefun.mobi/categories/iOS/"/>
    
      <category term="翻译" scheme="http://blog.morefun.mobi/categories/iOS/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>UIApplication​Delegate的launch​Options</title>
    <link href="http://blog.morefun.mobi/2014/01/08/2014-01-08-uiapplicationdelegate-launchoptions/"/>
    <id>http://blog.morefun.mobi/2014/01/08/2014-01-08-uiapplicationdelegate-launchoptions/</id>
    <published>2014-01-08T02:14:00.000Z</published>
    <updated>2017-06-17T15:13:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>AppDelegate就是iOS的垃圾场。</p>
<p>App的生命周期管理、URL处理、通知、CoreData、第三方SDK的初始化，还有那些看起来放到哪里都不合适的函数，统统都被塞到AppDelegate.m里面！</p>
<p>其中，<code>application:didFinishLaunchingWithOptions:</code>是最拥挤的一个。</p>
<p>对于许多开发者来说，launchOptions参数如同Java main函数的String[]参数一样，被忽视了。然而，摆在眼前的事实是，launchOptions包含了许多关键性知识，涉及了app在iOS上的众多启动方式。</p>
<p>这个周，我们就谈谈这个UIKit里面最重要的方法，揭秘一下这个知之甚少的launchOptions参数。</p>
<a id="more"></a>
<p>## </p>
<p>每个app都从UIApplicationDelegate的<code>application:didFinishLaunchingWithOptions:</code>方法开始启动(更精确点说，是<code>application:willFinishLaunchingWithOptions:</code>方法，如果你把它实现了的话)。应用程序通过调用这个方法来通知它的delegate：启动程序已经完成，差不多已经准备好运行了。</p>
<p>除了点击桌面上的应用图标可以启动程序外，还有其他几种场景可以使程序启动。例如，app如果注册了自定义的URL schemme，比如twitter://，就可以被open URL的方式调用开启程序。也可以通过推送通知或定位服务的方式调用开启程序。</p>
<p>launchOptions参数的所用就是用来判断一个app是如何被启动的。类似于userInfo字典，在<code>application:didFinishLaunchingWithOptions:</code>方法中，可以通过launchOptions参数来获取指定key的相关信息。</p>
<blockquote>
<p>其中的许多key同样使用于UIApplicationDidFinishLaunchingNotification通知。详细信息可以查阅相关文档。</p>
</blockquote>
<p>launchOptions包含了大量的key。根据app的启动方式，这些key大体可以被分为以下这几类：</p>
<h2 id="Open-URL"><a href="#Open-URL" class="headerlink" title="Open URL"></a><strong>Open URL</strong></h2><p>通过URL，程序可以调用启动其他程序：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"app://..."</span>]];</div></pre></td></tr></table></figure>
<p>例如，“http://” 的URL可以打开Safari，“mailto://” 的URL可以打开邮件程序，“tel://” 的URL可以拨打电话。</p>
<p>这些情形下，launchOptions里面会包含一个叫<code>UIApplicationLaunchOptionsURLKey</code>的Key。</p>
<blockquote>
<p>UIApplicationLaunchOptionsURLKey: 标示了该应用程序是为了打开一个URL启动。这个Key对应的值是一个NSURL对象，表示要打开的URL。</p>
</blockquote>
<p>app被URL启动的时候，还可以附带一些系统信息。当app是被UIDocumentInteractionController或AirDrop启动的时候，launchOptions里面还会附带下面这些key：</p>
<blockquote>
<p>UIApplicationLaunchOptionsSourceApplicationKey: 标示了要求启动你的程序的那个app。对应的值是一个NSString，表示那个app的bundle ID。</p>
<p>UIApplicationLaunchOptionsAnnotationKey: 标示了要求打开URL的那个app提供的自定义数据。对应的值是一个property-list类型的对象， 包含自定义的数据。 </p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *fileURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"Document"</span> withExtension:<span class="string">@"pdf"</span>];</div><div class="line"><span class="keyword">if</span> (fileURL) &#123;</div><div class="line">    <span class="built_in">UIDocumentInteractionController</span> *documentInteractionController = [<span class="built_in">UIDocumentInteractionController</span> interactionControllerWithURL:fileURL];</div><div class="line">    documentInteractionController.annotation = @&#123;<span class="string">@"foo"</span>: <span class="string">@"bar"</span>&#125;;</div><div class="line">    [documentInteractionController setDelegate:<span class="keyword">self</span>];</div><div class="line">    [documentInteractionController presentPreviewAnimated:<span class="literal">YES</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a><strong>通知</strong></h2><p>这里的通知不是指<a href="http://nshipster.com/nsnotification-and-nsnotificationcenter/" target="_blank" rel="external">NSNotification</a>，而是指推送通知和本地通知。</p>
<h4 id="推送通知"><a href="#推送通知" class="headerlink" title="推送通知"></a><strong>推送通知</strong></h4><p>自从iOS3引入推送通知以后，推送通知就成了移动平台最典型的功能之一。</p>
<p>要注册推送通知，在<code>application:didFinishLaunchingWithOptions:</code>里面调用<code>registerForRemoteNotificationTypes:</code>方法即可：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">[application registerForRemoteNotificationTypes:</div><div class="line">    <span class="built_in">UIRemoteNotificationTypeBadge</span> |</div><div class="line">    <span class="built_in">UIRemoteNotificationTypeSound</span> |</div><div class="line">    <span class="built_in">UIRemoteNotificationTypeAlert</span>];</div></pre></td></tr></table></figure>
<p>注册成功后，会收到<code>application:didRegisterForRemoteNotificationsWithDeviceToken:</code>这个回调。然后，就可以接收推送通知了。</p>
<p>接收到推送通知后，如果app当前处于前台运行状态，appDelgate的<code>application:didReceiveRemoteNotification:</code>方法会被调用。然而，当app是因为用户滑动通知中心的推送消息而启动时，<code>application:didFinishLaunchingWithOptions:</code>方法会被调用。这个时候，launchOption里面会包含名为<code>UIApplicationLaunchOptionsRemoteNotificationKey</code>的key：</p>
<blockquote>
<p>UIApplicationLaunchOptionsRemoteNotificationKey: 表明app有一个推送通知等待处理。这个key对应的值是一个包含了推送通知负载信息的NSDictionary，包括以下这些信息：</p>
<p><strong>alert</strong>：alert可以是一个字符串，表示提示信息；也可以是一个包含两个key(<strong>body</strong>和<strong>show-view</strong>)的字典。</p>
<p> <strong>badge</strong>：badge是一个数字，用于标示可从提供者下载的数据数量。这数字会被显示在app的图标上。如果推送通知中不包含badge这个字段，则app图标上标记的数字会被移除掉。</p>
<p> <strong>sound</strong>：指定app bundle里面用作提示音的声音文件的名字。如果为”default”，则会播放系统默认的提示音。</p>
</blockquote>
<p>这样看来，就有两个地方要写处理推送通知的代码。因此，一个通常的做法是在<code>application:didFinishLaunchingWithOptions:</code>里面手动调用<code>application:didReceiveRemoteNotification:</code>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application</div><div class="line">didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</div><div class="line">&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">if</span> (launchOptions[<span class="built_in">UIApplicationLaunchOptionsRemoteNotificationKey</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span> application:application didReceiveRemoteNotification:launchOptions[<span class="built_in">UIApplicationLaunchOptionsRemoteNotificationKey</span>]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="本地通知"><a href="#本地通知" class="headerlink" title="本地通知"></a><strong>本地通知</strong></h4><p><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/IPhoneOSClientImp.html#//apple_ref/doc/uid/TP40008194-CH103-SW1" target="_blank" rel="external">本地通知</a>从iOS4引入。令人惊奇的是，时至今日，仍然有很多人没有把它搞明白。</p>
<p>app可以定时触发一些<code>UILocalNotification</code>通知。通知触发时候，如果app正处于前台运行状态，appDelegate的<code>application:didReceiveLocalNotification:</code>方法会被调用。如果app处于非活动状态，通知就会被发布到通知中心。</p>
<p>与推送通知不同，UIApplication的delegate方法提供了一个统一的处理本地通知的地方。如果一个app是被本地通知启动的，会先调用<code>application:didReceiveLocalNotification:</code>方法，然后才会调用<code>application:didFinishLaunchingWithOptions:</code>(因此，就不需要在<code>application:didFinishLaunchingWithOptions:</code>里面手动调用<code>application:didReceiveLocalNotification</code>了)。</p>
<p>本地通知在launchOptions里面的key为<code>UIApplicationLaunchOptionsLocalNotificationKey</code>，对应的值为<code>UILocalNotification</code>对象(原文此处有误，本地通知和推送通知的结构不是相同的)。</p>
<blockquote>
<p>UIApplicationLaunchOptionsLocalNotificationKey: 如果这个key出现在launchOptions里面，则说明app有一个本地通知等待处理。对应的值是一个UILocalNotification对象，表示触发的本地通知。</p>
</blockquote>
<p>为了直观的展示，当app处于前台活动状态时应该如何显示一个本地通知的提示框。请看下面这个例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@import</span> <span class="built_in">AVFoundation</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SystemSoundID localNotificationSound;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application</div><div class="line">didReceiveLocalNotification:(<span class="built_in">UILocalNotification</span> *)notification</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (application.applicationState == <span class="built_in">UIApplicationStateActive</span>) &#123;</div><div class="line">        <span class="built_in">UIAlertView</span> *alertView =</div><div class="line">            [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:notification.alertAction</div><div class="line">                                       message:notification.alertBody</div><div class="line">                                      delegate:<span class="literal">nil</span></div><div class="line">                             cancelButtonTitle:<span class="built_in">NSLocalizedString</span>(<span class="string">@"OK"</span>, <span class="literal">nil</span>)</div><div class="line">                             otherButtonTitles:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.localNotificationSound) &#123;</div><div class="line">            <span class="built_in">NSURL</span> *soundURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"Sosumi"</span></div><div class="line">                                                      withExtension:<span class="string">@"wav"</span>];</div><div class="line">            AudioServicesCreateSystemSoundID((__bridge <span class="built_in">CFURLRef</span>)soundURL, &amp;_localNotificationSound);</div><div class="line">        &#125;</div><div class="line">        AudioServicesPlaySystemSound(<span class="keyword">self</span>.localNotificationSound);</div><div class="line"></div><div class="line">        [alertView show];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">UIApplication</span> *)application &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.localNotificationSound) &#123;</div><div class="line">        AudioServicesDisposeSystemSoundID(<span class="keyword">self</span>.localNotificationSound);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="定位事件"><a href="#定位事件" class="headerlink" title="定位事件"></a><strong>定位事件</strong></h2><p>想创造一个基于地理位置信息的本地社交图片签到软件？好吧，你已经晚了4年了。</p>
<p>但是不用怕！使用iOS的位置监测，你的app可以被定位事件启动：</p>
<blockquote>
<p>UIApplicationLaunchOptionsLocationKey: 表明app是为了响应定位事件才启动的。这个key对应的值是一个包含一个BOOL值的NSNumber对象。监测到这个key后，你应当创建CLLocationManager对象并再次启动定位服务。定位数据只会被投递给location manager的delegate，不会用这个key投递。</p>
</blockquote>
<p>下面这个例子，展示了当app收到一个显著的位置变化(significant location)事件而启动时的处理过程：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@import</span> CoreLocation;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> () &lt;<span class="title">CLLocationManagerDelegate</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CLLocationManager</span> *locationManager;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application</div><div class="line">didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</div><div class="line">&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (![<span class="built_in">CLLocationManager</span> locationServicesEnabled]) &#123;</div><div class="line">        [[[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="built_in">NSLocalizedString</span>(<span class="string">@"Location Services Disabled"</span>, <span class="literal">nil</span>)</div><div class="line">                                    message:<span class="built_in">NSLocalizedString</span>(<span class="string">@"You currently have all location services for this device disabled. If you proceed, you will be asked to confirm whether location services should be reenabled."</span>, <span class="literal">nil</span>)</div><div class="line">                                   delegate:<span class="literal">nil</span></div><div class="line">                          cancelButtonTitle:<span class="built_in">NSLocalizedString</span>(<span class="string">@"OK"</span>, <span class="literal">nil</span>)</div><div class="line">                          otherButtonTitles:<span class="literal">nil</span>] show];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">self</span>.locationManager = [[<span class="built_in">CLLocationManager</span> alloc] init];</div><div class="line">        <span class="keyword">self</span>.locationManager.delegate = <span class="keyword">self</span>;</div><div class="line">        [<span class="keyword">self</span>.locationManager startMonitoringSignificantLocationChanges];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (launchOptions[<span class="built_in">UIApplicationLaunchOptionsLocationKey</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span>.locationManager startUpdatingLocation];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Newsstand"><a href="#Newsstand" class="headerlink" title="Newsstand"></a><strong>Newsstand</strong></h2><p>所有Newsstand开发者，欢呼吧。</p>
<p>好吧好吧。</p>
<p>Newsstand可以在有新的下载资源时被启动。</p>
<p>你可以像这样注册：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">[application registerForRemoteNotificationTypes:</div><div class="line">    <span class="built_in">UIRemoteNotificationTypeNewsstandContentAvailability</span>];</div></pre></td></tr></table></figure>
<p>接下来就是launchOptions里面的关键部分：</p>
<blockquote>
<p>UIApplicationLaunchOptionsNewsstandDownloadsKey: 表明有新的Newsstand资源可供你的app下载。这个key对应的值是一组字符串标示符，它们标示了可供下载的资源对应的NKAssetDownload对象。虽然，这些标示符可以用作重复核对的用途，但是，你应当通过NKLibrary对象(表示Newsstand app的资源库)的downloadingAssets属性来明确的获取NKAssetDownload对象数组(它们表示了正在下载或者有错误的资源)。</p>
</blockquote>
<p>除此之外，就没有什么需要多说的了。</p>
<h2 id="Bluetooth"><a href="#Bluetooth" class="headerlink" title="Bluetooth"></a><strong>Bluetooth</strong></h2><p>iOS7引入了一个新功能，允许app被蓝牙外围设备重新启动。</p>
<p>如果app用特定的标示符实例化了一个<a href="https://developer.apple.com/library/ios/documentation/CoreBluetooth/Reference/CBCentralManager_Class/translated_content/CBCentralManager.html" target="_blank" rel="external">CBCentralManager</a>或一个<a href="https://developer.apple.com/library/ios/documentation/CoreBluetooth/Reference/CBPeripheralManager_Class/Reference/CBPeripheralManager.html#//apple_ref/doc/uid/TP40013015" target="_blank" rel="external">CBPeripheralManager</a>对象，并且连接了其他蓝牙外围设备，app就可以被来自蓝牙系统的中央操作(certain actions)重新启动。取决于接到通知的是中央设备管理器还是外围设备管理器，launchOptions里面会包含下面这两个key中的其中一个：</p>
<blockquote>
<p>UIApplicationLaunchOptionsBluetoothCentralsKey: 表明app先前有一个或多个CBCentralManager对象，现在app被蓝牙系统重新启动以继续处理这些对象的相关操作。这个key对应的值是一个包含了一个或多个NSString对象的数组。 每个字符串代表了一个中央设备管理器对象的复位标示符。</p>
<p>UIApplicationLaunchOptionsBluetoothPeripheralsKey: 表明app先前有一个或多个CBPeripheralManager对象，现在app被蓝牙系统重新启动以继续处理这些对象的相关操作。这个key对应的值是一个包含了一个或多个NSString对象的数组。每个字符串代表了一个外围设备管理器对象的复位标示符。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@import</span> CoreBluetooth;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> () &lt;<span class="title">CBCentralManagerDelegate</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) CBCentralManager *centralManager;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">self</span>.centralManager = [[CBCentralManager alloc] initWithDelegate:<span class="keyword">self</span> queue:<span class="literal">nil</span> options:@&#123;CBCentralManagerOptionRestoreIdentifierKey:(launchOptions[<span class="built_in">UIApplicationLaunchOptionsBluetoothCentralsKey</span>] ?: [[<span class="built_in">NSUUID</span> UUID] UUIDString])&#125;];</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.centralManager.state == CBCentralManagerStatePoweredOn) &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">UID</span> = <span class="string">@"7C13BAA0-A5D4-4624-9397-15BF67161B1C"</span>; <span class="comment">// generated with `$ uuidgen`</span></div><div class="line">    <span class="built_in">NSArray</span> *services = @[[CBUUID UUIDWithString:<span class="built_in">UID</span>]];</div><div class="line">    <span class="built_in">NSDictionary</span> *scanOptions = @&#123;CBCentralManagerScanOptionAllowDuplicatesKey:@YES&#125;;</div><div class="line">    [<span class="keyword">self</span>.centralManager scanForPeripheralsWithServices:services options:scanOptions];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要记住这么多app启动的方法和手段可能会让人筋疲力尽。幸运的是，任何一个app可能只需要处理其中的一两种情况。</p>
<p>知道什么是可能的，通常是能让一个app从概念演变成实现的必要条件。因此记住所有这些选项吧，以备你脑海中浮现出来的下一个伟大想法。</p>
<p>译自: <a href="http://nshipster.com/launch-options/" target="_blank" rel="external">NSHipster: UIApplication​Delegate launch​Options</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AppDelegate就是iOS的垃圾场。&lt;/p&gt;
&lt;p&gt;App的生命周期管理、URL处理、通知、CoreData、第三方SDK的初始化，还有那些看起来放到哪里都不合适的函数，统统都被塞到AppDelegate.m里面！&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt;是最拥挤的一个。&lt;/p&gt;
&lt;p&gt;对于许多开发者来说，launchOptions参数如同Java main函数的String[]参数一样，被忽视了。然而，摆在眼前的事实是，launchOptions包含了许多关键性知识，涉及了app在iOS上的众多启动方式。&lt;/p&gt;
&lt;p&gt;这个周，我们就谈谈这个UIKit里面最重要的方法，揭秘一下这个知之甚少的launchOptions参数。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.morefun.mobi/categories/iOS/"/>
    
      <category term="翻译" scheme="http://blog.morefun.mobi/categories/iOS/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Core Animation 3D介绍 第2部分</title>
    <link href="http://blog.morefun.mobi/2013/06/24/2013-06-24-core-animation-3djie-shao-di-2bu-fen/"/>
    <id>http://blog.morefun.mobi/2013/06/24/2013-06-24-core-animation-3djie-shao-di-2bu-fen/</id>
    <published>2013-06-24T04:58:00.000Z</published>
    <updated>2017-06-17T14:48:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2013/06/11/2013-06-11-core-animation-3djie-shao-di-1bu-fen/">上一篇</a>教程中，我们已经学习了Core Animation中3D绘图的基本方法。这篇教程，我们准备深入一些，讲讲如何创建一个可交互的3D场景。我们将会创建一个类似于旋转木马的3D场景界面，用户可以通过拖拽手势来旋转界面。</p>
<p>可能你已经在上一篇教程中见过最终APP的样子了，但是，让我们再来看一次吧：</p>
<p><img src="/images/posts/2013_06_11_core_animation_3d_app_preview.png" alt=""></p>
<p>你可以直接下载教程的<a href="https://github.com/ariok/TB_3DCoreAnimation" target="_blank" rel="external">源代码</a>。本篇教程的源代码和上一篇教程中的源代码在同一个代码仓库里面，但是我做了一些修改，为这篇教程建立了一个新的target。</p>
<a id="more"></a>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>这个程序，我们把工作分成了以下几个部分。</p>
<h4 id="3D"><a href="#3D" class="headerlink" title="3D"></a>3D</h4><p>因为我们需要3D效果，所以我们需要使用一个透视视图来进行绘制工作。为了构造旋转木马效果，我们将会建立一个3D层次体系。正如前一篇教程中介绍过的，用CATransformLayer来做层次体系中的根是不错的选择。</p>
<h4 id="平面"><a href="#平面" class="headerlink" title="平面"></a>平面</h4><p>旋转木马效果由一系列平面构成。我们将使用CAGradientLayer来表示这些平面。CAGradientLayer是CALayer的一个子类，用它可以制作渐变背景色，会比纯色背景要好看一些。</p>
<p>我们会对这些平面进行一些平移和旋转操作，使它们沿着旋转木马的圆周排列。</p>
<h4 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h4><p>获取用户的手势非常简单。我们只需要使用一个手势识别器(Gesture Recognizer)就可以了。然后，我们追踪用户的动作，将手势数据转换成角度值，用这个角度值来旋转界面。</p>
<p>好了，现在你应该已经知道这个项目有哪些东西要完成了吧？启动XCode吧！</p>
<h3 id="写代码吧"><a href="#写代码吧" class="headerlink" title="写代码吧"></a>写代码吧</h3><p>展开项目中的<strong>TB_3DPlanes</strong>文件夹，然后打开ViewController.m文件。</p>
<p>我们从viewDidLoad这个函数开始：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="comment">//Initialize the TransformLayer</span></div><div class="line">    transformLayer = [<span class="built_in">CATransformLayer</span> layer];</div><div class="line">    transformLayer.frame = <span class="keyword">self</span>.view.bounds;</div><div class="line">    [<span class="keyword">self</span>.view.layer addSublayer:transformLayer];</div><div class="line">    </div><div class="line">    angle = <span class="number">0</span>;</div><div class="line">    XPanOffset = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//Create 5 planes</span></div><div class="line">    [<span class="keyword">self</span> addPlane];</div><div class="line">    [<span class="keyword">self</span> addPlane];</div><div class="line">    [<span class="keyword">self</span> addPlane];</div><div class="line">    [<span class="keyword">self</span> addPlane];</div><div class="line">    [<span class="keyword">self</span> addPlane];</div><div class="line">    </div><div class="line">    <span class="comment">//Force the first animation to set the planes in place</span></div><div class="line">    [<span class="keyword">self</span> animate];</div><div class="line">    </div><div class="line">    <span class="comment">//Initialize the Pan gesture recognizer</span></div><div class="line">    <span class="built_in">UIPanGestureRecognizer</span> *panGesture = [[<span class="built_in">UIPanGestureRecognizer</span> alloc]initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pan:)];</div><div class="line">    [<span class="keyword">self</span>.view addGestureRecognizer:panGesture];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或许这个函数中有许多东西你还不完全明白是什么意思。但是，确实从这里开始就是核心部分的代码了。你可以暂时不用在这里纠结，继续阅读，后面会解释这些代码的意思的。<img src="http://www.thinkandbuild.it/wp-includes/images/smilies/icon_smile.gif" alt=""></p>
<p>很显然，我们先用<strong>CATransformLayer</strong>创建了一个根图层对象(<strong>transformLayer</strong>)，然后我们用<strong>addPlane</strong>函数向场景中添加了5个平面，并且我们将用<strong>pan:</strong>函数来处理拖拽手势。</p>
<h3 id="绘制平面"><a href="#绘制平面" class="headerlink" title="绘制平面"></a>绘制平面</h3><p>addPlane函数的代码也是相当直观的。它只是用<strong>CAGradientLayer</strong>和一些参数创建了一个图层罢了。然后将图层添加到了<strong>transformLayer</strong>上.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/** A simple function to create a CAGradientLayer **/</span></div><div class="line">- (<span class="keyword">void</span>)addPlane&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">CGSize</span> planeSize = <span class="built_in">CGSizeMake</span>(<span class="number">250</span>, <span class="number">150</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//Initialize the layer</span></div><div class="line">    <span class="built_in">CAGradientLayer</span> *layer = [<span class="built_in">CAGradientLayer</span> layer];</div><div class="line">    </div><div class="line">    <span class="comment">//Set the frame and the anchorPoint</span></div><div class="line">    layer.frame = <span class="built_in">CGRectMake</span>(<span class="number">480</span>/<span class="number">2</span> - planeSize.width/<span class="number">2</span>, <span class="number">320</span>/<span class="number">2</span> - planeSize.height/<span class="number">2</span> <span class="number">-20</span>, planeSize.width, planeSize.height);</div><div class="line">    layer.anchorPoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>, <span class="number">0.5</span>);</div><div class="line"></div><div class="line">    <span class="comment">//Set borders and cornerRadius</span></div><div class="line">    layer.borderColor = [[<span class="built_in">UIColor</span> colorWithWhite:<span class="number">1.0</span> alpha:<span class="number">0.3</span>]<span class="built_in">CGColor</span>];</div><div class="line">    layer.cornerRadius = <span class="number">10</span>;</div><div class="line">    layer.borderWidth = <span class="number">4</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//Set the gradient color for the plane background</span></div><div class="line">    layer.colors = [<span class="built_in">NSArray</span> arrayWithObjects:</div><div class="line">                    (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> purpleColor].CGColor,</div><div class="line">                    (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> redColor].CGColor,</div><div class="line">                    <span class="literal">nil</span>];</div><div class="line">    layer.locations = [<span class="built_in">NSArray</span> arrayWithObjects:</div><div class="line">                       [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">0.0</span>f],</div><div class="line">                       [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">1.0</span>f],</div><div class="line">                       <span class="literal">nil</span>];</div><div class="line">        </div><div class="line">    <span class="comment">//Set the shadow</span></div><div class="line">    layer.shadowColor = [[<span class="built_in">UIColor</span> blackColor]<span class="built_in">CGColor</span>];</div><div class="line">    layer.shadowOpacity = <span class="number">1</span>;</div><div class="line">    layer.shadowRadius = <span class="number">20</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//The double side has to be setted if we want to see the plane when its face is turned back</span></div><div class="line">    layer.doubleSided = <span class="literal">YES</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//Add the plane to the transformLayer</span></div><div class="line">    [transformLayer addSublayer:layer];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里唯一需要解释一下的是<strong>doubleSide</strong>属性。将它设置成YES，表示我们希望图层的背面也被绘制出来。当一个平面在Y轴上旋转接近180度的时候，我们仍然可以在场景中看到它，只是它旋转到了相反的方向。</p>
<p>为了更形象地说明这个问题，可以看看下图doubleSide为NO和YES时的对比。</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/04/double_side.png" alt=""></p>
<p>看了图，一下就明白了吧？设置成NO的时候，被旋转到背对着我们的那些平面都不会被绘制出来。</p>
<p>也许你已经注意到了，在viewDidLoad函数中我们添加了5个平面，但是这些平面并不是按位置排列在场景中的。在addPlane函数中，它们被添加到了同一个位置(参见frame属性)。</p>
<h3 id="更新平面位置"><a href="#更新平面位置" class="headerlink" title="更新平面位置"></a>更新平面位置</h3><p>在viewDidLoad函数里，平面被创建后，我们调用了<strong>animate</strong>方法。这个函数的主要作用是更新各个平面的位置。这里是我们第一次调用这个函数，这个时候并没有发生任何触摸事件，这里调用它只是为了让各个平面沿着旋转木马的圆周排列好。</p>
<p>我们来看看这个函数的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/** This function performs the transformation on each plane **/</span></div><div class="line">- (<span class="keyword">void</span>)animate&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//Define the degrees needed for each plane to create a circle</span></div><div class="line">    <span class="keyword">float</span> degForPlane = <span class="number">360</span> / [[transformLayer sublayers] count];</div><div class="line">    </div><div class="line">    <span class="comment">//The current angle offset (initially it is 0... it will change through the pan function)</span></div><div class="line">    <span class="keyword">float</span> degX = angle;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">CALayer</span> *layer <span class="keyword">in</span> [transformLayer sublayers]) &#123;</div><div class="line">        <span class="comment">//Create the Matrix identity</span></div><div class="line">        <span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">        <span class="comment">//Setup the perspective modifying the matrix elementat [3][4]</span></div><div class="line">        t.m34 = <span class="number">1.0</span>f / - <span class="number">1000.0</span>f;</div><div class="line">        </div><div class="line">        <span class="comment">//Perform rotate on the matrix identity</span></div><div class="line">        t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(degX), <span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f);</div><div class="line">        </div><div class="line">        <span class="comment">//Perform translate on the current transform matrix (identity + rotate)</span></div><div class="line">        t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">0.0</span>f, <span class="number">0.0</span>f,  <span class="number">250.0</span>f);</div><div class="line">        </div><div class="line">        <span class="comment">//Avoid animations</span></div><div class="line">        [<span class="built_in">CATransaction</span> setAnimationDuration:<span class="number">0.0</span>];</div><div class="line">        </div><div class="line">        <span class="comment">//apply the transoform on the current layer</span></div><div class="line">        layer.transform = t;</div><div class="line">        </div><div class="line">        <span class="comment">//Add the degree needed for the next plane</span></div><div class="line">        degX += degForPlane;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<strong>defForPlane</strong>变量是指沿着360度圆周上每个平面需要旋转的角度。看下图会容易理解一些：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/04/planes_circle_1.png" alt=""></p>
<p>圆周上的5个平面需要旋转一定的角度。这个角度从0开始，每个平面增加”360/平面总数”度。</p>
<p><strong>angle</strong>变量的值目前还是零，我们稍后会详细解释它的作用。</p>
<p>animate函数循环遍历transformLayer的所有子图层(5个平面)，为每一个平面加上一些变换效果：</p>
<p>第一个变换效果是改变视点，和我们在上一篇教程中的做法一样，直接给m34属性赋一个值，从而可以绘制出平面的3D空间深度。</p>
<p>另外2个变换效果需要一点点数值计算。我们前面已经谈到了，每个平面需要一个旋转角度。但是我们跳过了一个关键点，还没讲。</p>
<p>如果我们只是给每个平面加上一个旋转角度，我们只会得到下面这种效果：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/04/planes_center.png" alt=""></p>
<p>你可以看到，这种效果不行，我们还需要给每个平面加上平移变换，使让它们沿着圆周排列。</p>
<p>最后一步是将这些变换应用到各个平面上。只需要将变换赋值给当前平面的<strong>transform</strong>属性就可以了，赋值后，下一个平面的degX值会增加“degForPlane”度。</p>
<h3 id="拖拽手势"><a href="#拖拽手势" class="headerlink" title="拖拽手势"></a>拖拽手势</h3><p><strong>pan:</strong>函数是拖拽手势的处理函数。下面是该函数的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)pan:(<span class="built_in">UIPanGestureRecognizer</span>*)gesture&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//Get the current translation on the X</span></div><div class="line">    <span class="keyword">float</span> xOffset = [gesture translationInView:<span class="keyword">self</span>.view].x;</div><div class="line">    </div><div class="line">    <span class="comment">//When gesture begin, reset the offset</span></div><div class="line">    <span class="keyword">if</span>(gesture.state == <span class="built_in">UIGestureRecognizerStateBegan</span>)&#123;</div><div class="line">        XPanOffset = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//the distance covered since the last gesture event (I slow down a bit the final rotation multiplying by 0.5)</span></div><div class="line">    <span class="keyword">float</span> movedBy = xOffset * <span class="number">0.5</span> - XPanOffset;</div><div class="line">    </div><div class="line">    <span class="comment">//Calculate the offset from the previous gesture event</span></div><div class="line">    XPanOffset += movedBy;</div><div class="line">    </div><div class="line">    <span class="comment">//Add the offset to the current angle</span></div><div class="line">    angle += movedBy;</div><div class="line">    </div><div class="line">    <span class="comment">//Update the plane</span></div><div class="line">    [<span class="keyword">self</span> animate];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>拖拽手势是一个连续性的手势。从手势开始，直到所有手指离开屏幕之前，只要手指一移动，pan函数就会被调用。</p>
<p>为了将这些手势数据转换成对旋转木马动画有用的数据，我们需要获得每次移动前的X坐标值。</p>
<p>这里我们使用了<strong>XPanOffset</strong>这个变量来存储位置信息。当手势发生移动后，我们会计算出本次移动的距离(<strong>movedBy</strong>变量)。这个移动距离会被加到XPanOffset中，也会被加到当前的<strong>angle</strong>变量上。</p>
<p>然后调用animate函数就可以将所有平面旋转到新角度。</p>
<p>就这样，完成了！<img src="http://www.thinkandbuild.it/wp-includes/images/smilies/icon_smile.gif" alt=""></p>
<p>这个简单的例子展示了只需用Core Animation就可以做出来的一些3D效果。</p>
<p>祝你玩的愉快！有任何疑问或建议，请随时在<a href="http://twitter.com/bitwaker" target="_blank" rel="external">twitter</a>上联系我。</p>
<p><a href="https://github.com/ariok/TB_3DCoreAnimation" target="_blank" rel="external">教程源代码下载</a></p>
<p>译自：<a href="http://www.thinkandbuild.it/introduction-to-3d-drawing-in-core-animation-part-2/" target="_blank" rel="external">Think &amp; Build</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2013/06/11/2013-06-11-core-animation-3djie-shao-di-1bu-fen/&quot;&gt;上一篇&lt;/a&gt;教程中，我们已经学习了Core Animation中3D绘图的基本方法。这篇教程，我们准备深入一些，讲讲如何创建一个可交互的3D场景。我们将会创建一个类似于旋转木马的3D场景界面，用户可以通过拖拽手势来旋转界面。&lt;/p&gt;
&lt;p&gt;可能你已经在上一篇教程中见过最终APP的样子了，但是，让我们再来看一次吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/2013_06_11_core_animation_3d_app_preview.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;你可以直接下载教程的&lt;a href=&quot;https://github.com/ariok/TB_3DCoreAnimation&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源代码&lt;/a&gt;。本篇教程的源代码和上一篇教程中的源代码在同一个代码仓库里面，但是我做了一些修改，为这篇教程建立了一个新的target。&lt;/p&gt;
    
    </summary>
    
      <category term="动画" scheme="http://blog.morefun.mobi/categories/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="翻译" scheme="http://blog.morefun.mobi/categories/%E5%8A%A8%E7%94%BB/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Core Animation 3D介绍 第1部分</title>
    <link href="http://blog.morefun.mobi/2013/06/11/2013-06-11-core-animation-3djie-shao-di-1bu-fen/"/>
    <id>http://blog.morefun.mobi/2013/06/11/2013-06-11-core-animation-3djie-shao-di-1bu-fen/</id>
    <published>2013-06-11T05:21:00.000Z</published>
    <updated>2017-06-17T14:40:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>本教程将向你介绍Core Animation中用于绘制3D图形的一些技术。</p>
<p>好消息是：我们不必直接使用OpenGL，仅用Core Animation就可以很容易实现一些3D效果。但是，“用Core Animation来制作一个复杂的3D游戏”也并不是一个好主意。</p>
<p>这个教程将分为两部分。第一部分，我们先简单介绍一点3D原理知识，并运用这些概念来创建一些简单的3D场景。在第二部分中，我们将使用Core Animation来制作一个类似于旋转木马的3D场景特效。</p>
<p>最终app的预览效果如下：(译注: 原文中这里的视频被墙，因此这里只简单的提供一个图片预览，你可以直接下载例子代码运行即可以看到最终app的效果)</p>
<p><img src="/images/posts/2013_06_11_core_animation_3d_app_preview.png" alt=""></p>
<p>准备好了吗？开始编码吧！<br><a id="more"></a></p>
<p>首先，下载文章后面的代码。如果你要自己创建项目，要记得添加QuartzCore框架。</p>
<h3 id="少量3D和矩阵相关的数学知识"><a href="#少量3D和矩阵相关的数学知识" class="headerlink" title="少量3D和矩阵相关的数学知识"></a>少量3D和矩阵相关的数学知识</h3><p>要在一个3D空间中绘图，除了标准2D坐标(X和Y)概念外，我们还需要引入一个深度(depth)的概念，也就是要加入第三个坐标轴–Z轴。</p>
<p>这样，在空间中，我们只需要简单的改变物体的X、Y和Z坐标，就可以在垂直方向、水平方向或深度方向上移动物体。</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/handed.png" alt=""></p>
<p>在2D或3D空间中，对一个物体执行平移、缩放或旋转这些操作时需要使用矩阵运算。</p>
<p>你可以将矩阵想象成一个多维数组。比如，在3D空间中我们使用一个像下面这种格式的4X4矩阵：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">[X][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]</div><div class="line">[<span class="number">0</span>][Y][<span class="number">0</span>][<span class="number">0</span>]</div><div class="line">[<span class="number">0</span>][<span class="number">0</span>][Z][<span class="number">0</span>]</div><div class="line">[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]</div></pre></td></tr></table></figure>
<p>把这个矩阵和物体的每一个坐标点(又称顶点)相乘，我们可以得到物体的一个变换(transformation)效果。</p>
<p>严格点讲，前面这个矩阵是用来执行缩放操作的。其中的X、Y、Z值代表每个轴上的缩放值。</p>
<p>如果你要进行其他的变换操作，比如旋转或者平移，你需要将矩阵换成其他矩阵格式(scheme)。</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/Screen-Shot-2013-03-20-at-11.02.03-AM.png" alt=""></p>
<p>不要紧张！你不需要知道其他更多原理知识，而且也不必直接进行这些操作。Core Animation会为你完成这些操作，虽然你不知道它是如何做到的，但是它确实会为你完成这些操作，所以不必害怕。</p>
<p>当然，就我个人来说，如果我知道它背后是如何工作的(至少知道一些它的基本原理)，我会对我的代码更有自信。因此，如果你想了解更多矩阵相关的知识，建议你读一读这篇<a href="http://www.matrix44.net/cms/notes/opengl-3d-graphics/basic-3d-math-matrices" target="_blank" rel="external">文章</a>。</p>
<h3 id="3D变换-Transformations"><a href="#3D变换-Transformations" class="headerlink" title="3D变换(Transformations)"></a>3D变换(Transformations)</h3><p>现在基本上，你已经知道矩阵的作用了，也知道了3D空间是如何构成的。来，我们用Core Animation做一些3D的东西吧。</p>
<p>打开TB_3DIntro-&gt;viewController.m文件。</p>
<p>我在里面列出了6个分别以A、B、C、D、E、F开头的函数。每一个函数对应了一种不同的3D场景效果。</p>
<p>我们先来看看由<code>A_singlePlan</code>函数创造的场景吧。</p>
<p>用这个函数，我们画了一个平面，平面绕Y轴旋转了45度。</p>
<p>首先，我们创建了一个CALayer，用它来作容器层(当然，并不是一定要这样做，只是我更喜欢不直接在self.view的layer上进行工作)。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)A_singlePlane&#123;</div><div class="line">    <span class="comment">//Create the container</span></div><div class="line">    <span class="built_in">CALayer</span> *container = [<span class="built_in">CALayer</span> layer];</div><div class="line">    container.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">640</span>, <span class="number">300</span>);</div><div class="line">    [<span class="keyword">self</span>.view.layer addSublayer:container];</div></pre></td></tr></table></figure>
<p>然后我们创建了另一个CALayer，用它代表一个平面。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//Create a Plane</span></div><div class="line">   <span class="built_in">CALayer</span> *purplePlane = [<span class="keyword">self</span> addPlaneToLayer:container</div><div class="line">                                           size:<span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="number">100</span>)</div><div class="line">                                       position:<span class="built_in">CGPointMake</span>(<span class="number">250</span>, <span class="number">150</span>)</div><div class="line">                                          color:[<span class="built_in">UIColor</span> purpleColor]];</div></pre></td></tr></table></figure>
<p>我写了一个简单的辅助函数，用它将平面直接添加到容器层上，然后返回这个新建的平面层。代码非常简单：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">CALayer</span>*)addPlaneToLayer:(<span class="built_in">CALayer</span>*)container size:(<span class="built_in">CGSize</span>)size position:(<span class="built_in">CGPoint</span>)point color:(<span class="built_in">UIColor</span>*)color&#123;</div><div class="line">    <span class="comment">//Initialize the layer</span></div><div class="line">    <span class="built_in">CALayer</span> *plane = [<span class="built_in">CALayer</span> layer];</div><div class="line">    <span class="comment">//Define position,size and colors</span></div><div class="line">    plane.backgroundColor = [color <span class="built_in">CGColor</span>];</div><div class="line">    plane.opacity = <span class="number">0.6</span>;</div><div class="line">    plane.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height);</div><div class="line">    plane.position = point;</div><div class="line">    plane.anchorPoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>, <span class="number">0.5</span>);</div><div class="line">    plane.borderColor = [[<span class="built_in">UIColor</span> colorWithWhite:<span class="number">1.0</span> alpha:<span class="number">0.5</span>]<span class="built_in">CGColor</span>];</div><div class="line">    plane.borderWidth = <span class="number">3</span>;</div><div class="line">    plane.cornerRadius = <span class="number">10</span>;</div><div class="line">    <span class="comment">//Add the layer to the container layer</span></div><div class="line">    [container addSublayer:plane];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> plane;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，我们用CATransform3D来添加变换。</p>
<p>啊？？？你一定又想问CATransform3D是什么东西？按住Cmd键点击这个类型名称，你可以发现它是一个结构体，使用了一种很“火星”的语法来表示一个矩阵。<img src="http://www.thinkandbuild.it/wp-includes/images/smilies/icon_razz.gif" alt=""></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> <span class="built_in">CATransform3D</span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">CGFloat</span> m11, m12, m13, m14;</div><div class="line">  <span class="built_in">CGFloat</span> m21, m22, m23, m24;</div><div class="line">  <span class="built_in">CGFloat</span> m31, m32, m33, m34;</div><div class="line">  <span class="built_in">CGFloat</span> m41, m42, m43, m44;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CATransform3D</span> <span class="built_in">CATransform3D</span>;</div></pre></td></tr></table></figure>
<p>旋转变换部分的代码也相当简单：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">    <span class="comment">//Apply transform to the PLANE</span></div><div class="line">    <span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, <span class="number">45.00</span>f * M_PI / <span class="number">180.0</span>f, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    purplePlane.transform = t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先用单位矩阵<code>CATransform3DIdentity</code>来初始化一个变换(transformation)，然后用<code>CATransform3DRotate</code>函数给变换乘上一个旋转矩阵。</p>
<p>CATransform3DRotate这个函数的参数分别表示矩阵，旋转的角度(以弧度为单位)和3个坐标轴上的变换系数。这个例子中，X和Z轴都没受到影响，只对Y轴有影响，物体会在Y轴上旋转45度。</p>
<p>下图是运行结果。</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/pa1.png" alt=""></p>
<p>呃……你可以看到，它还不是3D的！我们只是在X轴方向上将一个正方形压扁了。</p>
<p>这是由于我们还没有设置视点的值(perspective value)。通常，在绘制3D场景的时候会将场景进行正射投影(Orthographic projection)处理，由此会产生一个扁平的场景。换句话说，在正射投影后你无法看到Z轴上的深度感。</p>
<p>要给我们的场景加上空间深度感，我们必须修改变换矩阵的<code>m34</code>参数。这个参数决定了视点的值。</p>
<p>现在，来看看<code>B_singlePlanePerspective</code>这个函数，这函数展示了视点的作用。</p>
<p>这个函数和前一个函数只有变换部分的代码有所不同：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">    <span class="comment">//Apply transform to the PLANE</span></div><div class="line">    <span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    <span class="comment">//Add perspective!!!</span></div><div class="line">    t.m34 = <span class="number">1.0</span>/ <span class="number">-500</span>;</div><div class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(<span class="number">45.0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    purplePlane.transform = t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以看到，我们直接给矩阵的m34属性赋了一个值。在这里，我不会深入的从数学上解释这个值是如何起作用的。但是我可以告诉你的是，这个值越接近0，视点就越深。</p>
<p>下面是两种不同视点值的效果：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/pa_2.png" alt=""></p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/pa_21.png" alt=""></p>
<h3 id="3D变换的顺序问题-Transformations-chain"><a href="#3D变换的顺序问题-Transformations-chain" class="headerlink" title="3D变换的顺序问题(Transformations chain)"></a>3D变换的顺序问题(Transformations chain)</h3><p>我们可以将多个矩阵相乘从而将多种变换应用到一个物体上。比如，如果我们想将平移和旋转变换应用到一个物体上，我们可以直接将两个变换矩阵相乘：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">TransformMatrix = TranslateMtx * RotateMtx</div></pre></td></tr></table></figure>
<p>数学上，一般情况下乘法都可以使用交换律：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">TranslateMtx * RotateMxt = RotateMtx * TranslateMtx</div></pre></td></tr></table></figure>
<p>但是<strong>矩阵乘法不适用于交换律</strong>。AxB的结果可能和BxA的结果不一样。要记住这一点！</p>
<p>接下来<code>C_transformationsChain</code>这个例子中，我们会将2个变换效果按不同的先后顺序应用到2个不同的物体上。</p>
<p>以下是主要代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//Apply transformation to the PLANES</span></div><div class="line"><span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line"> </div><div class="line"><span class="comment">//Purple plane: Perform a rotation and then a translation</span></div><div class="line">t = <span class="built_in">CATransform3DRotate</span>(t, <span class="number">45.0</span>f * M_PI / <span class="number">180.0</span>f, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">purplePlane.transform = t;</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">//reset the transform matrix</span></div><div class="line">t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line"> </div><div class="line"><span class="comment">//Red plane: Perform translation first and then the rotation</span></div><div class="line">t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">t = <span class="built_in">CATransform3DRotate</span>(t, <span class="number">45.0</span>f * M_PI / <span class="number">180.0</span>f, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">redPlane.transform = t;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/Screen-Shot-2013-03-20-at-11.47.15-AM.png" alt=""></p>
<p>看到了吗，不同的变换顺序完全导致了不同的效果。</p>
<p>我们重点下看一下紫色的那块。旋转变换改变了它的坐标轴方向，然后我们又将它沿X轴进行了平移，此时它的X轴方向已经和红色平面的X轴方向不一致了。</p>
<p>变换步骤示意图如下：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/p_r.png" alt=""></p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/p_r2.png" alt=""></p>
<h3 id="图层层次-layer-hierarchies"><a href="#图层层次-layer-hierarchies" class="headerlink" title="图层层次(layer hierarchies)"></a>图层层次(layer hierarchies)</h3><p>到目前为止，我们都是将变换直接应用在这些平面上。在3D场景中，经常需要创建一些相互之间有层次结构的物体。这个时候，只需要将变换应用到根层次上，就可以使整个层次结构中的物体整体具有这个变换效果。这种做法非常有用。</p>
<p>接下来，我们来看看<code>D_multiplePlanes</code>这个例子。</p>
<p>我们在容器层上添加了4个平面。</p>
<p>当没有任何变换效果时看起来是这样的：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/p5.png" alt=""></p>
<p>如果我们给每一个平面都加上一个Y轴上的旋转变换，我们会得到4个独立的旋转效果：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/p5_2.png" alt=""></p>
<p>但是，如果我们只是在容器层上应用旋转变换，我们会得到一个完全不同的场景效果：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/p5_1.png" alt=""></p>
<p>这种效果，是相机(camera)位置发生改变带来的结果。我们没有移动每个平面，只是改变了视点的位置。</p>
<p>此函数主要的变换部分代码如下，包含了分别应用于各个平面和应用于容器层的两种变换效果的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//Transformation </span></div><div class="line"><span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line"> </div><div class="line"><span class="built_in">BOOL</span> applyToContainer = <span class="literal">NO</span>;</div><div class="line"> </div><div class="line"><span class="comment">//Apply the transformation to each PLANE</span></div><div class="line"><span class="keyword">if</span>(!applyToContainer)&#123;</div><div class="line">    t.m34 = <span class="number">1.0</span> / <span class="number">-500.0</span>;</div><div class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(<span class="number">60.0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    purplePlane.transform = t;</div><div class="line">     </div><div class="line">    t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    t.m34 = <span class="number">1.0</span> / <span class="number">-500.0</span>;</div><div class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(<span class="number">60.0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    redPlane.transform = t;</div><div class="line">     </div><div class="line">    t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    t.m34 = <span class="number">1.0</span> / <span class="number">-500.0</span>;</div><div class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(<span class="number">60.0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    orangePlane.transform = t;</div><div class="line">     </div><div class="line">    t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    t.m34 = <span class="number">1.0</span> / <span class="number">-500.0</span>;</div><div class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(<span class="number">60.0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    yellowPlane.transform = t;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//Apply the transformation to the CONTAINER</span></div><div class="line"><span class="keyword">else</span>&#123;    </div><div class="line">    <span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    t.m34 = <span class="number">1.0</span>/<span class="number">-500</span>;</div><div class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(<span class="number">60.0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    container.transform = t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CATransformLayer"><a href="#CATransformLayer" class="headerlink" title="CATransformLayer"></a>CATransformLayer</h3><p>到目前为止我们所见到的代码都能正常工作，但说实话，作为3D层次结构的根，CALayer不是正确的选择。</p>
<p>函数<code>E_multiplePlanesZAxis</code>展示了为什么。</p>
<p>这个例子中，我们创建4个XY坐标相同只有Z坐标不同的平面。紫色平面最近，黄色平面最远。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//Apply transforms to the PLANES</span></div><div class="line">t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-10</span>);</div><div class="line">purplePlane.transform = t;</div><div class="line"> </div><div class="line">t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-50</span>);</div><div class="line">redPlane.transform = t;</div><div class="line"> </div><div class="line">t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-90</span>);</div><div class="line">orangePlane.transform = t;</div><div class="line"> </div><div class="line">t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-130</span>);</div><div class="line">yellowPlane.transform = t;</div></pre></td></tr></table></figure>
<p>在旋转这些平面前，我们先让容器层执行了一个旋转变换。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//Apply transform to the CONTAINER</span></div><div class="line"><span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">t.m34 = <span class="number">1.0</span>/<span class="number">-500</span>;</div><div class="line">t = <span class="built_in">CATransform3DRotate</span>(t, <span class="number">80.0</span>f * M_PI / <span class="number">180.0</span>f, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">container.transform = t;</div></pre></td></tr></table></figure>
<p>你也许希望看到下面这种结果：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/p6_1.png" alt=""></p>
<p>但是，实际上会得到这种结果：</p>
<p><img src="http://www.thinkandbuild.it/wp-content/uploads/2013/03/p6.png" alt=""></p>
<p>这是因为CALayer不能处理3D层次结构的深度，它只能将场景处理成相同的Z层次。</p>
<p>为了修正这个问题，我们需要用一个<code>CATransformLayers</code>来做根层对象。</p>
<p>函数<code>F_multiplePlanesZAxis</code>修正了这个问题：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//Create the container as a CATransformLayer</span></div><div class="line"><span class="built_in">CATransformLayer</span> *container = [<span class="built_in">CATransformLayer</span> layer];</div><div class="line">container.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">640</span>, <span class="number">300</span>);</div><div class="line">[<span class="keyword">self</span>.view.layer addSublayer:container];</div></pre></td></tr></table></figure>
<p>CATransformLayer是一个特殊的layer。与CALayer的不同之处在于，CATransformLayer本身不会被渲染到屏幕上，只有它的子图层才会被渲染到屏幕上。所以它的一些属性，比如backgroundColor、contents、border等等都没有什么用。要记住这点。</p>
<p>到这里，这个教程的第一部分就完了。建议你实际运行一下这些函数，也可以试试我没有讲到的<code>CATransform3DScale</code>，试试用它做一个缩放变换看。</p>
<p>如果你有任何问题，可以在twitter上找到我(<a href="http://www.twitter.com/bitwaker" target="_blank" rel="external">@bitwaker</a>)。</p>
<p><a href="https://github.com/ariok/TB_3DCoreAnimation" target="_blank" rel="external">本教程代码下载</a></p>
<p>译自：<a href="http://www.thinkandbuild.it/introduction-to-3d-drawing-in-core-animation-part-1/" target="_blank" rel="external">Think &amp; Build</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本教程将向你介绍Core Animation中用于绘制3D图形的一些技术。&lt;/p&gt;
&lt;p&gt;好消息是：我们不必直接使用OpenGL，仅用Core Animation就可以很容易实现一些3D效果。但是，“用Core Animation来制作一个复杂的3D游戏”也并不是一个好主意。&lt;/p&gt;
&lt;p&gt;这个教程将分为两部分。第一部分，我们先简单介绍一点3D原理知识，并运用这些概念来创建一些简单的3D场景。在第二部分中，我们将使用Core Animation来制作一个类似于旋转木马的3D场景特效。&lt;/p&gt;
&lt;p&gt;最终app的预览效果如下：(译注: 原文中这里的视频被墙，因此这里只简单的提供一个图片预览，你可以直接下载例子代码运行即可以看到最终app的效果)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/2013_06_11_core_animation_3d_app_preview.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;准备好了吗？开始编码吧！&lt;br&gt;
    
    </summary>
    
      <category term="动画" scheme="http://blog.morefun.mobi/categories/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="翻译" scheme="http://blog.morefun.mobi/categories/%E5%8A%A8%E7%94%BB/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS MVC设计模式最佳实践要点</title>
    <link href="http://blog.morefun.mobi/2013/05/20/2013-05-20-ios-mvcshe-ji-mo-shi-zui-jia-shi-jian-yao-dian/"/>
    <id>http://blog.morefun.mobi/2013/05/20/2013-05-20-ios-mvcshe-ji-mo-shi-zui-jia-shi-jian-yao-dian/</id>
    <published>2013-05-20T03:04:00.000Z</published>
    <updated>2017-06-17T14:16:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>一些关于MVC模式的实践要点，摘自《iOS5 Programming Pushing The Limits》。</p>
<h3 id="模型-Model"><a href="#模型-Model" class="headerlink" title="模型(Model)"></a>模型(Model)</h3><ul>
<li><p><strong>一个好的模型类仅以独立的描述性的方式封装数据。</strong></p>
<p>  比如一个Person类，可能有name、address、brithdate、image这些描述性的数据。但是不应该有显示或修改这些功能。</p>
</li>
<li><p><strong>模型类应当只引用其他模型类，永远不要引用视图(View)类或控制器(Controller)类</strong></p>
<p>  模型类可以定义一个协议，用delegate的形式和它们交互，这样就不需要引用一个特定类型的视图类或者控制器类了。</p>
<a id="more"></a>    
</li>
</ul>
<h3 id="视图-View"><a href="#视图-View" class="headerlink" title="视图(View)"></a>视图(View)</h3><ul>
<li><p><strong>视图类负责展示数据</strong></p>
</li>
<li><p><strong>视图类负责接收用户输入事件，但是不负责处理它们</strong></p>
<p>  当用户点击一个视图后，视图可以以delegate的方式发出通知“我被点击了”，但是不应该直接进入处理逻辑或者修改其他视图什么的。</p>
<p>  比如，UITableViewCell上，点击一个删除按钮后，视图应该通知delegate删除按钮被点击了，而不是直接告诉模型类删除数据或者告诉tableView移除屏幕上显示的内容，这些都是控制器的责任。</p>
</li>
</ul>
<ul>
<li><p><strong>视图类不要引用控制器类</strong></p>
<p>  像模型类一样，可以用delegate的方式和控制器类交互。</p>
</li>
<li><p><strong>除了superView或subView，视图类不要引用其他任何视图类</strong></p>
</li>
</ul>
<ul>
<li><p><strong>视图类可以引用模型类</strong></p>
<p>  但它引用的模型类通常就是它要显示的那个模型类。</p>
<p>  没有引用任何特殊模型类的视图重用性更高。比如UITableViewCell，它只用于显示字符串和图片，没有引用什么特殊的模型类，所以重用性高。</p>
<p>  有时，你需要根据实际情况在重用性和易用性上做取舍。通常，对于应用开发人员来说，定制的视图类通常更容易使用；但对于框架开发人员(比如UIKit团队)来说，就会更侧重于重用性。</p>
</li>
</ul>
<h3 id="控制器-Controller"><a href="#控制器-Controller" class="headerlink" title="控制器(Controller)"></a>控制器(Controller)</h3><ul>
<li><p><strong>控制器类负责协调模型和视图，它实现了应用程序的大部分逻辑</strong></p>
<p>  控制器类通常是程序中最不能重用的部分，这就是为什么要严格禁止模型类或视图类直接引用控制器类的原因。</p>
<p>  这里所说的直接引用是指引用一个特定类型的类。比如UITableView引用一个实现了<uitableviewdelegate>协议的类是OK的，都是不应该引用一个特定的，比如叫MyTableViewController的类。</uitableviewdelegate></p>
</li>
<li><p><strong>另一常见的错误是，使用appDelegate保存全局数据</strong></p>
<p>  如下例子，经常这么写的话，会造成很多对象直接引用appDelegate类，这样代码会很难重用，因为这些代码都要依赖于特殊的appDelegate类。如果要访问全局数据的化，用单例模式好些。</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//不要这么干</span></div><div class="line">MyAppDelegate *appDelegate = (MyAppDelegate *)[[<span class="built_in">UIApplication</span> sharedApplication] delegate];</div><div class="line">Something *something = [appDelegate something];</div><div class="line"><span class="comment">//不要这么干</span></div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些关于MVC模式的实践要点，摘自《iOS5 Programming Pushing The Limits》。&lt;/p&gt;
&lt;h3 id=&quot;模型-Model&quot;&gt;&lt;a href=&quot;#模型-Model&quot; class=&quot;headerlink&quot; title=&quot;模型(Model)&quot;&gt;&lt;/a&gt;模型(Model)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;一个好的模型类仅以独立的描述性的方式封装数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  比如一个Person类，可能有name、address、brithdate、image这些描述性的数据。但是不应该有显示或修改这些功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;模型类应当只引用其他模型类，永远不要引用视图(View)类或控制器(Controller)类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  模型类可以定义一个协议，用delegate的形式和它们交互，这样就不需要引用一个特定类型的视图类或者控制器类了。&lt;/p&gt;
    
    </summary>
    
      <category term="编程思想" scheme="http://blog.morefun.mobi/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="设计模式" scheme="http://blog.morefun.mobi/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>使用objc的AssociatedObject函数给现有类添加新property</title>
    <link href="http://blog.morefun.mobi/2013/05/16/2013-05-16-ru-he-shi-yong-objcde-associatedobjecthan-shu-gei-xian-you-lei-tian-jia-xin-property/"/>
    <id>http://blog.morefun.mobi/2013/05/16/2013-05-16-ru-he-shi-yong-objcde-associatedobjecthan-shu-gei-xian-you-lei-tian-jia-xin-property/</id>
    <published>2013-05-16T03:49:00.000Z</published>
    <updated>2017-06-17T14:14:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C的Category(类别)是一个很强大的特性。使用Category我们可以给现有类增加一些新的方法。但是也仅限于方法，不能直接增加新的property。但通过运行时中的<code>objc_setAssociatedObject</code>/<code>objc_getAssociatedObject</code>函数，就可以很方便的为现有类增加新property。</p>
<p>如下面代码所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  NSObject+Test.h</span></div><div class="line"><span class="comment">//  Test</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by ZhangTinghui on 13-5-16.</span></div><div class="line"><span class="comment">//  Copyright (c) 2013年 ZhangTinghui. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Test</span>)</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *testString;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  NSObject+Test.m</span></div><div class="line"><span class="comment">//  Test</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by ZhangTinghui on 13-5-16.</span></div><div class="line"><span class="comment">//  Copyright (c) 2013年 ZhangTinghui. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"NSObject+Test.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Test</span>)</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setTestString:(<span class="built_in">NSString</span> *)testString</div><div class="line">&#123;</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(testString), testString, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)testString</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(testString));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C的Category(类别)是一个很强大的特性。使用Category我们可以给现有类增加一些新的方法。但是也仅限于方法，不能直接增加新的property。但通过运行时中的&lt;code&gt;objc_setAssociatedObject&lt;/code&gt;/&lt;code&gt;objc_getAssociatedObject&lt;/code&gt;函数，就可以很方便的为现有类增加新property。&lt;/p&gt;
&lt;p&gt;如下面代码所示：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  NSObject+Test.h&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  Test&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  Created by ZhangTinghui on 13-5-16.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  Copyright (c) 2013年 ZhangTinghui. All rights reserved.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;Foundation/Foundation.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *testString;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Objc" scheme="http://blog.morefun.mobi/categories/Objc/"/>
    
      <category term="runtime" scheme="http://blog.morefun.mobi/categories/Objc/runtime/"/>
    
    
  </entry>
  
  <entry>
    <title>GCD使用详解 下篇</title>
    <link href="http://blog.morefun.mobi/2013/05/07/2013-05-07-gcdshi-yong-xiang-jie-xia-pian/"/>
    <id>http://blog.morefun.mobi/2013/05/07/2013-05-07-gcdshi-yong-xiang-jie-xia-pian/</id>
    <published>2013-05-07T08:19:00.000Z</published>
    <updated>2017-08-13T08:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dispatch-Queue的一些函数"><a href="#Dispatch-Queue的一些函数" class="headerlink" title="Dispatch Queue的一些函数"></a>Dispatch Queue的一些函数</h2><p>GCD还提供了许多很有用的API用于控制队列中的任务。接下来，我们挨个看看这些API，你就明白为什么GCD如此强大。</p>
<h3 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h3><p><code>dispatch_set_target_queue</code>函数用于设置一个”目标”队列。这个函数主要用来为新创建的队列设置优先级。当用<code>dispatch_queue_create</code>函数创建一个队列后，无论创建的是并行队列还是串行队列，队列的优先级都和全局队列的默认优先级一样。创建队列后，你可以用这个函数来修改队列的优先级。下面的代码演示了如何给一个串行队列设置background优先级。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> mySerialDispatchQueue =</div><div class="line">	dispatch_queue_create(<span class="string">"com.example.gcd.MySerialDispatchQueue"</span>, <span class="literal">NULL</span>);</div><div class="line"><span class="built_in">dispatch_queue_t</span> globalDispatchQueueBackground =</div><div class="line">	dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>);</div><div class="line">dispatch_set_target_queue(mySerialDispatchQueue, globalDispatchQueueBackground);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>上面代码中，<code>dispatch_set_target_queue</code>函数的第一个参数是被设置优先级的队列，第二个参数是一个全局队列，它会被作为目标队列。这段代码会使队列拥有和目标队列相同的优先级(稍后会解释这里的机制)。如果你将主线程队列或者全局队列传递给<code>dispatch_set_target_queue</code>函数的第一参数，结果不确定，最好不要这么干。使用<code>dispatch_set_target_queue</code>函数不仅能够设置优先级，也能创建队列的层次体系。如图7-8所示，一个串行队列被设置成了多个串行队列的目标队列，在目标队列上，一次只会有一个队列被执行。</p>
<p><img src="/images/posts/Figure7–8_Dispatch_Queue_execution_hierarchy.png" alt=""></p>
<p>这样，当有些任务你不想它们同时运行而又不得不将它们添加到不同的串行队列中时，就可以避免它们同时运行。(虽然，实际上我也不知道什么情况下会有这样的需求。)</p>
<h3 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h3><p><code>dispatch_after</code>用于在队列中定时执行任务。当你想在一段时间后执行一个任务，那么就可以用这个函数。例如，下面代码中，3秒过后，指定的block会被添加到主线程队列上。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, <span class="number">3</span>ull * <span class="built_in">NSEC_PER_SEC</span>); </div><div class="line">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</div><div class="line">	<span class="built_in">NSLog</span>(<span class="string">@"waited at least three seconds."</span>); </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>代码中，“ull”代表<code>unsigned long long</code>类型。请注意，<code>dispatch_after</code>函数并不会在指定的时间立即执行任务，时间到后，它只将任务添加到队列上。所以，这段代码的作用和你在3秒钟后用<code>dispatch_async</code>函数将block加到主线程队列上是一样的。主线程队列是在RunLoop上执行的，因此，假如RunLoop每1/60秒执行一次任务，那么上面添加的block会在3秒~3+1/60秒后被执行。如果主线程队列上添加了很多任务，或者主线程延迟了，时间可能更晚。所以，将<code>dispatch_after</code>作为一个精确的定时器使用是有问题的。如果你只是想粗略的延迟一下任务，这个函数倒是挺适用的。</p>
<p>函数的第二个参数指定了一个dispatch队列，用于添加任务。第三个参数，是一个block，即要执行的任务。第一参数指定了延迟的时间，是一个<code>dispatch_time_t</code>类型的参数，可以用<code>dispatch_time</code>函数或<code>dispatch_walltime</code>函数来创建。</p>
<p><code>dispatch_time</code>的第一个参数是指定的起始时间，第二个参数是以纳秒为单位的一个时间间隔。这个函数以起始时间和时间间隔来创建一个新的时间。如示例所示，通常以<code>DISPATCH_TIME_NOW</code>来作为第一个参数的值，它表示当前的时间。在下面这段代码中，你可以得到一个<code>dispatch_time_t</code>类型的表示1秒钟之后的时间的变量。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, <span class="number">1</span>ull * <span class="built_in">NSEC_PER_SEC</span>);</div></pre></td></tr></table></figure>
<p>第二个参数中，<code>NSEC_PER_SEC</code>和数字的乘积会得到一个以纳秒为单位的时间间隔值。如果使用NSEC_PER_MSEC，就会得到一个以毫秒为单位的时间间隔值。下面的代码，演示了如何获得一个150毫秒之后的时间。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, <span class="number">150</span>ull * <span class="built_in">NSEC_PER_MSEC</span>);</div></pre></td></tr></table></figure>
<p><code>dispatch_walltime</code>函数以一个<code>timespec</code>结构体类型(来自POSIX接口)的时间来创建一个<code>dispatch_time_t</code>类型的时间。<code>dispatch_time</code>主要用于创建一个相对时间。<code>dispatch_walltime</code>函数则是用于创建一个绝对时间。比如，你可以用<code>dispatch_walltime</code>函数为<code>dispatch_after</code>函数创建一个诸如“2011年11月11日 11:11:11”这样的绝对时间，用来做一个闹钟，但是它是低精度的。通过NSDate类对象，可以很方便的创建一个<code>timespec</code>结构的时间，如下面代码所示。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">dispatch_time_t getDispatchTimeByDate(<span class="built_in">NSDate</span> *date)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">NSTimeInterval</span> interval; </div><div class="line">	<span class="keyword">double</span> second, subsecond; </div><div class="line">	<span class="keyword">struct</span> timespec time; </div><div class="line">	dispatch_time_t milestone;</div><div class="line">	</div><div class="line">	interval = [date timeIntervalSince1970]; </div><div class="line">	subsecond = modf(interval, &amp;second); </div><div class="line">	time.tv_sec = second;</div><div class="line">	time.tv_nsec = subsecond * <span class="built_in">NSEC_PER_SEC</span>; </div><div class="line">	milestone = dispatch_walltime(&amp;time, <span class="number">0</span>);</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> milestone; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h3><p>Dispatch Group 用于创建一组队列。有时你可能需要等待队列中的所有任务完成后才执行另一个任务。当所有任务都在一个串行队列里面的时候，你只需要将最后一个任务加到队列的末尾就可以了。但如果你在使用并行队列的时候或者面对多个队列的时候，就没那么简单了。这种情况下，就可以使用 Dispatch Group 。下面的代码演示了 Dispatch Group 的基本用法，代码中，3个block被添加到了全局队列上，当所有block都完成后，最后一个block会在主线程队列上执行。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_async(group, queue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk0"</span>);&#125;); </div><div class="line">dispatch_group_async(group, queue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk1"</span>);&#125;); </div><div class="line">dispatch_group_async(group, queue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk2"</span>);&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"done"</span>);&#125;);</div><div class="line">dispatch_release(group);</div></pre></td></tr></table></figure>
<p>代码的执行结果可能会是这样：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">blk1</div><div class="line">blk2</div><div class="line">blk0</div><div class="line">done</div></pre></td></tr></table></figure>
<p>任务的执行顺序不会每次都相同，因为它们是被添加到全局的并发队列上的，会并发的在多个线程上执行。但“done”总是会在最后被执行。</p>
<p>不管是在何种队列上，dispatch group 都会监控任务的完成情况。当它发现所有任务都完成后，最后一个任务就会被加到队列上。这就是dispatch group的使用方法。</p>
<p>首先，用<code>dispatch_group_create</code>函数创建一个<code>dispatch_group_t</code>类型的dispatch group。因为函数名字中包含<code>create</code>，当你不再需要这个dispatch group后，要将它释放掉。与dispatch队列一样，用<code>dispatch_release</code>函数释放它。</p>
<p>接着，像用<code>dispatch_async</code>函数那样，用<code>dispatch_group_async</code>函数将block加到指定的队列上。与<code>dispatch_async</code>函数的不同之处在于，这个函数需要一个dispatch group来作为第一个参数。当调用<code>dispatch_group_async</code>函数的时候，block就和group关联起来了。和将block添加到dispatch队列的情况类似，当一个block和dispatch group关联起来后，block也就会通过<code>dispatch_retain</code>函数获得dispatch group的所有权。当block执行完毕后，也会通过<code>dispatch_release</code>函数释放掉对group的所有权。你不需要去关心block和group是如何关联起来的。</p>
<p>最后，<code>dispatch_group_notify</code>函数将一个block加到了一个dispatch队列上。这个block会在group中的所有任务完成后被执行。函数的第一个参数是一个要通知的dispatch group。当和这个group关联的所有任务完成后，第三个参数中的block会被添加到指定的队列(第二个参数)上。不管传递给<code>dispatch_group_notify</code>函数的是何种队列，当block被添加到队列上时，group相关联的所有任务必定已经全部完成了。</p>
<p>另外，如下代码所示，你还可以使用<code>dispatch_group_wait</code>函数，等待dispatch group的所有任务完成。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">dispatch_group_t group = dispatch_group_create(); </div><div class="line">dispatch_group_async(group, queue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk0"</span>);&#125;); </div><div class="line">dispatch_group_async(group, queue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk1"</span>);&#125;); </div><div class="line">dispatch_group_async(group, queue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk2"</span>);&#125;); </div><div class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER); </div><div class="line">dispatch_release(group);</div></pre></td></tr></table></figure>
<p><code>dispatch_group_wait</code>函数的第二个参数是等待的时间，<code>dispatch_time_t</code>类型。这个例子中，<code>DISPATCH_TIME_FOREVER</code>表示永远等待。它会一直等待，直到dispatch group相关联的所有任务都完成。不能在中途取消等待。</p>
<p>和dispatch_after函数中类似，你也可以设置等待1秒种。如下代码所示。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, <span class="number">1</span>ull * <span class="built_in">NSEC_PER_SEC</span>); </div><div class="line"><span class="keyword">long</span> result = dispatch_group_wait(group, time);</div><div class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * dispatch group相关联的所有任务都已经完成</div><div class="line">	 */</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * dispatch group相关联的一些任务仍然在执行</div><div class="line">	 */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>dispatch_group_wait</code>函数没有返回0，则说明当指定的等待时间过后，dispatch group相关联的一些任务仍然还在执行。如果它返回0，则说明所有任务都已经完成。如果指定的等待时间是<code>DISPATCH_TIME_FOREVER</code>，那么dispatch_group_wait函数肯定会返回0，因为必须要等待所有任务完成后才能返回。</p>
<p>这里的“wait”是指当<code>dispatch_group_wait</code>函数被调用后，函数不会立即返回，当前执行<code>dispatch_group_wait</code>函数的这个线程会停止，当超过指定的等待时间后或者dispatch group相关联的所有任务都完成后，这个线程才会继续，函数才会返回结果。</p>
<p>当等待时间被指定为<code>DISPATCH_TIME_NOW</code>的时候，这个函数可以被用来检查dispatch group相关联的所有任务是否都已经完成。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">long</span> result = dispatch_group_wait(group, DISPATCH_TIME_NOW);</div></pre></td></tr></table></figure>
<p>例如，你可以在主线程的RunLoop上毫无延迟的检查每次loop中是否所有任务都完成了，然后再做某些操作。尽管可以这样干，但是我建议还是用dispatch_group_notify函数好些，这样你的代码可以更简洁。</p>
<h3 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h3><p><code>dispatch_barrier_async</code>函数用于等待队列中其他任务完成。前面我们提到过，当你访问数据库或者一个文件的时候，你可以用串行队列来避免数据冲突。但实际上，当有其他更新数据或读取数据的操作在进行的时候，不应该同时再进行更新数据的操作。但是多个读取操作是可以同时进行的，这样可以更高效的访问数据。这种情况下，更新数据的操作必须放到一个串行队列中，并且只有当串行队列中没有任何更新操作在执行的时候，这些读取操作才能被放到一个并行队列中。你要确保不能在更新操作完成前开始读取操作。你可以用dispatch group和<code>dispatch_set_target_queue</code>函数来实现这种功能，但是会很复杂。GCD提供了一个更好的解决方案，就是<code>dispatch_barrier_async</code>函数。下面的代码创建了一个并发队列，然后向队列中添加了一些读取操作。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create( <span class="string">"com.example.gcd.ForBarrier"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk0_for_reading);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk1_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk2_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk3_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk4_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk5_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk6_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk7_for_reading);</div><div class="line">dispatch_release(queue);</div></pre></td></tr></table></figure>
<p>接下来，想象一下，在blk3_for_reading和blk4_for_reading之间要进行一个写数据的任务，任务完成后，blk4_for_reading才开始读取更新过后的数据。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(queue, blk0_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk1_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk2_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk3_for_reading);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 写数据</div><div class="line"> *</div><div class="line"> * 现在，所有读取操作读取到的都是更新后的数据 </div><div class="line"> */</div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk4_for_reading);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk5_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk6_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk7_for_reading);</div></pre></td></tr></table></figure>
<p>如果我们像下面代码一样，只是简单的用<code>dispatch_async</code>函数来添加写数据的操作，写操作之前添加的读取操作同样有可能会意外地读取到更新过后的数据。程序还可能因此而崩溃，此外，还会引起数据冲突和其他许多问题。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(queue, blk0_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk1_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk2_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk3_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk_for_writing); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk4_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk5_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk6_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk7_for_reading);</div></pre></td></tr></table></figure>
<p>这种情况下就该用<code>dispatch_barrier_async</code>函数了。使用<code>dispatch_barrier_async</code>函数，你可以将一个任务在所有任务都完成后才加入到并发队列中。当用<code>dispatch_barrier_async</code>添加的任务完成后，并发队列中的任务又恢复并发执行。图7-9演示了下面这段代码的执行情况。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(queue, blk0_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk1_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk2_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk3_for_reading); </div><div class="line">dispatch_barrier_async(queue, blk_for_writing); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk4_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk5_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk6_for_reading); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk7_for_reading);</div></pre></td></tr></table></figure>
<p><img src="/images/posts/Figure7–9Execution-with-the-dispatch_barrier_async-function.png" alt=""></p>
<p>就是这么简单，只需要用<code>dispatch_barrier_async</code>代替<code>dispatch_async</code>。</p>
<p>所以，为了更高效的访问数据库或文件，尽情的使用并发队列和<code>dispatch_barrier_async</code>函数吧。</p>
<p>接下来，我们来看看<code>dispatch_sync</code>函数，看起来和<code>dispatch_async</code>函数很像，对吧？</p>
<h3 id="dispatch-sync"><a href="#dispatch-sync" class="headerlink" title="dispatch_sync"></a>dispatch_sync</h3><p><code>dispatch_sync</code>函数和<code>dispatch_async</code>函数类似都是用于将一个任务添加到一个队列上，但是<code>dispatch_sync</code>会等待添加到队列上的任务执行完毕。而<code>dispatch_async</code>函数名字中的“async”代表异步(asynchronous)。因此，它将一个block添加到一个队列上后，block会异步的执行，dispatch_async不会等待任务执行完毕。如图7-10所示。</p>
<p><img src="/images/posts/Figure7–10Behavior-of-dispatch_async-function.png" alt=""></p>
<p>与此对应的同步版本(synchronous)——<code>dispatch_sync</code>函数，它将block添加到队列上后，会等到block执行完毕后才返回。如图7-11所示。</p>
<p><img src="/images/posts/Figure7–11-Behavior-of-dispatch_sync-function.png" alt=""></p>
<p>与前面介绍过的<code>dispatch_group_wait</code>函数类似，等待表示当前线程会暂停。例如，你可能想在主线程上使用一个在全局队列上运行的任务的结果，这种情况，你就可以用dispatch_sync函数。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;<span class="comment">/* a task */</span>&#125;);</div></pre></td></tr></table></figure>
<p>当<code>dispatch_sync</code>函数被调用后，函数不会立即返回，它会等待任务执行完成后才返回。这有点像是一个简单版的<code>dispatch_group_wait</code>函数。<code>dispatch_sync</code>的使用也非常简单，但它可能会引起死锁问题。例如，下面的代码如果在主线程上运行，就会造成死锁。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue(); </div><div class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"Hello?"</span>);&#125;);</div></pre></td></tr></table></figure>
<p>block被添加到了主线程队列上，但同时主线程又会等待block完成后才能继续，所以最后这个block永远也无法被执行。</p>
<p>再看下面这段代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue(); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">	<span class="built_in">dispatch_sync</span>(queue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"Hello?"</span>);&#125;); </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>dispatch_async</code>添加block后，虽然会立即返回，但是因为<code>dispatch_async</code>添加的这个block是加到主线程队列上的，而后面<code>dispatch_sync</code>这个函数添加的block也是加到主线程队列上的，也会造成死锁。</p>
<p>同样，这个问题也会发生在一个串行队列上。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.example.gcd.MySerialDispatchQueue"</span>, <span class="literal">NULL</span>);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">	<span class="built_in">dispatch_sync</span>(queue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"Hello?"</span>);&#125;); </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>另外，类似的<code>dispatch_barrier_async</code>函数中包含了一个“async”，同样这个函数也有一个“sync”版本，叫做<code>dispatch_barrier_sync</code>。当队列中的所有任务执行完成后，由<code>dispatch_barrier_sync</code>函数添加的这个任务会开始执行，并且函数会等待任务完成后才返回，像<code>dispatch_sync</code>函数一样。</p>
<p>当使用这些同步的(synchronous)API的时候，比如<code>dispatch_sync</code>，它们会等待任务完成后才继续。所以，当你使用这些API的时候要想想为什么，注意不要造成死锁。</p>
<h3 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h3><p><code>dispatch_apply</code>函数与<code>dispatch_sync</code>函数和dispatch group有点关系。它用来将一个block多次添加到dispatch队列上，然后等待所有任务完成。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">dispatch_apply(<span class="number">10</span>, queue, ^(size_t index) &#123;</div><div class="line">	<span class="built_in">NSLog</span>(<span class="string">@"%zu"</span>, index); </div><div class="line">&#125;);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"done"</span>);</div></pre></td></tr></table></figure>
<p>代码执行结果如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="number">4</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">6</span></div><div class="line"><span class="number">8</span></div><div class="line"><span class="number">9</span></div><div class="line"><span class="number">7</span></div><div class="line">done</div></pre></td></tr></table></figure>
<p>因为是执行在全局队列上面的，所以每个任务的执行时间不一定相同。但是，“done”总会在最后执行，因为<code>dispatch_apply</code>函数会等待所有任务完成。</p>
<p>函数中，第一个参数是添加次数，第二个参数是目标队列，第三个参数是要添加到目标队列上的block。在上面这个例子中，可以看到block带有一个参数，这个参数是用来区分是第几次的block，因为block会被多次添加到队列上。比如，如果你想要对一个NSArray中的所有对象进行某些操作的时候，就可以不用for循环的方式了，如下代码所示。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">dispatch_apply([array count], queue, ^(size_t index) &#123;</div><div class="line">	<span class="built_in">NSLog</span>(<span class="string">@"%zu: %@"</span>, index, [array objectAtIndex:index]); </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如你所见，在一个全局队列上对数组中的所有对象执行相同的处理非常容易。<code>dispatch_apply</code>函数会像<code>dispatch_sync</code>函数一样等待所有任务完成，所以建议你将<code>dispatch_apply</code>和<code>dispatch_async</code>函数一起结合使用。如下所示。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 在全局dispatch上并发执行</div><div class="line"> */</div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line"> 	 * 在全局dispatch队列上，dispatch_apply会等待所有任务完成。</div><div class="line"> 	 */</div><div class="line">	dispatch_apply([array count], queue, ^(size_t index) &#123;</div><div class="line"></div><div class="line">		<span class="comment">/*</span></div><div class="line"> 		 * 并发地对数组中的所有对象进行一些处理</div><div class="line"> 		 */</div><div class="line">		<span class="built_in">NSLog</span>(<span class="string">@"%zu: %@"</span>, index, [array objectAtIndex:index]); </div><div class="line">	&#125;);</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * dispatch_apply添加的所有任务都完成了。</div><div class="line">	 */</div><div class="line">	 </div><div class="line">	 </div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 在主线程dispatch队列上异步执行某些任务。</div><div class="line">	 */</div><div class="line">	<span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line"></div><div class="line">		<span class="comment">/*</span></div><div class="line">		 * 这里是要在主线程队列上执行的任务。</div><div class="line">		 * 比如更新用户界面等等。</div><div class="line">		 */</div><div class="line">		<span class="built_in">NSLog</span>(<span class="string">@"done"</span>);</div><div class="line">	&#125;); </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>好了，休息一会儿。我们稍后再接着看<code>dispatch_suspend</code>和<code>dispatch_resume</code>函数。</p>
<h3 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend/dispatch_resume"></a>dispatch_suspend/dispatch_resume</h3><p>这两个函数是用来暂停或继续队列运行的。当你想要往一个dispatch队列上添加多个任务，并且不想在全部任务添加完毕前执行任何一个任务，这个时候，你可以先让队列暂停运行，在你处理完后再让队列继续运行。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">dispatch_suspend(queue);</div><div class="line">dispatch_resume(queue);</div></pre></td></tr></table></figure>
<p>要注意的是，暂停只会禁止执行还未开始执行的任务，已经处于执行中的任务无法暂停。在队列恢复运行后，未开始执行的任务就可以正常执行了。</p>
<h3 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h3><p>当你需要对一小部分间隔时间较短的任务做并发控制的时候，信号量(Semaphore)会比串行队列或者<code>dispatch_barrier_async</code>更好用。</p>
<p>前面我们有提到，并发读取或更新数据时很容易造成数据冲突或者程序崩溃。你可以用串行队列或者<code>dispatch_barrier_async</code>函数来避免这种问题。但是有时需要在很短的时间间隔里做一些并发控制。比如，下面这个例子。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="built_in">NSMutableArray</span> *array = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) </div><div class="line">&#123; </div><div class="line">	<span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">		[array addObject:[<span class="built_in">NSNumber</span> numberWithInt:i]];</div><div class="line">	&#125;); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子中，在一个全局并发队列上向数组中加入数据，会有多个线程同时操作数组。由于NSMutableArrary并不支持多线程，因此当多个线程同时操作数组的时候，可能会扰乱数组中的数据。这种情况，我们可以用dispatch semaphore来解决。</p>
<p>Dispatch semaphore是一个带有计数器的信号量。这就是多线程编程中所谓的计数器信号量。信号量有点像一个交通信号标志，标志起来的时候你可以走，标准落下的时候你要停下来。Dispatch semaphore用计数器来模拟这种标志。计数器为0，队列暂停执行新任务并等待信号；当计数器超过0后，队列继续执行新任务，并减少计数器。</p>
<p>要创建一个dispatch semaphore，用<code>dispatch_semaphore_create</code>函数。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>函数的参数是指计数器的初始计数。同样，因为函数名字中有”create”单词，用这个函数创建的对象，在你不需要它之后，要用<code>dispatch_release</code>释放掉。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div></pre></td></tr></table></figure>
<p><code>dispatch_semaphore_wait</code>函数用于等待一个信号量。当信号量的计数器变成1(及以上)数字后，函数停止等待，使计数器减1，并返回。函数的第二个参数是指定的等待时间，<code>dispatch_time_t</code>类型。<code>dispatch_semaphore_wait</code>函数的返回值和<code>dispatch_group_wait</code>函数的返回值类型一样，不同的返回值代表了不同的结果。如下代码所示。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, <span class="number">1</span>ull * <span class="built_in">NSEC_PER_SEC</span>);</div><div class="line"><span class="keyword">long</span> result = dispatch_semaphore_wait(semaphore, time); </div><div class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) </div><div class="line">&#123;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 信号量计数器大于等于1。</div><div class="line"> * 或者在指定的等待时间超时前，信号量计数器变成了大于等于1的数字。</div><div class="line"> * 计数器会自动减一</div><div class="line"> *</div><div class="line"> * 在这里，可以安全地运行你的任务了。</div><div class="line"> */</div><div class="line">&#125; </div><div class="line"><span class="keyword">else</span> </div><div class="line">&#123;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 因为信号量计数器是0，就只能等待超时了。</div><div class="line"> * </div><div class="line"> * 这里处理等待超时的情况。</div><div class="line"> */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>dispatch_semaphore_wait</code>函数返回0的时候，可以安全的运行你的任务。任务完成后，要调用<code>dispatch_semaphore_signal</code>函数，使信号量的计数器加1。(译注: 这就有点类似于，-1表示你占用一份资源；用完后，+1表示你用完了，空余了一份资源出来。其他等待的人收到信号后，就可以用你这份空余的资源。)</p>
<p>现在再来看看前面那个例子中使用信号量是什么样的。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 创建一个信号量</div><div class="line"> * </div><div class="line"> * 将初始计数器设置为1， 使得一次只能有1个线程访问NSMutableArray对象。</div><div class="line"> */</div><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="built_in">NSMutableArray</span> *array = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) </div><div class="line">&#123; </div><div class="line">	<span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">		</div><div class="line">		<span class="comment">/*</span></div><div class="line">		 * 等待信号量</div><div class="line">		 *</div><div class="line">		 * 一直等待，直到信号量计数器大于等于1。</div><div class="line">		 */</div><div class="line">		dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line"></div><div class="line">		<span class="comment">/*</span></div><div class="line">		 * 因为信号量计数器&gt;=1，</div><div class="line">		 * dispatch_semaphore_wait函数停止等待，计数器自动-1，流程继续</div><div class="line">		 *</div><div class="line">		 * 此例中，到这里的时候，计数器始终会变成0。</div><div class="line">		 * 因为初始时为1，限定了一次只能有一个线程访问NSMutableArray对象。</div><div class="line">		 * </div><div class="line">		 * 现在，在这里，你可以安全地更新数组了。</div><div class="line">		 */</div><div class="line">		[array addObject:[<span class="built_in">NSNumber</span> numberWithInt:i]];</div><div class="line"></div><div class="line">		<span class="comment">/*</span></div><div class="line">		 * 任务完成后，要调用dispatch_semaphore_signal函数，使计数器+1</div><div class="line">		 * 如果还有其他线程在等待信号量，第一个进入等待状态的线程得到通知后就可以开始了运行了。</div><div class="line">		 */</div><div class="line">		dispatch_semaphore_signal(semaphore);</div><div class="line">	)&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 如果不再需要这个信号量了，要将它释放掉.</div><div class="line"> */</div><div class="line">dispatch_release(semaphore);</div></pre></td></tr></table></figure>
<h3 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h3><p><code>dispatch_once</code>函数用于确保一个任务在整个程序运行过程中，只会被执行一次。下面的代码是初始化一个对象时的典型做法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> initialized = <span class="literal">NO</span>;</div><div class="line"><span class="keyword">if</span> (initialized == <span class="literal">NO</span>) </div><div class="line">&#123;</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 初始化操作</div><div class="line">	 */</div><div class="line">	</div><div class="line">	initialized = <span class="literal">YES</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果用<code>dispatch_once</code>函数来实现就更简洁了。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> pred; </div><div class="line"><span class="built_in">dispatch_once</span>(&amp;pred, ^&#123;</div><div class="line">	<span class="comment">/*</span></div><div class="line"> 	 * 初始化操作 </div><div class="line">	 */</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>两种方式没有多少差别。前面一种，在大多数情况下是安全的，但在多核CPU上时，“initialized”变量可能在被重新赋值的同时又在被读取，这会导致初始化操作被执行多次。然而如果你用<code>dispatch_once</code>来实现的话，就没有这种担忧了，代码在多线程环境中也是安全的。因此在创建一个单例对象时，<code>dispatch_once</code>函数很有用。</p>
<h3 id="Dispatch-I-O"><a href="#Dispatch-I-O" class="headerlink" title="Dispatch I/O"></a>Dispatch I/O</h3><p>读取一个大文件的时候，你可能会想到，如果将文件分成若干小块再用全局队列并发读取，这样会比正常情况下一次性读取整个文件快很多。对于目前的I/O硬件来说，并发读取可能确实会比单线程读取要快。要想获得更快的读取速度，可以使用Dispatch I/O和Dispatch Data。当你使用Dispatch I/O读写文件的时候，文件会被分成某个固定大小的文件块，你可以在一个全局队列上访问它们。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;<span class="comment">/* 读取文件的 0 至 8191 字节。 */</span>&#125;); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;<span class="comment">/* 读取文件的 8192 至 16383 字节。 */</span>&#125;); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;<span class="comment">/* 读取文件的 16384 至 24575 字节 */</span>&#125;); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;<span class="comment">/* 读取文件的 24576 至 32767 字节 */</span>&#125;); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;<span class="comment">/* 读取文件的 32768 至 40959 字节 */</span>&#125;); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;<span class="comment">/* 读取文件的 40960 至 49151 字节 */</span>&#125;); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;<span class="comment">/* 读取文件的 49152 至 57343 字节 */</span>&#125;); </div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;<span class="comment">/* 读取文件的 57344 至 65535 字节 */</span>&#125;);</div></pre></td></tr></table></figure>
<p>如代码中所示，读取操作会分块进行。用Dispatch Data很容易将读取到的数据组合起来。如下，苹果官方的dispatch I/O和dispatch data例子。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">pipe_q = dispatch_queue_create(<span class="string">"PipeQ"</span>, <span class="literal">NULL</span>);</div><div class="line">pipe_channel = dispatch_io_create(DISPATCH_IO_STREAM, fd, pipe_q, ^(<span class="keyword">int</span> err)&#123;</div><div class="line">	close(fd);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">*out_fd = fdpair[<span class="number">1</span>];</div><div class="line"></div><div class="line">dispatch_io_set_low_water(pipe_channel, SIZE_MAX);</div><div class="line"></div><div class="line">dispatch_io_read(pipe_channel, <span class="number">0</span>, SIZE_MAX, pipe_q, ^(<span class="keyword">bool</span> done, dispatch_data_t pipedata, <span class="keyword">int</span> err)&#123;</div><div class="line">	<span class="keyword">if</span> (err == <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		size_t len = dispatch_data_get_size(pipedata); </div><div class="line">		<span class="keyword">if</span> (len &gt; <span class="number">0</span>)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">const</span> <span class="keyword">char</span> *bytes = <span class="literal">NULL</span>; </div><div class="line">			<span class="keyword">char</span> *encoded;</div><div class="line">			dispatch_data_t md = dispatch_data_create_map(pipedata, (<span class="keyword">const</span> <span class="keyword">void</span> **)&amp;bytes, &amp;len);</div><div class="line">			encoded = asl_core_encode_buffer(bytes, len); </div><div class="line">			asl_set((aslmsg)merged_msg, ASL_KEY_AUX_DATA, encoded);</div><div class="line">			free(encoded);</div><div class="line">			_asl_send_message(<span class="literal">NULL</span>, merged_msg, <span class="number">-1</span>, <span class="literal">NULL</span>);</div><div class="line">			asl_msg_release(merged_msg);</div><div class="line">			dispatch_release(md); </div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (done)</div><div class="line">	&#123;</div><div class="line">		dispatch_semaphore_signal(sem); </div><div class="line">		dispatch_release(pipe_channel); </div><div class="line">		dispatch_release(pipe_q);</div><div class="line">	&#125; </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这是来自苹果的系统日志API(Libc-763.11 gen/asl.c)的源代码。<code>dispatch_io_create</code>函数创建了一个dispatch I/O。它指定了一个会在发生错误的时候被执行的block，以及执行block的队列。<code>dispatch_io_set_low_water</code>函数指定了每次读取操作最多可以读取的数据长度(数据会按这个尺寸分块)。<code>dispatch_io_read</code>函数在全局队列上开启读取操作。每当一块数据被读取后，数据作为参数会被传递给<code>dispatch_io_read</code>的回调函数，因此，block就可以扫描或组合数据了。</p>
<p>如果你想读取文件的时候速度快些，就试试用dispatch I/O吧。</p>
<p>译自: <a href="http://www.amazon.com/Pro-Multithreading-Memory-Management-iOS/dp/1430241160" target="_blank" rel="external">《Pro Multithreading and Memory Management for iOS and OS X with ARC, Grand Central Dispatch, and Blocks》</a>第7章</p>
<p style="text-align:center"><img src="/images/posts/thx_money.png" width="50%" height="50%"></p>


]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Dispatch-Queue的一些函数&quot;&gt;&lt;a href=&quot;#Dispatch-Queue的一些函数&quot; class=&quot;headerlink&quot; title=&quot;Dispatch Queue的一些函数&quot;&gt;&lt;/a&gt;Dispatch Queue的一些函数&lt;/h2&gt;&lt;p&gt;GCD还提供了许多很有用的API用于控制队列中的任务。接下来，我们挨个看看这些API，你就明白为什么GCD如此强大。&lt;/p&gt;
&lt;h3 id=&quot;dispatch-set-target-queue&quot;&gt;&lt;a href=&quot;#dispatch-set-target-queue&quot; class=&quot;headerlink&quot; title=&quot;dispatch_set_target_queue&quot;&gt;&lt;/a&gt;dispatch_set_target_queue&lt;/h3&gt;&lt;p&gt;&lt;code&gt;dispatch_set_target_queue&lt;/code&gt;函数用于设置一个”目标”队列。这个函数主要用来为新创建的队列设置优先级。当用&lt;code&gt;dispatch_queue_create&lt;/code&gt;函数创建一个队列后，无论创建的是并行队列还是串行队列，队列的优先级都和全局队列的默认优先级一样。创建队列后，你可以用这个函数来修改队列的优先级。下面的代码演示了如何给一个串行队列设置background优先级。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;dispatch_queue_t&lt;/span&gt; mySerialDispatchQueue =&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	dispatch_queue_create(&lt;span class=&quot;string&quot;&gt;&quot;com.example.gcd.MySerialDispatchQueue&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;dispatch_queue_t&lt;/span&gt; globalDispatchQueueBackground =&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;dispatch_set_target_queue(mySerialDispatchQueue, globalDispatchQueueBackground);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Objc" scheme="http://blog.morefun.mobi/categories/Objc/"/>
    
      <category term="GCD" scheme="http://blog.morefun.mobi/categories/Objc/GCD/"/>
    
      <category term="翻译" scheme="http://blog.morefun.mobi/categories/Objc/GCD/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>GCD使用详解 上篇</title>
    <link href="http://blog.morefun.mobi/2013/05/07/2013-05-07-gcdshi-yong-xiang-jie-shang-pian/"/>
    <id>http://blog.morefun.mobi/2013/05/07/2013-05-07-gcdshi-yong-xiang-jie-shang-pian/</id>
    <published>2013-05-07T06:46:00.000Z</published>
    <updated>2017-08-13T08:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dispatch-Queues"><a href="#Dispatch-Queues" class="headerlink" title="Dispatch Queues"></a>Dispatch Queues</h2><p>Dispatch Queue，顾名思义，它是一个队列，用于存储要执行的任务。程序员可以用block语法编写要执行的任务，再通过<code>dispatch_async</code>函数将它加入到一个dispatch队列中。然后dispatch队列会按照FIFO的顺序执行这些任务。如图7-1所示。</p>
<p><img src="/images/posts/GCD7-1_execution_on_a_dispatch_queue.png" alt=""></p>
<p>GCD中有2种dispatch队列。一种是串行队列，队列中前一个任务执行完毕后，后一个任务才开始执行。另一种是并行队列，并行队列可以同时执行多个任务。如图7-2所示。</p>
<a id="more"></a>
<p><img src="/images/posts/GCD7-2_Serial_Dispatch_Queue_and_Concurrent_Dispatch_Queue.png" alt=""></p>
<h4 id="两种类型的Dispatch队列"><a href="#两种类型的Dispatch队列" class="headerlink" title="两种类型的Dispatch队列"></a>两种类型的Dispatch队列</h4><p>下面的代码用<code>dispatch_async</code>函数将任务添加到dispatch队列中。以这段代码为例，我们来对比一下这两种类型的队列有什么不同。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(queue, blk0);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk1);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk2);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk3);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk4);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk5);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk6);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, blk7);</div></pre></td></tr></table></figure>
<p>我们先来看看，当队列是串行队列时，这些任务是如何执行的呢。</p>
<h4 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h4><p>首先blk0开始执行。blk0完成后，blk1开始执行。然后blk1完成后，blk2开始执行，如此顺序执行，一次只执行一个任务。因此，每次都会按照下面这种顺序执行：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">blk0</div><div class="line">blk1</div><div class="line">blk2</div><div class="line">blk3</div><div class="line">blk4</div><div class="line">blk5</div><div class="line">blk6</div><div class="line">blk7</div></pre></td></tr></table></figure>
<p>接下来，我们再来看看并行队列是如何执行这些任务的。</p>
<h4 id="并行队列"><a href="#并行队列" class="headerlink" title="并行队列"></a>并行队列</h4><p>首先，blk0开始执行，不管它是否已经完成，blk1也会开始执行，然后不管blk1是否已经完成，blk2也会开始执行，以类似的方式执行下去，同时会有多个任务在执行。同时能够执行的任务的个数取决于当前的系统状态。iOS或者OS X系统会根据当前的系统状态（例如队列中有多少个任务，CPU的核心数目或者CPU的使用情况）决定可以同时执行多少个任务。如图7-3所示，任务可以在多个线程上并发执行。</p>
<p><img src="/images/posts/GCD7–3_Relationship_of_Serial_Dispatch_Queue_Concurrent_Dispatch_Queue_and_threads.png" alt=""></p>
<p>XNU内核(iOS和OS X的核心部件)会决定线程的个数，也负责创建用于执行任务的线程。当一个任务完成后，处于运行状态的任务的数目就会减少，XNU内核会终止不再需要的的线程。通过并行队列，XNU内核管理多线程，完美的并发运行各个任务。表格7-1，显示了上面的代码在多线程上的执行的情况。</p>
<p><img src="/images/posts/Table7–1_Theexampleresultwithaconcurrentdispatchqueue.png" alt=""></p>
<p>这里，我们假设并行队列有4个线程。首先线程0开始执行blk0。接着，线程1开始执行blk1，线程2开始执行blk2，线程3开始执行blk3。然后，线程0上blk0执行完毕后，blk4开始执行。接着，线程2开始执行blk5，因为线程2上的blk2已经执行完毕了，但是线程1上的blk1仍然在运行。</p>
<p>这种方式下，并行队列中任务的执行顺序取决于任务本身的状态和系统状态等因素。执行顺序并不会像串行队列那样总是固定不变的。如果任务需要按照特定的顺序执行或者不想让任务并发执行，那应当使用串行队列。</p>
<p>那么我们如何获得这些队列呢？</p>
<h2 id="获取Dispatch队列"><a href="#获取Dispatch队列" class="headerlink" title="获取Dispatch队列"></a>获取Dispatch队列</h2><p>有2种途径获得dispatch队列。一种是通过<code>dispatch_queue_create</code>函数创建一个队列；另一种是直接获取现成的主线程队列或者全局队列。</p>
<h4 id="dispatch-queue-create"><a href="#dispatch-queue-create" class="headerlink" title="dispatch_queue_create"></a>dispatch_queue_create</h4><p><code>dispatch_queue_create</code>这个函数用于创建一个dispatch队列。你可以用这个函数创建一个新的队列。下面的代码演示了如何创建一个串行队列。当然，也可以用它创建一个并行队列，稍后会作讲解。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> mySerialDispatchQueue =</div><div class="line">	dispatch_queue_create(<span class="string">"com.example.gcd.MySerialDispatchQueue"</span>, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure>
<p>创建一个串行队列后，它和其他串行队列是相互独立的，虽然它们都是一次只执行一个任务。例如，四个串行队列，可能同时开始执行任务，但它们是相互独立的。如图7-4所示。</p>
<p><img src="/images/posts/Figure7–4MultipleSerialDispatchQueues.png" alt=""></p>
<p>还有要特别注意的一点。当一个串行队列被创建，并向其中加入一个任务后，系统会为队列创建一个线程。每一个串行队列都有一个线程。如果创建了2000个串行队列，就会有2000个线程。这样，大量的线程会耗费大量的内存，也会因为需要大量切换上下文环境而拖慢系统速度。</p>
<p><img src="/images/posts/Figure7–5_Problem_of_multiple_Serial_Dispatch_Queues.png" alt=""></p>
<p>因此，你应该只在需要防止数据冲突的情况下才使用串行队列。因为，多线程更新数据时会有资源竞争(race condition)问题，这也是多线程编程中的一个常见问题。</p>
<p><img src="/images/posts/Figure_7–6_Situation_where_a_Serial_Dispatch_Queue_should_be_used.png" alt=""></p>
<p>串行队列应该是需要多少个才创建多少个。例如，当更新数据库的时候，应该为每一个表创建一个串行队列。当更新文件的时候，应该为文件创建一个串行队列或者为每个独立文件块创建一个串行队列。即使你可能会认为可以依靠串行队列来创建比并行队列更多的线程，也不要创建过多的串行队列。如果要执行的任务不会造成像数据冲突这种问题并且你想要并发的执行它们，你应该使用并行队列。即使不断的创建并发队列，也不会有什么问题，因为并发队列只会使用由XNU内核管理的线程。</p>
<p>回到<code>dispatch_queue_create</code>函数上来。函数的第一个参数是队列的名字，建议这个参数使用像示例代码中那样的反向全称域名。当你用Xcode或Instruments调试的时候，队列的名称会显示成这个参数的值。同样CrashLog中也会显示这个队列名字。因此，应该用一个开发人员所能够理解的名字来命名它。如果不想给它命名，直接设置成NULL也可以，但这样不利于调试。</p>
<p>第二个参数，如果要创建一个串行队列，就将其设置成NULL。如果要创建一个并行队列，就设置成DISPATCH_QUEUE_CONCURRENT，如下所示。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> myConcurrentDispatchQueue =</div><div class="line">	dispatch_queue_create( <span class="string">"com.example.gcd.MyConcurrentDispatchQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<p><code>dispatch_queue_create</code>函数的返回值是一个<code>dispatch_queue_t</code>类型的值。前面所有的例子中，队列都是<code>dispatch_queue_t</code>类型。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> myConcurrentDispatchQueue =</div><div class="line">	dispatch_queue_create( <span class="string">"com.example.gcd.MyConcurrentDispatchQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(myConcurrentDispatchQueue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"block on myConcurrentDispatchQueue"</span>);&#125;);</div></pre></td></tr></table></figure>
<p>这个例子中，block会运行在并行队列上。</p>
<p>虽然编译器有一个很强大的自动内存管理机制(ARC)，但是程序员还是要自己负责释放自己创建的dispatch队列。因为，与block不同的是，dispatch队列不会被当成一个Objective-C对象。当你不再需要它们的时候，你需要调用<code>dispatch_release</code>函数来释放它们。（<strong>译注: 注意iOS6.0以后，ARC已经可以自动管理dispatch对象的释放了。</strong>）</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">dispatch_release(mySerialDispatchQueue);</div></pre></td></tr></table></figure>
<p>同样，也有retain的函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">dispatch_retain(myConcurrentDispatchQueue);</div></pre></td></tr></table></figure>
<p>也就是说，在Objective-C中，要用引用计数技术来管理dispatch队列的内存。比如，前面例子中创建的并发队列”myConcurrentDispatchQueue”也需要释放掉。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> myConcurrentDispatchQueue =</div><div class="line">	dispatch_queue_create( <span class="string">"com.example.gcd.MyConcurrentDispatchQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="built_in">dispatch_async</span>(myConcurrentDispatchQueue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"block on myConcurrentDispatchQueue"</span>);&#125;);</div><div class="line">dispatch_release(myConcurrentDispatchQueue);</div></pre></td></tr></table></figure>
<p>一个并行队列会用多个线程来执行任务。在这个例子中，把任务加入队列后，队列就被释放了。那么这样会不会有问题？</p>
<p>没问题的。当一个block被加入到队列后，block会用<code>dispatch_retain</code>函数retain队列，这样block就拥有了队列的所有权。不管是串行队列还是并行队列，都会这样。然后当block执行完毕后，block会通过<code>dispatch_release</code>函数释放掉对队列的所有权。</p>
<p>即使刚刚将block加入到队列后就将队列释放掉了，block稍后也会被执行。block执行完毕后，会释放掉队列，block也会被丢弃掉。<code>dispatch_retain</code>函数和<code>dispatch_release</code>函数不仅仅只用来管理队列。接下来我们会见到许多带有create单词的GCD函数，所有这种函数返回的对象都需要用<code>dispatch_release</code>函数来释放。如果你通过其他函数获得了某个对象，根据需要也可以用<code>dispatch_retain</code>来获得对象的所有权，然后不需要了就用<code>dispatch_release</code>来释放掉所有权。</p>
<h4 id="主线程队列和全局队列"><a href="#主线程队列和全局队列" class="headerlink" title="主线程队列和全局队列"></a>主线程队列和全局队列</h4><p>另外一种获得dispatch队列的途径是直接获取系统已经创建好的队列。系统有两种不需要你创建的队列：主线程队列和全局队列。</p>
<p>主线程队列中的所有任务都在主线程上执行。因为只有一个主线程，因此主线程队列是一个串行队列。如图7-7所示，主线程队列中的任务会在主线程上的RunLoop中执行。因为是执行在主线程上，因此你应当只用它来执行必须在主线程中执行的操作，比如更新UI的操作。它和NSObject的<code>performSelectorOnMainThread</code>方法很像。</p>
<p><img src="/images/posts/Figure7–7Main-Dispatch-Queue.png" alt=""></p>
<p>系统还提供了另外一种被称为全局队列(global dispatch queues)的队列。这种队列是并行队列，可以在应用程序的任何地方使用它们。大多数情况下，如果没有特殊原因(稍后会提到一些特殊情况)，你都不需要用<code>dispatch_create</code>函数来创建一个新的并行队列。你可以直接获取系统提供的全局队列，直接使用。全局队列有4种不同的优先级：high、default、low、background。XNU内核会管理全局队列用到的线程以及它们的优先级。在添加任务到一个全局队列的时候，要选择一个优先级适合的队列。XNU并不能保证线程的实时性，优先级只是用作一个参考。比如，如果你不太在乎一个任务是否会被执行，就应该用background这个优先级。表7-2中列出了系统提供的几种队列。</p>
<p><img src="/images/posts/Table7–2Types-of-dispatch-queues.png" alt=""></p>
<p>以下代码演示了如何获取这些队列。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取主线程队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> mainDispatchQueue = dispatch_get_main_queue();</div><div class="line"></div><div class="line"><span class="comment">// 获取high优先级的全局队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> globalDispatchQueueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 获取default优先级的全局队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> globalDispatchQueueDefault = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 获取low优先级的全局队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> globalDispatchQueueLow = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 获取background优先级的全局队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>顺便提一下，如果你在主线程队列或者全局队列上调用<code>dispatch_retain</code>函数或者<code>dispatch_release</code>函数，是没有任何作用的，也不会引起任何问题。这也是为什么直接使用全局队列会比创建一个新队列更方便的原因。当然，也取决于你的代码，如果你觉得把主线程队列或者全局队列看待成是由<code>dispatch_queue_create</code>函数创建的更方便的话，也可以依照引用计数的规则用<code>dispatch_retain</code>和<code>dispatch_release</code>函数来管理它们。</p>
<p>最后，让我们来看一个如何使用主线程队列和全局队列的例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">* 在优先级为default的全局dispatch队列上执行一个block</div><div class="line">*/</div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">	<span class="comment">/*</span></div><div class="line">	* 这里，是一些需要并发的执行的任务</div><div class="line">	*/</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	* 然后，在主线程队列上执行了一个block</div><div class="line">	*/</div><div class="line">	<span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	* 这里，是一些会在主线程上面执行的操作.</div><div class="line">	*/</div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>现在，我们已经学习了GCD的基础知识。接下来，我会介绍一些API，通过这些API我们可以更好的管理GCD队列，使它们更高效。</p>
<p>译自:  《<a href="http://www.amazon.com/Pro-Multithreading-Memory-Management-iOS/dp/1430241160" target="_blank" rel="external">Pro Multithreading and Memory Management for iOS and OS X with ARC, Grand Central Dispatch, and Blocks”</a>》 第7章</p>
<p style="text-align:center"><img src="/images/posts/thx_money.png" width="50%" height="50%"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Dispatch-Queues&quot;&gt;&lt;a href=&quot;#Dispatch-Queues&quot; class=&quot;headerlink&quot; title=&quot;Dispatch Queues&quot;&gt;&lt;/a&gt;Dispatch Queues&lt;/h2&gt;&lt;p&gt;Dispatch Queue，顾名思义，它是一个队列，用于存储要执行的任务。程序员可以用block语法编写要执行的任务，再通过&lt;code&gt;dispatch_async&lt;/code&gt;函数将它加入到一个dispatch队列中。然后dispatch队列会按照FIFO的顺序执行这些任务。如图7-1所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/GCD7-1_execution_on_a_dispatch_queue.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;GCD中有2种dispatch队列。一种是串行队列，队列中前一个任务执行完毕后，后一个任务才开始执行。另一种是并行队列，并行队列可以同时执行多个任务。如图7-2所示。&lt;/p&gt;
    
    </summary>
    
      <category term="Objc" scheme="http://blog.morefun.mobi/categories/Objc/"/>
    
      <category term="GCD" scheme="http://blog.morefun.mobi/categories/Objc/GCD/"/>
    
      <category term="翻译" scheme="http://blog.morefun.mobi/categories/Objc/GCD/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>在init和dealloc中使用accessor</title>
    <link href="http://blog.morefun.mobi/2013/04/24/2013-04-24-guan-yu-bu-yao-zai-inithe-deallocli-mian-shi-yong-accessor-de-wen-ti/"/>
    <id>http://blog.morefun.mobi/2013/04/24/2013-04-24-guan-yu-bu-yao-zai-inithe-deallocli-mian-shi-yong-accessor-de-wen-ti/</id>
    <published>2013-04-24T08:23:00.000Z</published>
    <updated>2017-06-16T16:05:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>过去几年Cocoa社区已经发生了很大变化。曾经，在init/dealloc中使用accessor方法是很令人厌恶的，这种做法彻底地被认为是错误的。他们的说法是：最好直接操作实例变量，而不使用accessor方法。并且建议像这样写代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithWhatever:(<span class="keyword">id</span>)whatever</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>((<span class="keyword">self</span> = [<span class="keyword">self</span> init]))</div><div class="line">    &#123;</div><div class="line">        _whatever = [whatever <span class="keyword">retain</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    [_whatever release];</div><div class="line"></div><div class="line">    [<span class="keyword">super</span> dealloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>与之对应，使用accessor的版本，是这样的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithWhatever:(<span class="keyword">id</span>)whatever</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>((<span class="keyword">self</span> = [<span class="keyword">self</span> init]))</div><div class="line">    &#123;</div><div class="line">        [<span class="keyword">self</span> setWhatever:whatever];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> setWhatever: <span class="literal">nil</span>];</div><div class="line"></div><div class="line">    [<span class="keyword">super</span> dealloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="accessor的优点"><a href="#accessor的优点" class="headerlink" title="accessor的优点"></a>accessor的优点</h3><p>与在其他任何地方使用accessor一样，在init/dealloc中使用accessor有这样一些优点：它们使你的代码与实现解耦，并且还可以减轻你在内存管理方面的工作。</p>
<p>回忆一下，多少次你意外的把代码写成这样了：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)init</div><div class="line">&#123;</div><div class="line">    _ivar = [<span class="built_in">NSArray</span> arrayWithObjects:...];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我想答案可能各异(我已经很久没有犯过这种错误了)，但是使用accessor可以确保你不会犯这种错误：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)init</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> setIvar: [<span class="built_in">NSArray</span> arrayWithObjects:...]];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此外，你也许有一些附属状态(像缓存，统计等等这些)需要在对象的值变化时进行设置或者关闭。正确的使用accessor可以保证不需要过多重复的代码，所有的这些都能够在对象被创建时或被销毁时正常的工作。(译注类似KVO这种情形)</p>
<h3 id="accessor的缺点"><a href="#accessor的缺点" class="headerlink" title="accessor的缺点"></a>accessor的缺点</h3><p>使用accessor的缺点可以简单的总结成一句话：有副作用。有时候这些副作用会在init/dealloc中产生不良影响。</p>
<p>在写一个setter方法的时候，如果你打算在init/dealloc里面调用它，要确保它的行为正确。这意味着要处理对象没有完全被创建时的情况。</p>
<p>更糟糕的情况是，如果你一旦要在子类中重写setter方法，你需要将它写成能够处理父类用它来初始化或销毁实例变量的情况。比如，这段看上去很正常的代码却有潜在的危险：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setSomeObj:(<span class="keyword">id</span>)obj</div><div class="line">&#123;</div><div class="line">    [anotherObj notifySomething];</div><div class="line">    [<span class="keyword">super</span> setSomeObj:obj];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    [anotherObj release];</div><div class="line">    [<span class="keyword">super</span> dealloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果父类用setter方法来销毁someObj，就会在dealloc中<code>[anotherObj release]</code>已经执行后再执行子类重写的那个版本的setter方法。重载的setter方法就会去操作一个野指针，很可能就会来一个漂亮的崩溃。</p>
<p>要优雅地修正这个问题不是很难。在dealloc中释放后将anotherObj指向nil就行了。一般情况下，要使你的重载行为保持正常并不是很困难，但是如果你要这样用accessor，那么一定要记住这一点。</p>
<h3 id="键-值观察者-KVO"><a href="#键-值观察者-KVO" class="headerlink" title="键-值观察者(KVO)"></a>键-值观察者(KVO)</h3><p>这类讨论中经常提到的一个话题就是键-值观察者，因为accessor的副作用通常都是KVO引起的。当对象没有被完全创建时或者已经被销毁后，KVO的调用就会带来不幸的事情。但是我个人认为这是一个不靠谱的说法。</p>
<p>因为99%的情况下都是，只有一个对象被完全创建后KVO才能被设置到对象上，并且会在对象被销毁前撤销掉。实际情况下，KVO不太可能会在对象创建前就被激活或者对象销毁后才被终止。</p>
<p>在对象被完全初始化前，外部代码不可能对对象做任何操作。除非你的初始化方法自己要把指针到处传递给外部对象。同样，当你的对象正在执行dealloc方法的时候，外部对象也不可能继续保持对你的对象的KVO引用。父类的代码确实会在这个时候执行，但是父类的代码不太可能会导致外部对象可以观察一个它自己甚至都没有的属性。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>现在优点和缺点都知道了，你会在init和dealloc中使用accessor吗？在我看来，都可以。用，也没太大的优势；不用，也没什么缺点。大多数的实例变量我都没用accessor方法。但是在某些特定情况下，在对变量做了一些特殊处理的时候，这些情况下使用accessor会带来显著好处的时候，我会毫不犹豫地使用accessor，少些烦恼。</p>
<p>原文：<a href="http://www.mikeash.com/pyblog/friday-qa-2009-11-27-using-accessors-in-init-and-dealloc.html" target="_blank" rel="external">Friday Q&amp;A 2009-11-27: Using Accessors in Init and Dealloc</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过去几年Cocoa社区已经发生了很大变化。曾经，在init/dealloc中使用accessor方法是很令人厌恶的，这种做法彻底地被认为是错误的。他们的说法是：最好直接操作实例变量，而不使用accessor方法。并且建议像这样写代码：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)initWithWhatever:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)whatever&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;((&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; init]))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        _whatever = [whatever &lt;span class=&quot;keyword&quot;&gt;retain&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)dealloc&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [_whatever release];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; dealloc];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Objc" scheme="http://blog.morefun.mobi/categories/Objc/"/>
    
      <category term="翻译" scheme="http://blog.morefun.mobi/categories/Objc/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>给阴影设置shadowPath的重要性</title>
    <link href="http://blog.morefun.mobi/2013/04/19/2013-04-19-she-zhi-yin-ying-lu-jing-de-zhong-yao-xing/"/>
    <id>http://blog.morefun.mobi/2013/04/19/2013-04-19-she-zhi-yin-ying-lu-jing-de-zhong-yao-xing/</id>
    <published>2013-04-19T02:46:00.000Z</published>
    <updated>2017-06-16T16:04:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS中，给视图加阴影很容易，只需要：</p>
<ol>
<li>项目中引入QuartzCore框架</li>
<li>实现文件中import QuartzCore的头文件</li>
<li>然后仅需一行代码<code>[myView.layer setShadowOpacity:0.5]</code></li>
</ol>
<p><img src="https://markpospesel.files.wordpress.com/2012/04/shadow1.png?w=584" alt="image">  </p>
<p>然而，最简单的方法通常都不是性能最好的方法。<br><a id="more"></a></p>
<p>如果再用这个视图作动画(特别当它是UITableViewCell的一部分的时候)，你可能会注意到动画的卡顿。这是因为在计算视图阴影的时候，为了计算出怎样渲染视图的阴影，Core Animation需要做一次离屏渲染才能确定视图的形状。</p>
<p>为了证明这一点。现在打开模拟器，勾选上「Debug」菜单中的「Color Off-screen Rendered」选项。</p>
<p><img src="https://markpospesel.files.wordpress.com/2012/04/simulator-menu.png?w=584" alt="image"></p>
<p>或者，接上iOS设备，启动Instruments(⌘I)，选择Core Animation模板，选中Core Animation栏，勾上”Color Offscreen-Rendered Yellow”选项。</p>
<p><img src="https://markpospesel.files.wordpress.com/2012/04/instruments.png?w=584" alt="IMAGE"></p>
<p>之后在模拟器（或设备）上，会看到类似下面的画面：</p>
<p><img src="https://markpospesel.files.wordpress.com/2012/04/offscreen-rendered1.png?w=584" alt="IMAGE"></p>
<p>这表明某些东西（在我们这个例子中就是阴影）造成了一个昂贵的离屏渲染。</p>
<h3 id="快速修正"><a href="#快速修正" class="headerlink" title="快速修正"></a>快速修正</h3><p>幸运地是，修正阴影的这个性能问题和添加阴影一样简单。只需告诉Core Animation视图是什么形状的就行了。使用view.layer的<code>setShadowPath:</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[myView.layer setShadowPath:[[UIBezierPath bezierPathWithRect:myView.bounds] CGPath]];</div></pre></td></tr></table></figure>
<p>(注意：因为视图不同的形状，这里代码可能有所不同。UIBezierPath有许多便捷的方法可以调用。比如你的视图有圆角，可以使用<code>bezierPathWithRoundedRect:cornerRadius:</code>方法。)</p>
<p>现在再测试一下，指示离屏渲染内容的黄色区块应该消失了吧。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>当视图的bounds变化后，你需要更新layer的shadowPath。同样，如果你要做一个bounds变化的动画，也需要给layer的shadowPath做动画来匹配bounds的变化。给layer的shadowPath做动画需要用到CAAnimation，因为UIView不能直接对shadowPath做动画(shadowPath是CALayer的属性)。用CAKeyframeAnimation可以很简单地对shadowPath做一个动画，只需从一个CGPath变化到另一个CGPath就可以了。</p>
<p>原文: <a href="http://markpospesel.wordpress.com/2012/04/03/on-the-importance-of-setting-shadowpath/" target="_blank" rel="external">On the importance of setting shadowPath</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS中，给视图加阴影很容易，只需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目中引入QuartzCore框架&lt;/li&gt;
&lt;li&gt;实现文件中import QuartzCore的头文件&lt;/li&gt;
&lt;li&gt;然后仅需一行代码&lt;code&gt;[myView.layer setShadowOpacity:0.5]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://markpospesel.files.wordpress.com/2012/04/shadow1.png?w=584&quot; alt=&quot;image&quot;&gt;  &lt;/p&gt;
&lt;p&gt;然而，最简单的方法通常都不是性能最好的方法。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://blog.morefun.mobi/categories/iOS/"/>
    
      <category term="性能" scheme="http://blog.morefun.mobi/categories/iOS/%E6%80%A7%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>高效的ARC代码和陷阱</title>
    <link href="http://blog.morefun.mobi/2012/12/05/2012-12-05-effective-obj-c-arc-and-pitfalls-in-it/"/>
    <id>http://blog.morefun.mobi/2012/12/05/2012-12-05-effective-obj-c-arc-and-pitfalls-in-it/</id>
    <published>2012-12-05T02:00:00.000Z</published>
    <updated>2017-08-13T08:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C是一个非常酷的编程语言。<a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html" target="_blank" rel="external">TIOBE</a>已经公布了十一月的编程语言排行榜，Objective-C很可能会再次成为年度编程语言。Objective-C的流行不只是因为iOS和Mac OS X平台的原因，还得益于它在移动设备上的高性能。在Objective-C中，手动内存管理代替了垃圾回收机制。当然，现在Objective-C也不需要纯手动管理内存了，苹果引入了自动引用计数(Automatic Reference Counting, 简称ARC)机制，在编译时自动加入内存管理代码。大部分情况下，这非常棒。然而，当ARC和Core Foundation对象混用的时候，总是感觉很混乱。今天，我们聊聊ARC的要点和陷阱，尤其是用toll-free bridging将Objc对象和CF对象相互转换时的一些注意事项。<a id="more"></a></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>本文先简单的介绍一下ARC的两个主要的使用场景：Objective-C的property 和 ARC修饰符。然后再重点关注一下ARC与Core Foundation框架的内存管理问题。</p>
<h3 id="ARC-和-Objective-C的property"><a href="#ARC-和-Objective-C的property" class="headerlink" title="ARC 和 Objective-C的property"></a>ARC 和 Objective-C的property</h3><p>首先感谢一下，没有<a href="https://twitter.com/amattn" target="_blank" rel="external">@amattn</a>写的《ARC最佳实践》，就很难有这篇文章。点击这个链接查看<a href="http://amattn.com/2011/12/07/arc_best_practices.html" target="_blank" rel="external">ARC Best Practices</a>的原文。下面是我总结的文章中的重点：</p>
<ul>
<li><p>需要retain的实例变量对象，用 <code>strong</code>。</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> childObject;</div></pre></td></tr></table></figure>
</li>
<li><p>防止引用循环(reference cycle)，要用 <code>weak</code>。</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> delegate;</div></pre></td></tr></table></figure>
</li>
<li><p>基本数据类型，用 <code>assign</code>。</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> width;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> height;</div></pre></td></tr></table></figure>
</li>
<li><p>不可变的容器类型以及字符串和block，用 <code>copy</code>。要避免使用可变容器类型(比如：NSMutableArray这些…)作为property，如果要用可变的容器类型，就用 <code>strong</code>。</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>* name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>* components;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) (<span class="keyword">void</span> (^)(<span class="keyword">void</span>)) job;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span>* badPatterns;</div></pre></td></tr></table></figure>
</li>
<li><p>dealloc中</p>
<ul>
<li>移除观察者。</li>
<li>注销通知。</li>
<li><del>停掉timer。</del>(<strong>译注</strong>：因为系统会retain传递给timer的target对象，在timer停掉前，target对象是不会被dealloc的。 所以原文里的这点是错误的，<font color="red">别把停掉timer的操作放到dealloc中。</font>在确定不再需要当前这对象的时候，要主动停掉timer。)</li>
</ul>
</li>
<li><p>IBOutlets一般用 <code>weak</code>，除非它是文件的所有者(File’s Owner)在nib文件中的顶层对象。如果将它设置为strong了，就需要在<code>viewDidUnload</code>方法中将它设置为nil。</p>
<p>  (<strong>译注</strong>：<code>viewDidUnload</code>在iOS6.0以后没有了，要移到<code>didReciveMemoryWorning</code>中。详细请阅读苹果的《<a href="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/DefiningYourSubclass.html#//apple_ref/doc/uid/TP40007457-CH7-SW1" target="_blank" rel="external">View Controller Programming Guide for iOS</a>》)</p>
</li>
</ul>
<h3 id="ARC类型修饰符"><a href="#ARC类型修饰符" class="headerlink" title="ARC类型修饰符"></a>ARC类型修饰符</h3><p>类型修饰符的使用规则，可以看看我<a href="http://www.idryman.org/blog/2012/10/29/type-qualifiers/" target="_blank" rel="external">以前的一篇文章</a>。ARC相关的类型修饰符，有4个：</p>
<ul>
<li><code>__strong</code>表示到一个对象的强引用。只要有任意一个强引用指向对象，对象就不会被销毁。这个是ARC中所有对象的默认属性。</li>
<li><code>__weak</code>指定到一个对象的弱引用。弱引用不会使它指向的对象保持一直存在，当没有任何强引用指向这个对象后，对象会被释放，然后弱引用会指向nil。</li>
<li><code>__unsafe_unretained</code>指定到一个对象的弱引用，当它指向的对象被销毁后，它不会指向nil，就变成一个野指针了。</li>
<li><code>__autoreleasing</code>用来表示参数按引用传递，在函数返回后，这个参数就被自动释放了。</li>
</ul>
<p>注意，ARC类型修饰符只能用在指针上。也就是说，必须把修饰符放到星号的右边。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">MyClass * __<span class="keyword">weak</span> w_self = <span class="keyword">self</span>; <span class="comment">// 正确</span></div><div class="line">MyClass __<span class="keyword">weak</span> * w_self = <span class="keyword">self</span>; <span class="comment">// 错误! 可能导致很严重的bug!</span></div><div class="line">__<span class="keyword">weak</span> MyClass * w_self = <span class="keyword">self</span>; <span class="comment">// 错误!</span></div><div class="line"></div><div class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) w_self = <span class="keyword">self</span>;</div><div class="line"><span class="comment">// 正确，将会被展开为 __weak (MyClass *) w_self = self;</span></div><div class="line"><span class="comment">// (参见gcc的typeof说明)</span></div><div class="line"></div><div class="line"><span class="keyword">typeof</span>(<span class="keyword">self</span>) __<span class="keyword">weak</span> w_self = <span class="keyword">self</span>; <span class="comment">// 正确, 这个安全些</span></div></pre></td></tr></table></figure>
<p>等等，难道网上这么多写法都是错误的？哦，原来因为苹果官方文档里面提到：“你应该正确修饰变量。当修饰符用在对象变量上的时候，正确的格式是 <code>ClassName * qualifier variableName;</code> ”</p>
<blockquote>
<p>You should decorate variables correctly. When using qualifiers in an object variable declaration, the correct format is: <code>ClassName * qualifier variableName;</code></p>
</blockquote>
<h3 id="ARC-和-Toll-free绑定"><a href="#ARC-和-Toll-free绑定" class="headerlink" title="ARC 和 Toll-free绑定"></a>ARC 和 Toll-free绑定</h3><p>ARC和Core Foundation混用的时候坑最多。以下是一些重要的原则：</p>
<ul>
<li>传递Objc对象给一个CF引用时，要retain它。</li>
<li>传递一个CF引用给一个Objc对象时，要release它。</li>
<li>传递时如果不明确的指定对象的所有权，会很危险。有时Clang编译器会帮你修正，但不是总是会，这样就会造成很严重的问题。</li>
<li>Core Foundation里面没有autorelease。你必须遵守它的内存管理规则：<ul>
<li>名字中带有<code>Create</code>或<code>Copy</code>的函数返回的对象，你会持有它，因此你要负责释放它。</li>
<li>如果函数名字中是带的<code>get</code>，你不会持有它返回的对象，不需要你释放它。</li>
</ul>
</li>
</ul>
<p>ARC中有两种方法来retain一个CF对象：用类型转换符<code>(__bridge_retained)</code> 或者 C函数<code>CFBridgingRetain</code>。我更喜欢后者，因为代码简洁清晰。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">CFArrayRef</span> arr = <span class="built_in">CFBridgingRetain</span>( @[<span class="string">@"abc"</span>, <span class="string">@"def"</span>, @<span class="number">3.14</span>] );</div><div class="line"><span class="comment">// or CFArrayRef arr = (__bridge_retained CFArrayRef)@[...];</span></div><div class="line"><span class="comment">// do stuffs..</span></div><div class="line"><span class="built_in">CFRelease</span>(arr);</div></pre></td></tr></table></figure>
<p>当用Core Foundation中名字中带有Create或者Copy的方法获得一个对象的时候，用<code>(__bridge_transfor)</code>或者<code>CFBridgingRealease</code>来将对象的所有权转移给ARC，这样就能让ARC负责对象的释放。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)logFirstNameOfPerson:(ABRecordRef)person &#123;</div><div class="line">	<span class="built_in">NSString</span> *name = (<span class="built_in">NSString</span> *)<span class="built_in">CFBridgingRelease</span>(ABRecordCopyValue(person, kABPersonFirstNameProperty));</div><div class="line">	<span class="built_in">NSLog</span>(<span class="string">@"Person's first name: %@"</span>, name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Toll-free绑定的注意事项"><a href="#Toll-free绑定的注意事项" class="headerlink" title="Toll-free绑定的注意事项"></a>Toll-free绑定的注意事项</h3><p>要当心下面这种代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">CGColorRef</span>)foo &#123;</div><div class="line">	<span class="built_in">UIColor</span>* color = [<span class="built_in">UIColor</span> redColor];</div><div class="line">	<span class="keyword">return</span> [color <span class="built_in">CGColor</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它任何时候都可能崩溃。由于我们没有保持对UIColor的引用，它可能创建后就立即被释放掉了！CGColor也跟着释放掉了，就会引起崩溃。</p>
<p>有3种方法来修正这个问题：</p>
<ul>
<li><p>使用<code>__autorelease</code>修饰符。这样UIColor就被延迟到当前runloop结束时才被释放，就不会崩溃了。应该是<a href="https://twitter.com/amattn" target="_blank" rel="external">@amattn</a>第一个发现了这种解决方法。</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">CGColorRef</span>)getFooColor &#123;</div><div class="line">	<span class="built_in">UIColor</span> * __autoreleasing color = [<span class="built_in">UIColor</span> redColor];</div><div class="line">	<span class="keyword">return</span> [color <span class="built_in">CGColor</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用Core Foundation的命名规则来改变返回值的所有权。</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">CGColorRef</span>)fooColorCopy &#123;</div><div class="line">	<span class="built_in">UIColor</span>* color = [<span class="built_in">UIColor</span> redColor];</div><div class="line">	<span class="built_in">CGColorRef</span> c = <span class="built_in">CFRetain</span>([color <span class="built_in">CGColor</span>]);</div><div class="line">	<span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">CGColorRef</span> c = [obj fooColorCopy];</div><div class="line"><span class="comment">// do stuffs</span></div><div class="line"><span class="built_in">CFRelease</span>(c);</div></pre></td></tr></table></figure>
</li>
<li><p>用self来持有CF对象。但如果self被dealloc，仍然会引起崩溃。</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">CGColorRef</span>)getFooColor &#123;</div><div class="line">	<span class="built_in">CGColorRef</span> c = <span class="keyword">self</span>.myColor.CGColor;</div><div class="line">	<span class="keyword">return</span> c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ARC中使用Block的注意事项"><a href="#ARC中使用Block的注意事项" class="headerlink" title="ARC中使用Block的注意事项"></a>ARC中使用Block的注意事项</h3><p>如果用block做实例变量，block会隐式的retain self，这样就会造成引用循环。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">	<span class="keyword">id</span> child;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) (<span class="keyword">void</span>(^)(<span class="keyword">void</span>)) job;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)foo &#123;</div><div class="line">	<span class="keyword">self</span>.job = ^&#123;</div><div class="line">		[child work];</div><div class="line">		<span class="comment">// will expand to [self-&gt;child work]</span></div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解决这个问题的方法是使用self的弱引用，然后在block内部临时将弱引用转换为强引用。在block内部使用强引用的原因，是因为我们想确保在使用self的时候它不会被其它人释放掉。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)foo &#123;</div><div class="line">	MyClass * __<span class="keyword">weak</span> w_self = <span class="keyword">self</span>;</div><div class="line">	<span class="keyword">self</span>.block = ^&#123;</div><div class="line">		MyClass *s_self = w_self; <span class="comment">// self retained, but only in this scope!</span></div><div class="line">		<span class="keyword">if</span> (s_self) &#123;</div><div class="line">			[s_self-&gt;child work];</div><div class="line">			<span class="comment">// do other stuffs</span></div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="NSError的注意事项"><a href="#NSError的注意事项" class="headerlink" title="NSError的注意事项"></a>NSError的注意事项</h3><p>实现带NSError参数方法的时候，要注意正确地使用类型修饰符！</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)doStuffWithError:(<span class="built_in">NSError</span> * __autoreleasing *)error; <span class="comment">// correct</span></div><div class="line">- (<span class="keyword">void</span>)doStuffWithError:(__autoreleasing <span class="built_in">NSError</span> **)error; <span class="comment">// wrong!</span></div></pre></td></tr></table></figure>
<p>创建一个NSError对象的时候，通常最好把它定义成一个自动释放对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSError</span> * __autoreleasing error = <span class="literal">nil</span>; <span class="comment">// 正确</span></div><div class="line">__autoreleasing <span class="built_in">NSError</span> *error = <span class="literal">nil</span>; <span class="comment">// 错误</span></div><div class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>; <span class="comment">// clang编译器下正确。(clang编译器会帮我们做优化)</span></div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ARC很方便，但是刚开始使用时可能不容易搞清楚用法。当面对复杂的对象所有权关系时，可以写一些测试代码，看看对象的retain count是怎样的。下面是我用来测试retain count的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)testCGColorRetainCount1 &#123;</div><div class="line">	<span class="built_in">CGColorRef</span> s_ref;</div><div class="line">	<span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">		<span class="built_in">UIColor</span> * __autoreleasing shadowColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.12</span> green:<span class="number">0.12</span> blue:<span class="number">0.12</span> alpha:<span class="number">1.0</span>];</div><div class="line">		s_ref = shadowColor.CGColor;</div><div class="line">		<span class="built_in">CFRetain</span>(s_ref);</div><div class="line">	&#125;</div><div class="line">	STAssertEquals(<span class="built_in">CFGetRetainCount</span>(s_ref), <span class="number">1</span>L, <span class="string">@"retain count owned by us"</span>);</div><div class="line"></div><div class="line">	<span class="built_in">CGColorRef</span>(^strangeBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">		<span class="keyword">return</span> <span class="built_in">CGColorCreateCopy</span>(s_ref);</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="built_in">CGColorRef</span> myCopy = strangeBlock();</div><div class="line">	STAssertEquals(<span class="built_in">CFGetRetainCount</span>(s_ref), <span class="number">2</span>L, <span class="string">@"retain count owned by block and us"</span>);</div><div class="line">	<span class="built_in">CFRelease</span>(s_ref);</div><div class="line">	STAssertEquals(<span class="built_in">CFGetRetainCount</span>(s_ref), <span class="number">1</span>L, <span class="string">@"retain count owned by block"</span>);</div><div class="line">	STAssertEquals(<span class="built_in">CFGetRetainCount</span>(myCopy), <span class="number">1</span>L, <span class="string">@"retain count owned by us"</span>);</div><div class="line">	<span class="built_in">CFRelease</span>(myCopy);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>希望这篇文章对你有帮助！欢迎讨论和分享！</p>
<p>原文：<a href="http://www.idryman.org/blog/2012/11/22/arc-best-practices-and-pitfalls/" target="_blank" rel="external">Effective Obj-C ARC and Pitfalls in It</a></p>
<p>译注：如果还想了解ARC更详细的知识，可以看看官方文档《<a href="http://developer.apple.com/library/ios/#releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Transitioning to ARC Release Notes</a>》或这篇《<a href="http://www.cocoachina.com/bbs/read.php?tid=92507" target="_blank" rel="external">iOS5 ARC完全指南</a>》。</p>
<p style="text-align:center"><img src="/images/posts/thx_money.png" width="50%" height="50%"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C是一个非常酷的编程语言。&lt;a href=&quot;http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TIOBE&lt;/a&gt;已经公布了十一月的编程语言排行榜，Objective-C很可能会再次成为年度编程语言。Objective-C的流行不只是因为iOS和Mac OS X平台的原因，还得益于它在移动设备上的高性能。在Objective-C中，手动内存管理代替了垃圾回收机制。当然，现在Objective-C也不需要纯手动管理内存了，苹果引入了自动引用计数(Automatic Reference Counting, 简称ARC)机制，在编译时自动加入内存管理代码。大部分情况下，这非常棒。然而，当ARC和Core Foundation对象混用的时候，总是感觉很混乱。今天，我们聊聊ARC的要点和陷阱，尤其是用toll-free bridging将Objc对象和CF对象相互转换时的一些注意事项。
    
    </summary>
    
      <category term="Objc" scheme="http://blog.morefun.mobi/categories/Objc/"/>
    
      <category term="翻译" scheme="http://blog.morefun.mobi/categories/Objc/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>改变导航控制器的Push和Pop动画效果</title>
    <link href="http://blog.morefun.mobi/2012/07/07/2012-07-07-gai-bian-uinavigationcontroller-de-push-he-pop-dong-hua/"/>
    <id>http://blog.morefun.mobi/2012/07/07/2012-07-07-gai-bian-uinavigationcontroller-de-push-he-pop-dong-hua/</id>
    <published>2012-07-07T12:00:00.000Z</published>
    <updated>2017-06-16T16:04:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>UINavigationController的push和pop动画只有从右边推入和推出这一种效果。以下代码可以很灵活的改变UINavigationController的push或pop动画效果。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">CATransition</span>* transition = [<span class="built_in">CATransition</span> animation];</div><div class="line">transition.duration = <span class="number">0.5</span>;</div><div class="line">transition.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">transition.type = kCATransitionPush; <span class="comment">//4种: kCATransitionMoveIn, kCATransitionMoveIn, kCATransitionReveal, kCATransitionFade</span></div><div class="line">transition.subtype = kCATransitionFromTop; <span class="comment">//4种: kCATransitionFromLeft, kCATransitionFromRight, kCATransitionFromTop, kCATransitionFromBottom</span></div><div class="line">[<span class="keyword">self</span>.navigationController.view.layer addAnimation:transition forKey:<span class="literal">nil</span>];</div><div class="line">[[<span class="keyword">self</span> navigationController] popViewControllerAnimated:<span class="literal">NO</span>]; <span class="comment">//关键地方：Animated:NO禁用navigationController自带的动画</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UINavigationController的push和pop动画只有从右边推入和推出这一种效果。以下代码可以很灵活的改变UINavigationController的push或pop动画效果。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;tab
    
    </summary>
    
      <category term="动画" scheme="http://blog.morefun.mobi/categories/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="iOS" scheme="http://blog.morefun.mobi/categories/%E5%8A%A8%E7%94%BB/iOS/"/>
    
    
  </entry>
  
</feed>
