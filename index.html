<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Morefun With Coding</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.morefun.mobi/atom.xml" title="Morefun With Coding"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Tinghui" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="mailto:tinghui.zhang3@gmail.com" target="_self" class="nav-list-link">EMAIL</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/08/13/the-keys-to-a-better-text-input-experience-in-iOS/" class="post-title-link">打造更好的iOS文本输入体验</a></h2><div class="post-info">2017年8月13日</div><div class="post-content"><p>做客户端开发，不可避免的需要和文本输入打交道。今天我们来聊聊，如何在iOS里面打造更好的文本输入体验。</p>
<p>全文包含4部分内容：</p>
<p><a href="#1">1. 处理键盘遮挡视图问题</a><br><a href="#2">2. 动态高度的输入框</a><br><a href="#3">3. 记住用户选择的键盘</a><br><a href="#4">4. 自定义键盘</a></p></div><a href="/2017/08/13/the-keys-to-a-better-text-input-experience-in-iOS/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/09/01/2015-09-01-he-shi-shi-yong-updateconstraints/" class="post-title-link">什么时候使用updateConstraints</a></h2><div class="post-info">2015年9月1日</div><div class="post-content"><p>UIView中的<code>updateConstraints</code>方法一直是一个令人纠结的地方。按照<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/#//apple_ref/occ/instm/UIView/updateConstraints" target="_blank" rel="external">苹果官方文档</a>中给出的建议：</p>
<blockquote>
<p>Custom views that set up constraints themselves should do so by overriding this method. When your custom view notes that a change has been made to the view that invalidates one of its constraints, it should immediately remove that constraint, and then call setNeedsUpdateConstraints to note that constraints need to be updated. Before layout is performed, your implementation of updateConstraints will be invoked, allowing you to verify that all necessary constraints for your content are in place at a time when your custom view’s properties are not changing.</p>
</blockquote>
<p>当视图的改变使得某个约束无效时，应当把该约束移除，并调用<code>setNeedsUpdateConstraints</code>以标记视图需要更新约束，然后在<code>updateConstraints</code>中更新约束。</p>
<p>然而，实际上却并不那么好用：</p></div><a href="/2015/09/01/2015-09-01-he-shi-shi-yong-updateconstraints/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/01/28/2015-01-28-autolayoutzhong-de-content-compression-resistancehe-content-huggingdao-di-shi-shi-yao-yi-si/" class="post-title-link">Content Compression Resistance和Content Hugging</a></h2><div class="post-info">2015年1月28日</div><div class="post-content"><p>AutoLayout中，<code>Content Compression Resistance</code>和<code>Content Hugging</code>这两个概念，从字面上很难理解它们意思和用途，苹果官方文档中相关描述也比较少。中文翻译中大多数都把它们按字面翻译成<code>内容压缩阻力</code>和<code>内容吸附性</code>，也不是很好理解。最近搜索和查看了一些文章和资料，搞清楚了它们的作用，在此整理一下。</p></div><a href="/2015/01/28/2015-01-28-autolayoutzhong-de-content-compression-resistancehe-content-huggingdao-di-shi-shi-yao-yi-si/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/10/15/2014-10-15-shi-yong-autolayoutshi-xian-uitableviewde-celldong-tai-bu-ju-he-ke-bian-xing-gao/" class="post-title-link">使用Autolayout实现UITableView的Cell动态布局和动态行高</a></h2><div class="post-info">2014年10月15日</div><div class="post-content"><p>本文翻译自：<a href="http://stackoverflow.com/questions/18746929/using-auto-layout-in-uitableview-for-dynamic-cell-layouts-variable-row-heights" target="_blank" rel="external">stackoverflow</a></p>
<p>有人在<a href="http://stackoverflow.com/questions/18746929/using-auto-layout-in-uitableview-for-dynamic-cell-layouts-variable-row-heights" target="_blank" rel="external">stackoverflow</a>上问了一个问题：</p>
<blockquote>
<p>如何在UITableViewCell中使用Autolayout来实现Cell的内容和子视图自动计算行高，并且保持平滑的滚动？</p>
</blockquote>
<p>这个问题获得了接近1000的支持和1100+的收藏，答案更是超过了1800+的支持，很详细的说明了如何在iOS7和iOS8上实现UITableView的动态行高计算。答案对实现UICollectionView的动态行高也具有参考意义，所以在这里将这个答案翻译了一下，希望对大家有所帮助。以下是答案的全文翻译：</p>
<p>全文略长，不喜欢阅读可以直接看示例代码：</p>
<ul>
<li><a href="https://github.com/smileyborg/TableViewCellWithAutoLayoutiOS8" target="_blank" rel="external">iOS8的示例代码</a> - iOS8以上才支持</li>
<li><a href="https://github.com/smileyborg/TableViewCellWithAutoLayout" target="_blank" rel="external">iOS7的示例代码</a> - iOS7+</li>
</ul></div><a href="/2014/10/15/2014-10-15-shi-yong-autolayoutshi-xian-uitableviewde-celldong-tai-bu-ju-he-ke-bian-xing-gao/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/07/15/2014-07-15-you-objective-cdao-swiftde-xie-gan-xiang-he-ti-shi/" class="post-title-link">Objective-C到Swift：一些想法和建议</a></h2><div class="post-info">2014年7月15日</div><div class="post-content"><p>本文分享一些在由Objective-C转换至Swift的过程中产生的思考，并尝试总结了一些技巧建议和一些误区陷阱。本文尽量通过对比来展示这两种语言在同一个问题上的不同处理方法。开始吧！</p>
<h2 id="单文件-vs-接口-实现文件"><a href="#单文件-vs-接口-实现文件" class="headerlink" title="单文件 vs. 接口-实现文件"></a>单文件 vs. 接口-实现文件</h2><p>第一个重大的变化是：<code>interface.h/implementation.m</code>的文件结构被舍弃了。</p>
<p>我是这种文件结构的坚定支持者。只通过接口文件来获取或共享类相关的信息，不仅安全而且很方便。</p>
<p>在Swift中，接口和实现并没有分离。我们只能实现自己的类（并且在写代码的时候甚至不能添加可见性修饰符）。<br></div><a href="/2014/07/15/2014-07-15-you-objective-cdao-swiftde-xie-gan-xiang-he-ti-shi/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/05/17/2014-05-17-yi-model-view-viewmodel-for-ios/" class="post-title-link">iOS的Model-View-ViewModel模式</a></h2><div class="post-info">2014年5月17日</div><div class="post-content"><p>如果你已经做过一段时间的iOS开发，那么你一定听说过模型—视图—控制器或MVC模式。这是构建iOS应用的标准方式。不过最近，我越来越厌倦MVC的缺点。本文，我们先重温一下MVC是什么，它有什么缺点。然后再介绍一种构建应用的新方式：Model-View-ViewModel。</p>
<h2 id="Model-View-Controller"><a href="#Model-View-Controller" class="headerlink" title="Model-View-Controller"></a>Model-View-Controller</h2><p>模型-视图-控制器模式(Model-View-Controller)是构造代码的权威范式。苹果甚至<a href="https://developer.apple.com/library/ios/documentation/general/conceptual/devpedia-cocoacore/MVC.html" target="_blank" rel="external">这么说</a>。MVC模式，所有对象都被界定为，要么是一个模型，要么是一个视图，或者要么是一个控制器。模型持有数据，视图向用户呈现一个可交互的界面，视图控制器做模型和视图之间的中介者。</p>
<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/mvc1.png" alt=""></p>
<p>这个图表中，视图将用户交互通知给控制器。然后视图控制器根据这个状态的变化来更新模型。然后该模型通知(通常是通过KVO的方式)相关的控制器更新它们的视图。iOS应用大部分代码都采用这种机制。<br></div><a href="/2014/05/17/2014-05-17-yi-model-view-viewmodel-for-ios/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/04/15/2014-04-15-shi-yong-nssecurecodingxie-yi-jin-xing-bian-jie-ma/" class="post-title-link">使用NSSecureCoding协议进行编解码</a></h2><div class="post-info">2014年4月15日</div><div class="post-content"><p>在iOS和Mac OS上，<code>NSCoding</code>是一种简单方便的数据存储方法。它可以直接将你的数据模型对象写入一个文件，之后又可以直接将它们读入内存而不需要编写任何文件解析和序列化的逻辑。将一个对象（假设它已经实现了NSCoding协议）保存至一个文件，只需要这样做：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">Foo *someFoo = [[Foo alloc] init];</div><div class="line">[<span class="built_in">NSKeyedArchiver</span> archiveRootObject:someFoo toFile:someFile];</div></pre></td></tr></table></figure>
<p>之后要加载时，只需要这样：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">Foo *someFoo = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:someFile];</div></pre></td></tr></table></figure></div><a href="/2014/04/15/2014-04-15-shi-yong-nssecurecodingxie-yi-jin-xing-bian-jie-ma/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/03/21/2014-03-21-yi-7chong-chang-jian-de-dai-ma-wen-ti/" class="post-title-link">7种常见的代码问题</a></h2><div class="post-info">2014年3月21日</div><div class="post-content"><p>我进行过很多代码审查，其中有7种最常见的代码问题。</p>
<h2 id="被注释掉的代码"><a href="#被注释掉的代码" class="headerlink" title="被注释掉的代码"></a>被注释掉的代码</h2><p>这让我觉得你没有学会如何使用版本控制工具和标记功能。如果这些旧代码已经不再有用了，我干嘛还需要读它！？</p>
<p>如果它很重要，将来你可能会需要返回来查看它。那么你可以在版本控制工具中给它添加一个适当的标记，然后把它从当前代码中移除掉。<br></div><a href="/2014/03/21/2014-03-21-yi-7chong-chang-jian-de-dai-ma-wen-ti/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/03/16/2014-03-16-yi-adopting-modern-objective-c/" class="post-title-link">Adopting Modern Objective-C</a></h2><div class="post-info">2014年3月16日</div><div class="post-content"><p>苹果2014年03月10日发布了一个新文档，介绍了Objective-C的几个新技巧，包括：</p>
<ul>
<li><a href="#instancetype">用instancetype代替id</a></li>
<li><a href="#property">用@property代替实例变量</a></li>
<li><a href="#enum">用NS_ENUM或NS_OPTIONS代替enum</a></li>
<li><a href="#arc">采用ARC</a></li>
</ul>
<p>文档名字叫《<a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/RevisionHistory.html#//apple_ref/doc/uid/TP40014150-CH99-SW1" target="_blank" rel="external">Adopting Modern Objective-C</a>》，将它翻译成中文了，以下是正文。<br></div><a href="/2014/03/16/2014-03-16-yi-adopting-modern-objective-c/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/02/11/2014-02-11-ni-xu-yao-zhi-dao-de-suo-you-guan-yu-ioshe-os-xyi-qi-yong-de-apide-shi-er/" class="post-title-link">关于iOS和OS X废弃的API你需要知道的一切</a></h2><div class="post-info">2014年2月11日</div><div class="post-content"><p>已废弃(Deprecated)的API指的是那些已经过时并且在将来某个时间最终会被移除掉的方法或类。通常，苹果在引入一个更优秀的API后就会把原来的API给废弃掉。因为，新引入的API通常意味着可以更好的发挥新硬件或操作系统的性能，或者可以使用一些在构建原有API时根本还没有的语言特性(e.g. blocks)。</p>
<p>每当苹果添加新方法的时候，他们都会在方法声明的后面用一个很特殊的宏来标明哪些iOS版本支持它们。例如，在UIViewController中，苹果引入了一个使用block来处理回调的方法用来展示一个模态controller，它的声明是这样的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)presentViewController:(<span class="built_in">UIViewController</span> *)viewControllerToPresent animated: (<span class="built_in">BOOL</span>)flag completion:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completion <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div></pre></td></tr></table></figure>
<p>注意到<code>NS_AVAILABLE_IOS(5_0)</code>了吗？这就告诉我们这个方法可以在iOS5.0及以后的版本中使用。如果我们在比指定版本更老的版本中调用这个方法，就会引起崩溃。</p></div><a href="/2014/02/11/2014-02-11-ni-xu-yao-zhi-dao-de-suo-you-guan-yu-ioshe-os-xyi-qi-yong-de-apide-shi-er/" class="read-more">...阅读全文</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">下一页</a></div><div class="copyright"><p>© 2012 - 2017 <a href="http://blog.morefun.mobi">Tinghui</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>