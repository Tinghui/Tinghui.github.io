<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Coding With MoreFun</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.morefun.mobi/atom.xml" title="Coding With MoreFun"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Tinghui" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="mailto:tinghui.zhang3@gmail.com" target="_self" class="nav-list-link">EMAIL</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/01/25/2018-01-25-copy-on-write-in-swift/" class="post-title-link">Swift的写时复制机制</a></h2><div class="post-info">2018年1月25日</div><div class="post-content"><p>在Swift中，我们有引用类型（比如：类）和值类型（比如：结构体、元组、枚举）。值类型具有复制语义。这意味着如果你将一个值类型分配给一个变量，该值的底层数据将会被复制。你会得到两个具有相同内容的值，但分配在不同的内存地址中。</p>
<p>如下例所示，把<code>str1</code>赋值给<code>str2</code>后，<code>str2</code>的内容和<code>str1</code>的内容相同，都是字符串“Hello”，但两个值的内存地址不同。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> str1 = <span class="string">"Hello"</span>  <span class="comment">//Hello</span></div><div class="line"><span class="keyword">var</span> str2 = str1     <span class="comment">//Hello，str1的内容被复制给str2，str2的内容和str1的内容一样</span></div><div class="line"></div><div class="line">address(of: str1)   <span class="comment">//0x604000059670</span></div><div class="line">address(of: str2)   <span class="comment">//0x604000059cd0</span></div></pre></td></tr></table></figure>
<p>然而，把包含大量信息的值类型作为参数分配或传递给函数时，对于性能来说，复制是非常昂贵的操作。为了尽量减少这个问题，Swift标准库为一些值类型（比如数组、字典）实现了一套叫做<strong><a href="https://zh.wikipedia.org/wiki/寫入時複製" target="_blank" rel="external">写时复制</a></strong>的机制。</p>
<p>其核心思想是，如果有多个调用者（callers）同时要求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。</p>
<p>所以，如果只是将数组分配给一个变量或将其传递给一个函数并不会复制它，直到对它进行修改时才可能会进行复制，这样就提高了性能。</p></div><a href="/2018/01/25/2018-01-25-copy-on-write-in-swift/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/11/27/2017-11-27-ios-tdd-intro/" class="post-title-link">iOS测试驱动开发入门介绍</a></h2><div class="post-info">2017年11月27日</div><div class="post-content"><p>1996年，Kent Beck提出了一个称作<a href="https://zh.wikipedia.org/wiki/极限编程" target="_blank" rel="external"><strong>极限编程</strong></a>(Extreme Programming)的软件开发方法。它基于12条编程实践规则，其中一条规则倡导：开发者必须编写单元测试，并且软件的所有部分都必须经过彻底的测试。所有测试都必须在软件(或新功能)发布给客户之前通过。应当先于测试的生产代码之前编写测试。</p>
<p>这种测试优先的程序设计方法被称作<a href="https://zh.wikipedia.org/wiki/测试驱动开发" target="_blank" rel="external">测试驱动开发</a>(Test-Driven Development，以下简称TDD)。<strong>它的基本思想是在开发功能代码之前，先编写测试代码。</strong>也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，完成测试代码的编写，然后再编写相关的实际功能代码，以满足这些测试用例。然后如此继续添加其他功能，直至完成全部功能的开发。<br></div><a href="/2017/11/27/2017-11-27-ios-tdd-intro/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/08/13/2017-08-13-the-keys-to-a-better-text-input-experience-in-iOS/" class="post-title-link">打造更好的iOS文本输入体验</a></h2><div class="post-info">2017年8月13日</div><div class="post-content"><p>做客户端开发，不可避免的需要和文本输入打交道。今天我们来聊聊，如何在iOS里面打造更好的文本输入体验。</p>
<p>全文包含4部分内容：</p>
<p><a href="#1">1. 处理键盘遮挡视图问题</a><br><a href="#2">2. 动态高度的输入框</a><br><a href="#3">3. 记住用户选择的键盘</a><br><a href="#4">4. 自定义键盘</a></p></div><a href="/2017/08/13/2017-08-13-the-keys-to-a-better-text-input-experience-in-iOS/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/09/01/2015-09-01-he-shi-shi-yong-updateconstraints/" class="post-title-link">什么时候使用updateConstraints</a></h2><div class="post-info">2015年9月1日</div><div class="post-content"><p>UIView中的<code>updateConstraints</code>方法一直是一个令人纠结的地方。按照<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/#//apple_ref/occ/instm/UIView/updateConstraints" target="_blank" rel="external">苹果官方文档</a>中给出的建议：</p>
<blockquote>
<p>Custom views that set up constraints themselves should do so by overriding this method. When your custom view notes that a change has been made to the view that invalidates one of its constraints, it should immediately remove that constraint, and then call setNeedsUpdateConstraints to note that constraints need to be updated. Before layout is performed, your implementation of updateConstraints will be invoked, allowing you to verify that all necessary constraints for your content are in place at a time when your custom view’s properties are not changing.</p>
</blockquote>
<p>当视图的改变使得某个约束无效时，应当把该约束移除，并调用<code>setNeedsUpdateConstraints</code>以标记视图需要更新约束，然后在<code>updateConstraints</code>中更新约束。</p>
<p>然而，实际上却并不那么好用：</p></div><a href="/2015/09/01/2015-09-01-he-shi-shi-yong-updateconstraints/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/01/28/2015-01-28-autolayoutzhong-de-content-compression-resistancehe-content-huggingdao-di-shi-shi-yao-yi-si/" class="post-title-link">Content Compression Resistance和Content Hugging</a></h2><div class="post-info">2015年1月28日</div><div class="post-content"><p>AutoLayout中，<code>Content Compression Resistance</code>和<code>Content Hugging</code>这两个概念，从字面上很难理解它们意思和用途，苹果官方文档中相关描述也比较少。中文翻译中大多数都把它们按字面翻译成<code>内容压缩阻力</code>和<code>内容吸附性</code>，也不是很好理解。最近搜索和查看了一些文章和资料，搞清楚了它们的作用，在此整理一下。</p></div><a href="/2015/01/28/2015-01-28-autolayoutzhong-de-content-compression-resistancehe-content-huggingdao-di-shi-shi-yao-yi-si/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/10/15/2014-10-15-shi-yong-autolayoutshi-xian-uitableviewde-celldong-tai-bu-ju-he-ke-bian-xing-gao/" class="post-title-link">使用Autolayout实现UITableView的Cell动态布局和动态行高</a></h2><div class="post-info">2014年10月15日</div><div class="post-content"><p>本文翻译自：<a href="http://stackoverflow.com/questions/18746929/using-auto-layout-in-uitableview-for-dynamic-cell-layouts-variable-row-heights" target="_blank" rel="external">stackoverflow</a></p>
<p>有人在<a href="http://stackoverflow.com/questions/18746929/using-auto-layout-in-uitableview-for-dynamic-cell-layouts-variable-row-heights" target="_blank" rel="external">stackoverflow</a>上问了一个问题：</p>
<blockquote>
<p>如何在UITableViewCell中使用Autolayout来实现Cell的内容和子视图自动计算行高，并且保持平滑的滚动？</p>
</blockquote>
<p>这个问题获得了接近1000的支持和1100+的收藏，答案更是超过了1800+的支持，很详细的说明了如何在iOS7和iOS8上实现UITableView的动态行高计算。答案对实现UICollectionView的动态行高也具有参考意义，所以在这里将这个答案翻译了一下，希望对大家有所帮助。以下是答案的全文翻译：</p>
<p>全文略长，不喜欢阅读可以直接看示例代码：</p>
<ul>
<li><a href="https://github.com/smileyborg/TableViewCellWithAutoLayoutiOS8" target="_blank" rel="external">iOS8的示例代码</a> - iOS8以上才支持</li>
<li><a href="https://github.com/smileyborg/TableViewCellWithAutoLayout" target="_blank" rel="external">iOS7的示例代码</a> - iOS7+</li>
</ul></div><a href="/2014/10/15/2014-10-15-shi-yong-autolayoutshi-xian-uitableviewde-celldong-tai-bu-ju-he-ke-bian-xing-gao/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/07/15/2014-07-15-you-objective-cdao-swiftde-xie-gan-xiang-he-ti-shi/" class="post-title-link">Objective-C到Swift：一些想法和建议</a></h2><div class="post-info">2014年7月15日</div><div class="post-content"><p>本文分享一些在由Objective-C转换至Swift的过程中产生的思考，并尝试总结了一些技巧建议和一些误区陷阱。本文尽量通过对比来展示这两种语言在同一个问题上的不同处理方法。开始吧！</p>
<h2 id="单文件-vs-接口-实现文件"><a href="#单文件-vs-接口-实现文件" class="headerlink" title="单文件 vs. 接口-实现文件"></a>单文件 vs. 接口-实现文件</h2><p>第一个重大的变化是：<code>interface.h/implementation.m</code>的文件结构被舍弃了。</p>
<p>我是这种文件结构的坚定支持者。只通过接口文件来获取或共享类相关的信息，不仅安全而且很方便。</p>
<p>在Swift中，接口和实现并没有分离。我们只能实现自己的类（并且在写代码的时候甚至不能添加可见性修饰符）。<br></div><a href="/2014/07/15/2014-07-15-you-objective-cdao-swiftde-xie-gan-xiang-he-ti-shi/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/05/17/2014-05-17-yi-model-view-viewmodel-for-ios/" class="post-title-link">iOS的Model-View-ViewModel模式</a></h2><div class="post-info">2014年5月17日</div><div class="post-content"><p>如果你已经做过一段时间的iOS开发，那么你一定听说过模型—视图—控制器或MVC模式。这是构建iOS应用的标准方式。不过最近，我越来越厌倦MVC的缺点。本文，我们先重温一下MVC是什么，它有什么缺点。然后再介绍一种构建应用的新方式：Model-View-ViewModel。</p>
<h2 id="Model-View-Controller"><a href="#Model-View-Controller" class="headerlink" title="Model-View-Controller"></a>Model-View-Controller</h2><p>模型-视图-控制器模式(Model-View-Controller)是构造代码的权威范式。苹果甚至<a href="https://developer.apple.com/library/ios/documentation/general/conceptual/devpedia-cocoacore/MVC.html" target="_blank" rel="external">这么说</a>。MVC模式，所有对象都被界定为，要么是一个模型，要么是一个视图，或者要么是一个控制器。模型持有数据，视图向用户呈现一个可交互的界面，视图控制器做模型和视图之间的中介者。</p>
<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/mvc1.png" alt=""></p>
<p>这个图表中，视图将用户交互通知给控制器。然后视图控制器根据这个状态的变化来更新模型。然后该模型通知(通常是通过KVO的方式)相关的控制器更新它们的视图。iOS应用大部分代码都采用这种机制。<br></div><a href="/2014/05/17/2014-05-17-yi-model-view-viewmodel-for-ios/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/04/15/2014-04-15-shi-yong-nssecurecodingxie-yi-jin-xing-bian-jie-ma/" class="post-title-link">使用NSSecureCoding协议进行编解码</a></h2><div class="post-info">2014年4月15日</div><div class="post-content"><p>在iOS和Mac OS上，<code>NSCoding</code>是一种简单方便的数据存储方法。它可以直接将你的数据模型对象写入一个文件，之后又可以直接将它们读入内存而不需要编写任何文件解析和序列化的逻辑。将一个对象（假设它已经实现了NSCoding协议）保存至一个文件，只需要这样做：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">Foo *someFoo = [[Foo alloc] init];</div><div class="line">[<span class="built_in">NSKeyedArchiver</span> archiveRootObject:someFoo toFile:someFile];</div></pre></td></tr></table></figure>
<p>之后要加载时，只需要这样：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">Foo *someFoo = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:someFile];</div></pre></td></tr></table></figure></div><a href="/2014/04/15/2014-04-15-shi-yong-nssecurecodingxie-yi-jin-xing-bian-jie-ma/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/03/21/2014-03-21-yi-7chong-chang-jian-de-dai-ma-wen-ti/" class="post-title-link">7种常见的代码问题</a></h2><div class="post-info">2014年3月21日</div><div class="post-content"><p>我进行过很多代码审查，其中有7种最常见的代码问题。</p>
<h2 id="被注释掉的代码"><a href="#被注释掉的代码" class="headerlink" title="被注释掉的代码"></a>被注释掉的代码</h2><p>这让我觉得你没有学会如何使用版本控制工具和标记功能。如果这些旧代码已经不再有用了，我干嘛还需要读它！？</p>
<p>如果它很重要，将来你可能会需要返回来查看它。那么你可以在版本控制工具中给它添加一个适当的标记，然后把它从当前代码中移除掉。<br></div><a href="/2014/03/21/2014-03-21-yi-7chong-chang-jian-de-dai-ma-wen-ti/" class="read-more">...阅读全文</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">下一页</a></div><div class="copyright"><p>© 2012 - 2018 <a href="http://blog.morefun.mobi">Tinghui</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>